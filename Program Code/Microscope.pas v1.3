program Microscope;	{$B+}															   {Set bundle bit so finder will use my icon}	{$T APPLMICR}										{set my file type and creator} {$U-}                  {Use My own include Librarys} {$U Jim Surine:Programming:Units:Mews Units:Serial} {$U Jim Surine:Programming:Units:My Units:JimIO}  {$R Jim Surine:Programming:Reasources:Microscope.Rsrc}									{Load my reasources (dialog boxes etc..)} {$S+}                  {Use Segments} {$I-} {$O Jim Surine:Programming:Programs:Microscopes:Microscope v1.3} USES   Memtypes,       {Basic types stanadard}  QuickDraw,      {Quickdraw standard}  OSIntf,         {Operating system standard}  ToolIntf,       {Tools standard}    PackIntf,       {Package stuff (List Manager, Decimal to string convert)}  PasInOut,       {Pascal File interface}  MacPrint,       {Printer driver}  Serial,         {RS232 port driver}  JimIO;          {File access driver}	type		{My Types}		arr4=			array[1..4] of real;		{arrary of 4 reals}		ari4=			array[1..4] of integer;	{Arrary of 4 integers}		strtype=			string[10];							{string size to shrink record size when writing to disk} 		HeaderType=								{Header storage record definition} 			record 				Reply:SfReply;				{current File system reply from last load} 				NumParticle:Integer;	{counter holds number of particles in list} 				Beam:strtype; 				Date:strtype; 				Event:strtype; 				operator:strtype; 				Plate:strtype; 				part:strtype; 				Rangetostar:strtype; 				ShrinkFactZT:Real; 				ShrinkFactZM:Real; 				ShrinkFactAN:Real; 				Magnification:Real; 				ZZO:Real; 				X:arr4; 				y:arr4; 				z:arr4; 				slopexy:real;	 				slopezy:real; 				Primary:strtype; 				Frag:strtype; 				a:strtype; 				p:strtype; 				M:strtype; 				NB:ari4; 				G1:ari4; 				G2:ari4; 				G3:ari4; 				NH:ari4; 				energyQ:arr4;     FBlack:integer;     BBlack:integer;     NBlack:integer; 				FtoBBlack:real;     FGrey:integer;     BGrey:integer;     NGrey:integer; 				FtoBGrey:real;         NHtotal:integer;     energytotal:real; 			end;		ParticlePtr=							  {pointers are used to access particles in list because list Record can hold}			^ParticleType;		 			{only 32K of data, not much room for particles 212 bytes long, so only a pointer}															        {to the data is saved in the list record and the particle data is stored elsewhere }                       {leaving room in the list record for about max 3000 particles in list}															 		ParticleType=							{Holds each particle information} 			record 				Number:strtype;				{Particle information} 				xsec:real; 				ysec:real; 				zsec:real; 				GrainCount:real; 				P:real; 				L:real;				beta:real;					{beta}				degrees:real;				{beta expressed in degrees}				azimuth:real;				{azimuth angle}				azidegree:real;			{azimuth angle expressed in degress}				pseudo:real;				{pseudoripidity}									{slope of children particles with respect to the primary}				deltax:real;						{the value calculated from the raw data}				deltay:real;						{the value calculated from the raw data}				deltaz:real;                         {the value calculated from the raw data}				bigx:real;				bigz:real;				deltar:real;				xstar:real;				ystar:real;				zstar:real;			end;  TheFile = record              {would be used for multiple windows not used now}                  Header:HeaderType;                  List:ListHandle;                  ListWindow:WindowPtr;                  InMem,           {is This File Valid}                  FromFile,								{was this file new or from disk}	                 changed:								 {has it been changed}			                 Boolean;                  PgSetUp:								{printer values}			                 THPrint;                 end;	const		HeaderNHRes=						{reasource numbers of dialog boxes}			6000;		ParticleNHRes=			6001;		DebugRes=			6002;		AreSureRes=			6003;		AboutRes=			6004;		HeaderLTRes=			6005;		ParticleLTRes=			6006;					appleMenu =							{reasource number of menus}			300;		fileMenu =			301;		editMenu =			302;		particleMenu =			303;		HeaderMenu =			304;		beginMenu =			300;		endMenu =			304;		pi=			3.1415926535898;	var		{Mac Varibles}		Done:										{program done flag}			Boolean;		myMenus:								{Handles to each menu}			 array[beginMenu..endMenu] of MenuHandle;		DragArea,								{area that make sure you don't drag somting off the screen}		GrowArea:								{Largest window grow hopully smaller than the screen}			Rect;		PgSetUp:								{Global printer values}			THPrint;       {Page setup info}		MyStRec:								{print record}			TPrStatus;		PrinterPort:				{graphic port for printing}			TPPrPort;  PrintDlgDo:     {Flag for if you want to have standard printing dialog at beginning of print used for finder print}    Boolean;{My Global Varibles}		InMem,									{is a file in memory}		FromFile,						{was this file new or from disk}		changed:							{has it been changed}			Boolean;		Header:								{only one header so global}			HeaderType;		List:										{only one list so global}			ListHandle;		ListWindow:				{only one window to go with one list so global}			WindowPtr;{********************}	procedure DebugDialog(TheInteger:integer);   {simple pop use dialog for debuging}    	forward;     procedure AreYouSure(	TheString	:Str255;var cancel	:boolean);    forward;     procedure UpdateListWindow(var ListWindow:WindowPtr;var List: ListHandle;Header:HeaderType);        forward;         procedure DrawHeader;        forward;         procedure cleanHeader;        forward;         procedure HeaderDefault;        forward;        Procedure DisposeList(Var List:ListHandle;var ListWIndow:WindowPtr);      var    i:integer;    ParticlePointer:particlePtr;    last:cell;    len:integer;        begin						for i := 1 to Header.NumParticle do							 begin								 len:=SizeOf(ParticlePointer);								 last.h:=0;						   Last.v:=i-1;				     LGetCell(pointer(ord(@ParticlePointer)),Len,Last,List);							 	Dispose(ParticlePointer);						 end;     Header.NumParticle:=0;					LDispose(List);					CloseWindow(listWindow);    end;{****************************************************}	procedure calcparticle(var particle:particletype;header:headertype);		procedure changeofxyz(var particle:particletype;header:headertype);			begin{ changeofxyz}				particle.deltay:=(particle.ysec-particle.ystar)*1000;				particle.deltax:=(particle.xsec-particle.xstar)*(header.Magnification)-(header.slopexy*particle.deltay);				particle.deltaz:=(particle.zsec-particle.zstar)*(header.ShrinkFactAN)-(header.slopezy*particle.deltay);			end;{ changeofxyz}		procedure answer(var particle:particletype);			procedure beta(var particle:particletype);				{calculates beta}				begin					particle.beta:=arctan(sqrt(sqr(particle.deltax)+sqr(particle.deltaz))/abs(particle.deltay));					If particle.deltay>0 then						particle.beta:= pi+(-particle.beta);					particle.degrees:=particle.beta*180/pi;				end;			procedure pseudoripidity(var particle:particletype);				{calculates pseudoripidity}				begin					particle.pseudo:=-ln(abs(sin(particle.beta/2)/cos(particle.beta/2)));				end;			procedure azimuthangle(var particle:particletype);				{calculates azimuth angle}				begin					if particle.deltaz=0 then						particle.azimuth:=(pi/2)					else						 particle.azimuth:=arctan(abs(particle.deltax/particle.deltaz));					if particle.deltaz<>0 then						begin							if abs(particle.deltax/particle.deltaz)<>(particle.deltax/particle.deltaz) then								particle.azimuth:=-particle.azimuth;						end					else						if particle.deltax<0 then							particle.azimuth:=-particle.azimuth;					if particle.deltaz>=0 then						begin							if particle.deltax<0 then								particle.azimuth:=particle.azimuth+2*pi;						end					else						particle.azimuth:=particle.azimuth+pi;					particle.azidegree:=particle.azimuth*180/pi;				end;			procedure calcxandz(var particle:particletype);				begin{calcxandz}					particle.deltar:=1000*sin(particle.beta)/cos(particle.beta);					particle.bigx:=particle.deltar*sin(particle.azimuth);					particle.bigz:=particle.deltar*cos(particle.azimuth);				end;{calcxandz}			begin{answer}				beta(particle);				pseudoripidity(particle);				azimuthangle(particle);				calcxandz(particle);			end;{answer}		begin{calcparticle}			changeofxyz(particle,header);			answer(particle);		end;{calcparticle}	procedure calcheader(var Header:HeaderType);		{Michael Heinrich}		{8/20/86}		{The purpose of this program is to }		{calculate theta, phi,pseudoripidity}		{for particles given a primary and secondary}		{measurements on the particles}		{this is only part of the overall developement}		{the input and output of data will be handled}		{by other parts of the program}		{print option not on disk}		{calculates the dip of the primary}		var				j:integer;{indice counter throughout}				sumx,sumy,sumxy,sumx2:real;{least squares stuff}				K:integer;		Procedure NHEnergy(var header:headertype);			var				k:integer;			begin{NHEnergy}				with header do					begin						for k:=1 to 4 do							begin								energyQ[k]:=12.5*NB[k]+54*G1[k]+146*G2[k]+299*G3[k];								NH[k]:=NB[k]+G1[k]+G2[k]+G3[k];							end;						energytotal:=energyQ[1]+energyQ[2]+energyQ[3]+energyQ[4];						NHtotal:=NH[1]+NH[2]+NH[3]+NH[4];      FBlack:=NB[1]+NB[4];      BBlack:=NB[2]+NB[3];      NBlack:=FBlack+BBlack;						FtoBBlack:=FBlack/BBlack;      FGrey:=G1[1]+G2[1]+G3[1]+G1[4]+G2[4]+G3[4];      BGrey:=G1[2]+G2[2]+G3[2]+G1[3]+G2[3]+G3[3];      NGrey:=FGrey+BGrey;						FtoBGrey:=FGrey/BGrey;					end;			end;{NHEnergy}		Procedure RecalcParticles(header:HeaderType);			var				i:Integer;				Last:Cell;				particle:ParticleType;				ParticlePointer:ParticlePtr;				len:integer;			begin    LDoDraw(False,List);				len:=SizeOf(ParticlePointer);				last.h:=0;				for i := 1 to Header.NumParticle do					begin						Last.v:=i-1;						LGetCell(pointer(ord(@ParticlePointer)),Len,Last,List);						Particle:=ParticlePointer^;						CalcParticle(Particle,Header);						ParticlePointer^:=Particle;						LSetCell(pointer(ord(@ParticlePointer)),len,Last,List);					end;    LDoDraw(true,List);			end;		begin{calprimary}    {The following includes a least squares fit added by James Amundson 1/29/87}			with header do				begin					sumx:=0;     sumy:=0;     sumxy:=0;     sumx2:=0;					if (x[4]=0) and (y[4]=0) and (z[4]=0) then						k:=3					else					 	k:=4;					for j:=1 to k do        begin				    	sumx:=sumx+y[j];         sumy:=sumy+x[j];         sumxy:=sumxy+x[j]*y[j];         sumx2:=sumx2+sqr(y[j]);        end;					slopexy :=(k*sumxy-sumx*sumy)/(k*sumx2-sqr(sumx))/1000*(Magnification);					sumx:=0;     sumy:=0;     sumxy:=0;     sumx2:=0;					if Header.ShrinkFactZM<>0 then				    	Header.ShrinkFactAN:=Header.ShrinkFactZT/Header.ShrinkFactZM;{Note that, for this section, z values are put in x for least squares}					for j:=1 to k do        begin				    	sumx:=sumx+y[j];         sumy:=sumy+z[j];         sumxy:=sumxy+z[j]*y[j];         sumx2:=sumx2+sqr(y[j]);        end;					slopezy :=(k*sumxy-sumx*sumy)/(k*sumx2-sqr(sumx))/1000*(ShrinkFactAN);				end;			NHEnergy(header);			RecalcParticles(Header);		end;{calprimary}{********************************************}  	procedure NoFileMenu;  {dulls out menu stuff for when no file is in memory}    		begin  			Enableitem(MyMenus[appleMenu],0);  			Enableitem(MyMenus[appleMenu],1);  			Enableitem(MyMenus[fileMenu],0);  			Enableitem(MyMenus[fileMenu],1);  			Enableitem(MyMenus[fileMenu],2);  			DisableItem(MyMenus[fileMenu],3);			 	DisableItem(MyMenus[fileMenu],5);			 	DisableItem(MyMenus[fileMenu],6);			 	DisableItem(MyMenus[fileMenu],7);			 	EnableItem(MyMenus[fileMenu],9);			 	DisableItem(MyMenus[fileMenu],10);			 	EnableItem(MyMenus[fileMenu],12);							 	DisableItem(MyMenus[ParticleMenu],0);							 	DisableItem(MyMenus[HeaderMenu],0);  		end;  	procedure NewMenuNone;      {dulls out menu stuff for when you have a new file with no particles}  		begin  			NoFileMenu;  			EnableItem(MyMenus[FileMenu],3);			 	EnableItem(MyMenus[FileMenu],6);			 	EnableItem(MyMenus[FileMenu],10);			 	EnableItem(MyMenus[ParticleMenu],0);			 	EnableItem(MyMenus[ParticleMenu],1);			 	EnableItem(MyMenus[ParticleMenu],2);				 DisableItem(MyMenus[Particlemenu],3);			 	DisableItem(MyMenus[ParticleMenu],4);			 	DisableItem(MyMenus[ParticleMenu],5);			 	Enableitem(MyMenus[HeaderMenu],0);			 	Enableitem(MyMenus[HeaderMenu],1);			 	Enableitem(MyMenus[HeaderMenu],2);  		end;  	procedure NewMenuSome;    {dulls out menu stuff for when you have a new file with some particles}      		begin  			NewMenuNone;  			EnableItem(MyMenus[ParticleMenu],3);  			EnableItem(MyMenus[ParticleMenu],4);			 	EnableItem(MyMenus[ParticleMenu],5);  		end;  	procedure OldMenuNone;    {Dulls out menus for when you have a file from disk with no particles}      		begin			 	NewMenuNone;			 	EnableItem(MyMenus[FileMenu],5);			 	EnableItem(MyMenus[FileMenu],7);  		end;  	procedure OldMenuSome;{Dulls out menus for when you have a file from disk with some particles}  		begin  			OldMenuNone;  			EnableItem(MyMenus[ParticleMenu],3);  			EnableItem(MyMenus[ParticleMenu],4);			 	EnableItem(MyMenus[ParticleMenu],5);  		end;  	procedure DrawMenu;    {Goes through and order of priority of menu dulling to get the right menu for the situation}      		begin  			if InMem then  				if fromFile then  					if Header.NumParticle = 0 then  						OldMenuNone  					else  						OldMenuSome  				else  					if Header.NumParticle = 0 then  						NewMenuNone  					else  						NewMenuSome  			else  				NoFileMenu;  			DrawMenuBar;  		end;  {************************}    {Procedures to convert real numbers to strings and back for use with dialog and window, entry and display}	function Power10 (Expo : integer) : longint;		var			power : longint;			i : integer;		begin			power := 1;			if power <> 0 then				for i := 1 to expo do			power := Power * 10;			power10 := Power;		end;	procedure Real2String ( WholeNumber : Real;		var TheString : Str255;		DecAcc:Integer);		var			integerPart, decimalPart : str255;		begin   WholeNumber:=round((WholeNumber*power10(DecAcc)))/power10(DecAcc);			NumToString(trunc(abs(wholeNumber)), IntegerPart);			if wholeNumber<0 then				IntegerPart:=concat('-',IntegerPart);			NumToString(round( abs(wholeNumber - trunc(wholeNumber)) * power10(DecAcc) ), decimalPart);			TheSTring := concat(IntegerPart,'.', copy('000000', 1, DecAcc - length(DecimalPart)), decimalPart);	  if copy(TheString,1,6)='-21474'then    TheString:='*Undef*';		end;	procedure String2Real (var WholeNumber : str255;		var TheReal : real);		var			decimalPos : integer;			IntegerPart : longint;			DecimalPart : longint;			zeros : integer;			neg:integer;		begin   if WholeNumber ='*Undef*' then      TheReal:=-21474836   else    begin			DecimalPart := 0;			IntegerPart := 0;			neg:=pos('-',WholeNumber);			if neg=0 then				neg:=1			else				begin					Delete(WholeNumber, 1, Neg);					neg:=-1;				end;			DecimalPos := pos('.', WholeNumber);			if DecimalPos = 0 then				StringtoNum(WholeNumber, IntegerPart)			else				begin					if DecimalPos <> 1 then						StringtoNum(copy(WholeNumber, 1, DecimalPos - 1), integerpart);					Zeros := 0;					Delete(WholeNumber, 1, DecimalPos);					while copy(WholeNumber, 1, 1) = '0' do						begin							Delete(WholeNumber, 1, 1);							Zeros := Zeros + 1;						end;					wholeNumber := copy(WholeNumber, 1, 5);					StringtoNum(WholeNumber, DecimalPart);				end;			TheReal := neg*(IntegerPart + (DecimalPart / Power10(zeros + Length(WholeNumber))));   end;  end;{*************************}procedure DrawRealBox(TheReal:Real;LeftOffset,Width:integer;TheRect:Rect;Decimals:Integer);  var     theString:Str255;     box:Rect;    begin    Real2String(TheReal,TheString,Decimals);				setRect(Box,TheRect.left+LeftOffset,TheRect.top,theRect.left+LeftOffset+Width,theRect.top + 10);				TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);  end;procedure DrawNumBox(TheNumber:integer;LeftOffset,Width:integer;TheRect:Rect);  var     theString:Str255;     box:Rect;    begin				numtoString(TheNumber,TheString);				setRect(Box,TheRect.left+LeftOffset,TheRect.top,theRect.left+LeftOffset+Width,theRect.top + 10);				TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);  end;  procedure DrawstrBox(Thestring:strtype;LeftOffset,Width:integer;TheRect:Rect);  var     box:Rect;    begin				setRect(Box,TheRect.left+LeftOffset,TheRect.top,theRect.left+LeftOffset+Width,theRect.top + 10);				TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);  end;procedure DrawParticle(Number:Integer;TheRect:Rect;Particle:ParticleType);  var    theString:str255;	  	Box:Rect;        begin      textfont(4);						textSize(9);      DrawNumBox(Number,0,25,TheRect);      DrawRealBox(Particle.Xsec,25,50,TheRect,1);						DrawRealBox(Particle.Zsec,75,50,TheRect,1);						DrawRealBox(Particle.Ysec,125,50,TheRect,3);      DrawStrBox(Particle.Number,175,50,TheRect);      DrawRealBox(Particle.GrainCount,225,50,TheRect,1);      DrawRealBox(Particle.pseudo,275,50,TheRect,3);      DrawRealBox(Particle.BigX,325,50,TheRect,1);      DrawRealBox(Particle.BigZ,375,50,TheRect,1);      DrawRealBox(Particle.aziDegree,425,50,TheRect,1);					end;	procedure MyListDef(		lMessage :			 Integer;		lSelect :			 Boolean;		lRect :			Rect;		lCell :			Cell;		lDataOffSet :			Integer;		lDataLen :			Integer;		lHandle :			ListHandle);		procedure DoDrawMsg(SelectIt : boolean;				theRect : Rect;				theCell : Cell;				theHandle : ListHandle);			var				Particle:ParticleType;				thestring:str255;				len:Integer;				particlePointer:ParticlePtr;			begin				EraseRect(TheRect);				len:=SizeOf(ParticlePointer);				LGetCell(pointer(ord(@ParticlePointer)),Len,TheCell,List);				if len = SizeOf(ParticlePointer) then      begin				   Particle:=ParticlePointer^;       DrawParticle(TheCell.v+1,TheRect,Particle);      end;				if SelectIt then					invertRect(theRect);			end;		begin			case lMessage of				lInitMsg:;				lDrawMsg:DoDrawMsg(lSelect,lRect,lCell,lHandle);				lHiliteMsg:invertRect(lRect);				lCloseMsg:;			end;		end;   procedure NewList(var List:ListHandle;var ListWindow:WindowPtr);				var					CSize:Point;					DataBounds,rview:Rect;				begin					if InMem then						  DisposeList(List,ListWindow);     CleanHeader;     HeaderDefault;     Header.NumParticle:=0;     					ListWindow:=GetNewWindow(300,nil,Pointer(-1));					SetPort(ListWindow);					Databounds.top:=0;					DataBounds.Left:=0;					DataBounds.Bottom:=0;					DataBounds.Right:=1;					Rview:=ListWindow^.PortRect;					Rview.right:=Rview.right-16;					Rview.Bottom:=Rview.Bottom-16;					Rview.Top:=Rview.Top+10+80;					CSize.v:=10;					CSize.h:=(50*9)+25;					List:=Lnew(Rview,databounds,cSize,0,Listwindow,false,false,false,true);					List^^.ListDefProc:=NewHandle(0);					List^^.ListDefProc^:=ptr(@MyListDef);					List^^.selFlags:=lOnlyOne;					LDoDraw(true,List);				end;{*************************}	procedure CleanParticle(var Particle:ParticleType);		begin			with Particle do				begin					number:='';					xsec:=0; 				ysec:=0; 				zsec:=0; 				GrainCount:=0; 				P:=0; 				L:=0;					beta:=0;					pseudo:=0;					azimuth:=0;					degrees:=0;					azidegree:=0;					deltax:=0;					deltay:=0;					deltaz:=0;					bigx:=0;					bigz:=0;					deltar:=0;					XStar:=0;					YStar:=0;					ZStar:=0;				end;		end;	procedure AddParticle(Particle				:ParticleType);		var			Last:Cell;			Dummy:Integer;			aBol:Boolean;			ParticlePointer:ParticlePtr;		begin			last.h:=0;			last.v:=0;			if LGetSelect(true,last,list) then				LSetSelect(False,Last,list);			Dummy:=LAddRow(1,Header.NumParticle+1,List);			Last.h:=0;			Last.v:=Header.NumParticle;			New(ParticlePointer);			ParticlePointer^:=Particle;			LSetCell(pointer(ord(@ParticlePointer)),SizeOf(ParticlePointer),Last,List);			LSetSelect(true,Last,List);			Header.NumParticle:=Header.NumParticle+1;		end;	procedure DeleteSelectedParticle;		var			last:Cell;			len:integer;			ParticlePointer:ParticlePtr;   Dummy:Boolean;		begin   last.h:=0;			last.v:=0;			Dummy := LGetSelect(true,Last,List);					len:=SizeOf(ParticlePointer);					last.h:=0;					LGetCell(pointer(ord(@ParticlePointer)),Len,Last,List);					Dispose(ParticlePointer);					LDelRow(1,Last.v,List);					Header.NumParticle:=Header.NumParticle-1;     invalRect(List^^.rview);		end;procedure GetParticleNum(	Number:integer;var Particle:ParticleType);		var			Last:Cell;			len:Integer;			particlePointer:ParticlePtr;		begin			  last.h:=0;					len:=SizeOf(ParticlePointer);					last.v:=Number;					LGetCell(pointer(ord(@ParticlePointer)),Len,Last,List);					Particle:=ParticlePointer^;		end;	procedure GetSelectedParticle(	var Particle:ParticleType);		var			Last:Cell;    Dummy:Boolean;		begin			last.h:=0;			last.v:=0;			Dummy := LGetSelect(true,last,list);			GetParticleNum(Last.v,Particle);		end;	procedure GetLastParticle(var Particle:ParticleType);		begin   GetParticleNum(Header.NumParticle-1,Particle);		end;	procedure SetSelectedParticle(Particle:ParticleType);		var			Last:Cell;			ParticlePointer:ParticlePtr;			len:integer;   Dummy:boolean;		begin			last.h:=0;			last.v:=0;			Dummy:=LGetSelect(true,last,list);					last.h:=0;					len:=SizeOf(ParticlePointer);					LGetCell(pointer(ord(@ParticlePointer)),Len,Last,List);					ParticlePointer^:=Particle;					LSetCell(pointer(ord(@ParticlePointer)),len,Last,List)		end;{******************************}	procedure CleanHeader;		var			i:integer;		begin			with Header do				begin					Beam:=''; 				Date:=''; 				Event:=''; 				operator:=''; 				Plate:=''; 				part:=''; 				Rangetostar:=''; 				ShrinkFactZT:=0; 				ShrinkFactZM:=0; 				ShrinkFactAN:=0; 				Magnification:=0; 				ZZO:=0;     for i:= 1 to 4 do        begin 				       X[i]:=0; 				       y[i]:=0; 				       z[i]:=0;        end; 				slopexy:=0;	 				slopezy:=0; 				Primary:=''; 				Frag:=''; 				a:=''; 				p:=''; 				M:='';     for i:= 1 to 4 do        begin 				       NB[i]:=0; 				       G1[i]:=0; 				       G2[i]:=0; 				       G3[i]:=0; 				       NH[i]:=0;            energyQ[i]:=0;        end;     FBlack:=0;     BBlack:=0;     NBlack:=0; 				FtoBBlack:=0;     FGrey:=0;     BGrey:=0;     NGrey:=0; 				FtoBGrey:=0;         NHtotal:=0;     energytotal:=0; 			end;		end;{*****************************}			Procedure PrintFile;              var        i:integer;        page:integer;        particle:particleType;        TheRect:Rect;        Line:integer;        trueorFalse:boolean;        cancel:Boolean;           Procedure StartPrinter(Var Canceled:Boolean);	begin		PrOpen;  if PrintDlgDo then		 canceled:= not PrJobDialog(PgSetup)  else    canceled :=False;		if not canceled then			begin			  PrinterPort:=PrOpenDoc(PgSetup,nil,nil);			  PrOpenPage(PrinterPort,nil);			end;	end; {StartPrinter}Procedure StopPrinter;	begin		PrCloseDoc(PrinterPort);		PrPicFile(PgSetup,nil,nil,nil,myStRec);  PrClose;	end;				begin     trueORfalse := PrValidate(PgSetUp);					StartPrinter(Cancel);     if not cancel then     begin     page:=0;     line:=0;     i:=0;     while (i<> Header.NumParticle) and (PrError=0) do      begin       if Page = 0 then        begin         drawHeader;         Line:=9;         SetRect(TheRect,0,90,475 ,100);        end       else        begin         SetRect(TheRect,0,0,475 ,10);         line:=0;         PrOpenPage(PrinterPort,nil);        end;       while (Line <> 70) and (i<> Header.NumParticle) and (PrError=0) do        begin         GetParticleNum(i,Particle);         DrawParticle(i+1,TheRect,Particle);         OffsetRect(TheRect,0,10);          i:=i+1;         Line:=Line+1;        end;       page:=Page+1;       PrClosePage(PrinterPort);      end;      if PrError <>0 then        AreYouSure('There was a printing error',Cancel);      StopPrinter;      end      else       PrClose;				end;{****************************}{Dialog Stuff used to put and get numbers etc from dialog boxes}	Procedure SetDlgStr255(	Item				:integer;										TheString		:str255;										var DialogPointer:DialogPtr);		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;		begin			GetDItem(DialogPointer,Item,ItemType,TextHandle,Box);			SetItext(TextHandle,TheString);		end;	Procedure SetDlgStr(	Item				:integer;										TheString		:strtype;										var DialogPointer:DialogPtr);		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			dummy:str255;		begin			GetDItem(DialogPointer,Item,ItemType,TextHandle,Box);			dummy:=TheString;			dummy:=copy(dummy,1,10);			SetItext(TextHandle,dummy);		end;	procedure SetReal(	Item					:integer;										TheReal				:real;										DecAcc				:Integer;										var DialogPointer:DialogPtr);		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			TheString		:str255;		begin			GetDItem(DialogPointer,item,ItemType,TextHandle,Box);			Real2String(TheReal,TheString,DecAcc);			SetItext(TextHandle,TheString);		end;	procedure SetDlgInt(  Item					:integer;										theInt				:integer;										var DialogPointer:DialogPtr);		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			TheString		:str255;		begin			GetDItem(DialogPointer,item,ItemType,TextHandle,Box);			NumToString(TheInt,TheString);			SetItext(TextHandle,TheString);		end;	function GetDlgStr(	Item				:integer;										var DialogPointer:DialogPtr):strType;		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			TheString		:str255;			dummy:strtype;		begin			GetDItem(DialogPointer,Item,ItemType,TextHandle,Box);			GetItext(TextHandle,TheString);			dummy:=TheString;			GetDlgStr:=dummy;		end;	function GetReal(	Item					:integer;										var DialogPointer:DialogPtr):Real;		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			RealString		:str255;			TheReal			:real;		begin			GetDItem(DialogPointer,item,ItemType,TextHandle,Box);			GetItext(TextHandle,RealString);			String2Real(RealString,TheReal);			GetReal:=TheReal;		end;	function GetDlgInt(	Item					:integer;										var DialogPointer:DialogPtr):Integer;		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			IntString		:str255;			TheInt			:LongInt;		begin			GetDItem(DialogPointer,item,ItemType,TextHandle,Box);			GetItext(TextHandle,IntString);			StringtoNum(IntString,TheInt);			GetDlgInt:=TheInt;		end;{********************}{Procedures for use with reading from the microscope Readers}	procedure ClearBuffer(var FootStop:Boolean);		var			ch:char;			Dummy:Longint;		begin			Delay(15,dummy);			FootStop:=False;			While InReady(SPortA) do				begin					GetChar(SPortA,ch);					if  ch = 'S' then						FootStop:=True;				end;		end;	procedure GetStringM(var TheString:str255);		var			ch:char;			i:integer;			A:integer;		begin			thestring:='';			repeat				begin					GetChar(SPortA,ch);					if  ch > chr(32) then						thestring:=concat(thestring,ch);				end;			until ch=chr(10);		end;	procedure SendString(TheString:str255);		var			i:integer;		begin			for i := 1 to Length(TheString) do				sendChar(SPortA,TheString[i]);			sendChar(SPortA,chr(13));			sendChar(SPortA,chr(10));		end;	procedure ReadMicro(var channel1,channel2,channel3:Real;						var	FootStop:Boolean);		var			TheString:str255;			Dummy:boolean;		begin			ClearBuffer(FootStop);			SendString('D1');			getStringM(TheString);			String2Real(TheString,channel1);			SendString('D2');			getStringM(TheString);			String2Real(TheString,channel2);			SendString('D3');			getStringM(TheString);			String2Real(TheString,channel3);			ClearBuffer(dummy);		end;{***********************}	Function Filter(var TheDialog:DialogPtr;		var theEvent:EventRecord;		var itemNumber:Integer):			Boolean;		const			returnCode=				13;			enterCode=				3;			CancelCode=				27;			asterCode=				42;		var			charCode:				char;		begin			Filter:=false;			if (theEvent.What = keyDown) or (theEvent.What = AutoKey) then				begin					CharCode:=chr(BitAnd(theEvent.message,charCodeMask));					if BitAnd(theEvent.modifiers,CmdKey) = CmdKey then						begin							case CharCode of								'X':DlgCut(TheDialog);								'C':DlgCopy(TheDialog);								'V':DlgPaste(TheDialog);								'B':DlgDelete(TheDialog);							end;							Filter:=true;						end;					if CharCode = chr(returnCode) then						begin							itemNumber:=OK;							Filter:=true;						end;					if CharCode = chr(CancelCode) then						begin							itemNumber := Cancel;							Filter:=true;						end;					if CharCode = chr(enterCode) then						begin							theEvent.message:=theEvent.message+6;							Filter:=false;						end;					if CharCode = chr(asterCode) then						begin							itemNumber:=3;							Filter:=true;						end;				end;			{if inReady(SPortA) then				begin					itemNumber:=99;					Filter:=True;				end;}		end;{*********************}	procedure GetHeaderDialog(var DialogPointer:DialogPtr);		var			i:integer;		begin			Header.Beam:=GetDlgStr(8,DialogPointer);			Header.Date:=GetDlgStr(9,DialogPointer);			Header.Event:=GetDlgStr(10,DialogPointer);			Header.Operator:=GetDlgStr(11,DialogPointer);			Header.Plate:=GetDlgStr(12,DialogPointer);			Header.Part:=GetDlgStr(13,DialogPointer);			Header.Rangetostar:=GetDlgStr(14,DialogPointer);			Header.ShrinkFactZT:=GetReal(15,DialogPointer);			Header.ShrinkFactZM:=GetReal(16,DialogPointer);			Header.Magnification:=GetReal(17,DialogPointer);			Header.ZZO:=GetReal(18,DialogPointer);			for i:=1 to 4 do				begin					Header.NB[i]:=GetDlgInt(19+(i-1)*4,DialogPointer);					Header.G1[i]:=GetDlgInt(20+(i-1)*4,DialogPointer);					Header.G2[i]:=GetDlgInt(21+(i-1)*4,DialogPointer);					Header.G3[i]:=GetDlgInt(22+(i-1)*4,DialogPointer);				end;			Header.Primary:=GetDlgStr(35,DialogPointer);			Header.Frag:=GetDlgStr(36,DialogPointer);			Header.a:=GetDlgStr(37,DialogPointer);			Header.p:=GetDlgStr(38,DialogPointer);			Header.M:=GetDlgStr(39,DialogPointer);			for i:=1 to 4 do				begin					Header.X[i]:=GetReal(40+(i-1)*3,DialogPointer);					Header.Z[i]:=GetReal(41+(i-1)*3,DialogPointer);					Header.Y[i]:=GetReal(42+(i-1)*3,DialogPointer);				end;		end;	procedure SetHeaderDialog(var DialogPointer:DialogPtr);		var			i:integer;		begin			SetDlgStr(8,Header.Beam,DialogPointer);			SetDlgStr(9,Header.Date,DialogPointer);			SetDlgStr(10,Header.Event,DialogPointer);			SetDlgStr(11,Header.Operator,DialogPointer);			SetDlgStr(12,Header.Plate,DialogPointer);			SetDlgStr(13,Header.Part,DialogPointer);			SetDlgStr(14,Header.Rangetostar,DialogPointer);			SetReal(15,Header.ShrinkFactZT,3,DialogPointer);			SetReal(16,Header.ShrinkFactZM,3,DialogPointer);			SetReal(17,Header.Magnification,3,DialogPointer);			SetReal(18,Header.ZZO,3,DialogPointer);			for i:=1 to 4 do				begin					SetDlgInt(19+(i-1)*4,Header.NB[i],DialogPointer);					SetDlgInt(20+(i-1)*4,Header.G1[i],DialogPointer);					SetDlgInt(21+(i-1)*4,Header.G2[i],DialogPointer);					SetDlgInt(22+(i-1)*4,Header.G3[i],DialogPointer);				end;			SetDlgStr(35,Header.Primary,DialogPointer);			SetDlgStr(36,Header.Frag,DialogPointer);			SetDlgStr(37,Header.a,DialogPointer);			SetDlgStr(38,Header.p,DialogPointer);			SetDlgStr(39,Header.M,DialogPointer);			for i:=1 to 4 do				begin					SetReal(40+(i-1)*3,Header.X[i],1,DialogPointer);					SetReal(41+(i-1)*3,Header.Z[i],1,DialogPointer);					SetReal(42+(i-1)*3,Header.Y[i],3,DialogPointer);				end;			SetReal(52,Header.ShrinkFactAN,3,DialogPointer);			SetReal(53,Header.SlopeXY,4,DialogPointer);			SetReal(54,Header.SlopeZY,4,DialogPointer);			SetDlgint(55,Header.NHtotal,DialogPointer);			SetReal(56,Header.EnergyTotal,2,DialogPointer);			SetReal(57,Header.FtoBBlack,2,DialogPointer);			SetReal(58,Header.FtoBGrey,2,DialogPointer);		end;	Procedure HeaderDefault;		var			seconds:longint;			TheDate:str255;		begin			if Header.Date = '' then				begin					getdatetime(seconds);					IUDateString(seconds,shortDate,TheDate);					Header.Date:=TheDate;				end;		end;	procedure SetParticleDialog(Particle:ParticleType;			var DialogPointer:DialogPtr);		begin			SetDlgStr(6,Particle.Number,DialogPointer);			setReal(7,Particle.GrainCount,1,DialogPointer);			SetReal(8,Particle.xsec,1,DialogPointer);			SetReal(9,Particle.zsec,1,DialogPointer);			SetReal(10,Particle.ysec,3,DialogPointer);			SetReal(11,Particle.xstar,2,DialogPointer);			SetReal(12,Particle.zstar,2,DialogPointer);			SetReal(13,Particle.ystar,3,DialogPointer);			SetReal(14,Particle.pseudo,3,DialogPointer);			SetReal(15,Particle.BigX,1,DialogPointer);			SetReal(16,Particle.BigZ,1,DialogPointer);			SetReal(17,Particle.deltaX,4,DialogPointer);			SetReal(18,Particle.deltaY,4,DialogPointer);			SetReal(19,Particle.deltaZ,4,DialogPointer);			SetReal(20,Particle.deltaR,4,DialogPointer);			SetReal(21,Particle.Beta,2,DialogPointer);			SetReal(22,Particle.degrees,2,DialogPointer);			SetReal(23,Particle.azimuth,1,DialogPointer);			SetReal(24,Particle.azidegree,1,DialogPointer);		end;	procedure GetParticleDialog(var Particle:ParticleType;					var DialogPointer:DialogPtr);		begin			Particle.Number:=GetDlgStr(6,DialogPointer);			Particle.GrainCount:=GetReal(7,DialogPointer);			Particle.xsec:=GetReal(8,DialogPointer);			Particle.zsec:=GetReal(9,DialogPointer);			Particle.ysec:=GetReal(10,DialogPointer);			Particle.xstar:=GetReal(11,DialogPointer);			Particle.zstar:=GetReal(12,DialogPointer);			Particle.ystar:=GetReal(13,DialogPointer);		end;	procedure DefaultParticle(var Particle:ParticleType);		var			LastParticle:ParticleType;		begin			if Header.NumParticle > 0 then				begin					CleanParticle(LastParticle);					GetLastParticle(LastParticle);					Particle.Xstar:=LastParticle.Xstar;					Particle.Ystar:=LastParticle.Ystar;					Particle.Zstar:=LastParticle.Zstar;					Particle.ysec:=LastParticle.ysec;				end;		end;	procedure NullButton(			ItemHit				:integer;		var			Done,			Cancel				:Boolean;			var DialogPointer				:DialogPtr);		begin			case itemHit of				1:	Done:=true;				2:	begin							done:=true;							cancel:=true;						end;			end;		end;	procedure HeaderButton(			ItemHit				:integer;		var			Done,			Cancel				:Boolean;			var DialogPointer				:DialogPtr);		begin			case itemHit of				1:	Done:=true;				2:	begin							done:=true;							cancel:=true;						end;				3:	begin							GetHeaderDialog(DialogPointer);							CalcHeader(Header);							SetHeaderDialog(DialogPointer);						end;			end;		end;	procedure ParticleButton(			ItemHit				:integer;		var			Done,			Cancel				:Boolean;			var DialogPointer				:DialogPtr);		var			Particle:				ParticleType;			channel1,			channel2,			channel3:				Real;			footstop:				Boolean;		begin			case itemHit of				1:	Done:=true;				2:	begin							done:=true;							cancel:=true;						end;				3:	begin       CleanParticle(Particle);							GetParticleDialog(Particle,DialogPointer);							CalcParticle(Particle,Header);							SetParticleDialog(Particle,DialogPointer);						end;				99:	begin							ReadMicro(channel1,channel2,channel3,FootStop);							if FootStop then								done:=true;							SetReal(4,channel1,2,dialogPointer);							SetReal(5,channel2,2,dialogPointer);							SetReal(6,channel3,2,dialogPointer);							ClearBuffer(FootStop);						end;			end;		end;	Procedure Modal(		var			cancel:				Boolean;			button:				Integer;			var DialogPointer:				DialogPtr);		Var			itemHit:				integer;			Done:				boolean;  	begin  		cancel:=false;  		done:=false;        repeat					begin {repeat}						ModalDialog(@Filter,itemHit);						case Button of							1:	NullButton(ItemHit,Done,Cancel,DialogPointer);							2:	ParticleButton(ItemHit,Done,Cancel,DialogPointer);							3:	HeaderButton(ItemHit,Done,Cancel,DialogPointer);						end;					end;{repeat}				until done;    end;{dialog}	procedure HeaderDialog(var cancel:boolean);		var			DialogPointer:DialogPtr;		begin			DialogPointer:=GetNewDialog(HeaderLTRes,nil,pointer(-1));			SetHeaderDialog(dialogPointer);   ShowHide(DialogPointer,true);			Modal(Cancel,3,DialogPointer);			if not cancel then				begin					GetHeaderDialog(DialogPointer);					CalcHeader(Header);				end;			CloseDialog(DialogPointer);		end; procedure ParticleDialog(	var Particle		:ParticleType;    										var Cancel		:Boolean); var			DialogPointer:DialogPtr;		begin			DialogPointer:=GetNewDialog(ParticleLTRes,nil,pointer(-1));			SetParticleDialog(Particle,DialogPointer);   ShowHide(DialogPointer,true);			Modal(Cancel,2,DialogPointer);			if not cancel then				begin     CleanParticle(Particle);					GetParticleDialog(Particle,DialogPointer);					CalcParticle(particle,header);				end;			CloseDialog(DialogPointer);		end; {$S Main}{*******************}	procedure DebugDialog{(TheInteger:integer)};		var			cancel:boolean;			DialogPointer:DialogPtr;			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			itemHit	:integer;			TheString:str255;		begin			DialogPointer:=GetNewDialog(DebugRes,nil,pointer(-1));			NumToString(TheInteger,TheString);			GetDItem(DialogPointer,3,ItemType,TextHandle,Box);			SetItext(TextHandle,TheString);			ModalDialog(nil,itemHit);			CloseDialog(DialogPointer);		end;	procedure AreYouSure{(	TheString	:Str255;											var cancel	:boolean)};		var			DialogPointer:DialogPtr;		begin			DialogPointer:=GetNewDialog(AreSureRes,nil,pointer(-1));			SetDlgStr255(3,TheString,DialogPointer);			Modal(Cancel,1,DialogPointer);			CloseDialog(DialogPointer);		end;{**********************}	procedure FileError;				var					TheError:str255;      cancel:Boolean;  				begin  					if IOR > 0 then  						begin  							GetErrorMessage(IOR,TheError);  							sysbeep(50);  							areyousure(TheError,Cancel);  						end;  				end;    procedure WriteFile(Reply:SFReply);				var					f:FileRec;					Particle:ParticleType;     i:integer;				begin 					FRewrite(f,reply.vRefNum,reply.fName,'DATA','MICR');     if IOR = 0 then      begin					  FPutM(f,@Header,SizeOf(Header));					  if IOR = 0 then         begin				    	SetWTitle(ListWindow,Header.reply.fName);				    	for i := 1 to Header.NumParticle do					    	begin           GetParticleNum(i-1,Particle);					    		FPutM(f,@Particle,SizeOf(Particle));					   	 end;         FileError;        end;      end;     FileError;					FClose(f);				end;			procedure ReadFile(Reply:SFReply);				var					f:filerec;					i:integer;					Particle:ParticleType;					Temp:Integer;				begin					FReset(f,reply.vRefNum,reply.fName);					FGetM(f,@Header,SizeOf(Header));					Header.Reply:=Reply;					Temp:=Header.NumParticle;     Header.NumParticle:=0;					SetWTitle(ListWindow,Header.reply.fName);     LDoDraw(False,List);					for i := 1 to Temp do						begin							FGetM(f,@Particle,SizeOf(Particle));							AddParticle(Particle);						end;     LDoDraw(True,List);					FileError;					FClose(f);				end;	procedure ProcessMenu(CodeWord : LongInt);		var			menuNum : Integer;			itemNum : Integer;    temp:longInt;{***********************}		procedure DoAppleMenu;			procedure About;				var					AboutRecord : DialogRecord;					AboutDlog : DialogPtr;					dummy:integer;				begin					AboutDlog := GetNewDialog(AboutRes,nil,Pointer(-1));					ModalDialog(nil,dummy);					CloseDialog(AboutDlog);				end;			procedure DeskAccesory;				var					dummy:integer;					nameHolder : str255;				begin					GetItem(myMenus[appleMenu],ItemNum,NameHolder);					dummy := OpenDeskAcc(NameHolder);				end;			begin				case ItemNum of					1:About;					2 :;					otherwise						deskAccesory;				end;			end;{*****************}		procedure DoEditMenu;			begin				if not SystemEdit(ItemNum - 1) then					begin						case ItemNum of        1:;						end;					end;			end;{*****************}		procedure DoFileMenu;			{procedures for file menu}			procedure GetReadFile(var reply:SFReply);				var					pt:point;					FileType:SFTypeList;				begin					pt.h:=50;					pt.v:=50;					FileType[0][1]:='D';					FileType[0][2]:='A';					FileType[0][3]:='T';					FileType[0][4]:='A';					SFGetFile(pt,'Enter File',nil,1,filetype,nil,reply);				end;			procedure GetWriteFile(var reply:SFReply);				var					pt:point;				begin					pt.h:=50;					pt.v:=50;					SFPutFile(pt,'Save File',Reply.Fname,nil,reply);				end;			{the File menu procedures}   			procedure NewFile;				var					cancel:boolean;				begin     cancel:= False;					if changed and InMem then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							NewList(List,ListWindow);							HeaderDialog(Cancel);							Header.Reply.FName:='untitled';							SetWTitle(ListWindow,Header.reply.fName);							changed:=True;							InMem:=True;							FromFile:=False;						end;				end;			procedure OpenFile;				var					Cancel:Boolean;     Reply:SfReply;				begin     cancel:= False;					if inmem and Changed then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							GetReadFile(Reply);							if  Reply.good then								begin         NewList(List,ListWindow);         Header.Reply:=Reply;									ReadFile(Header.Reply);									Changed:=false;									InMem:=True;									fromFile:=true;								end						end;				end;			Procedure CloseFile;				var					cancel:Boolean;				begin      cancel:= False;					if Changed and inmem then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							if InMem then						   DisposeList(List,ListWindow);							InMem:=False;							changed:=False;							FromFile:=False;						end;				end;			Procedure SaveAsFile;				begin					GetWriteFile(Header.Reply);					if Header.Reply.Good then						begin							WriteFile(Header.Reply);							Changed:=False;							FromFile:=true;						end;				end;			Procedure SaveFile;				begin					WriteFile(Header.Reply);					Changed:=False;					FromFile:=true;				end;			Procedure RevertFile;				var					cancel:Boolean;				begin     cancel:= False;					if Changed and inmem then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							NewList(List,ListWindow);							ReadFile(Header.Reply);							Changed:=False;							InMem:=True;							fromFile:=true;						end;				end;			procedure PageSetup;		var  			trueORfalse : boolean;  		begin     PrOpen;  			trueORfalse := PrValidate(PgSetUp); { make sure handle is valid}  			trueORfalse := PrStlDialog(PgSetUp); { fill the record with the info}     PrClose;		end;			Procedure QuitProgram;    var					cancel:Boolean;    len:integer;    Last:Cell;    ParticlePointer:ParticlePtr;    i:integer;				begin      cancel:= False;					if Changed and inmem then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							if InMem then						  DisposeList(List,ListWindow);							InMem:=False;							changed:=False;							FromFile:=False;       Done:=True;						end;				end;			begin				case ItemNum of					1:NewFile;					2:OpenFile;					3:CloseFile;					4:;					5:SaveFile;					6:SaveAsFile;					7:RevertFile;					8:;					9:PageSetUp;					10:PrintFile;					11:;					12:QuitProgram;				end;				DrawMenu;			end;{******************}		procedure DoParticleMenu;			procedure NewParticle(var Cancel:Boolean);				var					particle:ParticleType;				begin					CleanParticle(Particle);					DefaultParticle(Particle);					ParticleDialog(Particle,cancel);					if not cancel then						begin							AddParticle(Particle);							Changed:=true;						end;				end;			procedure AddParticleMenu;				var					cancel:boolean;				begin					NewParticle(Cancel);				end;			procedure AddContinuousParticle;				var					cancel:boolean;				begin					repeat						NewParticle(Cancel);					until cancel;				end;			procedure EditParticle;				var					cancel:boolean;					Particle:ParticleType;				begin					  GetSelectedParticle(Particle);							ParticleDialog(Particle,cancel);							if not cancel then								begin									SetSelectedParticle(Particle);									Changed:=true;								end;				end;			procedure ClearParticle;				var					particle:ParticleType;     cancel:boolean;				begin     cancel:= False;					if inmem then						AreYouSure('Are you sure you want to clear this particle?',Cancel);					if not cancel then       begin					   GetSelectedParticle(Particle);					 		CleanParticle(Particle);					 		SetSelectedParticle(Particle);					 		Changed:=true;       end;				end;			procedure DeleteParticleMenu;   var     cancel:Boolean;    				begin     cancel:= False;					if inmem then						AreYouSure('Are you sure you want to delete the select particle?',Cancel);					if not cancel then      begin					  DeleteSelectedParticle;					  changed:=true;      end;				end;			begin				case ItemNum of					1:AddParticleMenu;					2:AddContinuousParticle;					3:EditParticle;					4:ClearParticle;					5:DeleteParticleMenu;				end;				DrawMenu;			end;{****************}		procedure DoHeaderMenu;			procedure EditHeader;				var					cancel:boolean;				begin					HeaderDialog(Cancel);					if not cancel then						Changed:=true;				end;			Procedure ClearHeader;  var   cancel:Boolean;   				begin     cancel:= False;					if inmem then						AreYouSure('Are you sure you want to clear the header?',Cancel);					if not cancel then     begin					 CleanHeader;      CalcHeader(Header);      invalrgn(ListWindow^.visrgn);					 changed:=true;     end;				end;			begin				case ItemNum of					1:EditHeader;					2:ClearHeader;				end;				DrawMenu;			end;{*****************}		begin    Temp:=CodeWord;			menuNum := HiWord(temp);    temp:=CodeWord;			itemNum := LoWord(temp);			if itemNum > 0 then				begin					case MenuNum of						1:DoAppleMenu;						2:DoFileMenu;						3:DoEditMenu;						4:DoParticleMenu;						5:DoHeaderMenu;					end;				end;			HiliteMenu(0);		end;{******************}	procedure AllDone;		begin    CloseSPort(sPortA);  end;{******************}  procedure DrawHeader;    var theString:str255;      Box:Rect;      Temp:Str255;      i:integer;    begin      textfont(4);      textSize(9);            setRect(box,0,0,1000,87);      eraseRect(box);            MoveTo(19,88);      DrawString('#       X        Z       Y   Ident   Grain   Pseudo   BigX     Big Z     phi');      MoveTo(3,10);      TheString:='Beam: '+Header.Beam+'   Date: '+Header.Date+'    Operator: '+Header.operator;      TheString:=TheString+'    Plate: '+Header.Plate+'    Part: '+Header.Part;      DrawString(TheString);      MoveTo(3,20);      TheString:=Header.Primary+' ->'+' '+Header.a+'a + '+' '+Header.p+'p + '+Header.m+'M + ';      NumtoSTring(Header.NBlack,Temp);      TheString:=TheString+Temp+'NB + ';      NumtoSTring(Header.NGrey,Temp);      TheString:=TheString+Temp+'NG ';      Real2STring(Header.EnergyTotal,Temp,2);      TheString:=TheString+' = '+Temp+'MeV   F to B Black ';      NumTostring(Header.FBlack,temp);      TheString:=TheString+temp+'/';      numToString(Header.BBLack,Temp);      TheString:=TheString+temp+'   F to B Grey ';      numToString(Header.FGrey,Temp);      TheString:=TheString+temp+'/';      numToString(Header.BGrey,Temp);      TheString:=TheString+temp;      DrawString(TheString);      MoveTo(15,30);      DrawString('    X       Z       Y ');            for i := 1 to 4 do        begin          SetRect(box,0,20+i*10,50,30+i*10);          Real2String(Header.x[i],TheString,1);          TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);          SetRect(box,50,20+i*10,100,30+i*10);          Real2String(Header.z[i],TheSTring,1);          TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);          SetRect(box,100,20+i*10,150,30+i*10);          Real2String(Header.y[i],TheString,3);          TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);        end;      MoveTo(180,30);      DrawString('Range to Star: '+Header.Rangetostar);      Moveto(180,40);      Real2STring(Header.ShrinkFactAN,Temp,3);      DrawString('Shrinkage Factor:'+Temp);      Moveto(180,50);      Real2String(Header.ShrinkFactZT,Temp,3);      TheString:= 'ZT :'+Temp;      Real2String(Header.ShrinkFactZM,Temp,3);      DrawString(TheString+'  ZM:'+Temp);      Moveto(180,60);      Real2String(Header.Magnification,temp,3);      DrawString('Magnification: '+Temp);      MoveTo(180,70);      Real2String(Header.ZZO,temp,3);      DrawString('z/zO of Star:'+temp);      MoveTo(350,30);      Real2String(Header.SlopeXY,temp,4);      DrawString('Slope XY :'+temp);      Moveto(350,40);      Real2String(Header.SlopeZY,temp,4);      DrawString('Slope ZY :'+temp);     end;  procedure UpdateListWindow{(var ListWindow:WindowPtr;var List:ListHandle;Header:HeaderType)};    begin      SetPort(ListWindow);  {Make sure we update the right window and not some window with no list}      BeginUpdate(ListWindow);      List^^.listdefProc^ := Ptr(@MyListDef);      LUpdate(ListWindow^.visRgn,List);      DrawHeader;						EndUpdate(ListWindow);    end; 	procedure MainEventLoop;  var   Event:     EventRecord;			windowLoc:     integer;			mouseLoc,   LastMouseLoc:     point;   LastClick:     Longint;			theWindow:     WindowPtr;			CharCode:     Char;			DummyBoolean:     Boolean;			Last:     Cell;   cancel:     Boolean;		begin			repeat				SystemTask;				if InMem then    {Make Sure that somthing is selected in the list}					begin						Last.v:=0;						Last.h:=0;						if not LGetSelect(true,Last,List) then							begin								Last.v:=0;								Last.h:=0;								LSetSelect(True,last,List);							end;					end;				if GetNextEvent(everyEvent,Event) then					begin						case event.what of							mouseDown :								begin									mouseLoc := Event.where;									windowLoc := FindWindow(mouseLoc,theWindow);          if(abs(MouseLoc.h-LastMouseLoc.h)<5)and(abs(MouseLoc.v-LastMouseLoc.v)<5)then            if (WindowLoc=InContent)and((tickcount-LastClick)<GetDblTime)then            begin             GlobalToLocal(MouseLoc);												 DummyBoolean := LClick(MouseLoc, Event.modifiers,List);             ProcessMenu(MenuKey('E'));             LocalToGlobal(MouseLoc);            end;         LastMouseLoc:=MouseLoc;         LastClick:=tickcount;         									case windowLoc of										inMenuBar :            ProcessMenu(MenuSelect(MouseLoc));										inSysWindow:											SystemClick(Event,theWindow);										inContent:											begin												GlobalToLocal(MouseLoc);												DummyBoolean := LClick(MouseLoc, Event.modifiers,List);											end;										inDrag:											begin												DragWindow(theWindow,mouseLoc,DragArea);												SelectWindow(theWindow);											end;										inGrow:											begin											end;										inGoAway:           if TrackGoAway(Thewindow,mouseLoc) then											 begin             cancel:= False;					        if Changed and inmem then						        AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					        if not cancel then					         	begin							         if InMem then						            DisposeList(List,ListWindow);							         InMem:=False;						          changed:=False;							         FromFile:=False;                DrawMenu;						        end;											  end;										inDesk:											Begin											end;									end;								end;							UpdateEvt :        if InMem then								  UpdateListWindow(ListWindow,List,Header);							ActivateEvt :        if InMem then								  begin            SetPort(ListWindow);									   LActivate(Odd(Event.modifiers),List);									   UpdateListWindow(ListWindow,List,Header);								  end;							keyDown,AutoKey :								begin									CharCode := chr(BitAnd(Event.message,charCodeMask));									if BitAnd(Event.modifiers,CmdKey) = CmdKey then										 ProcessMenu(MenuKey(CharCode));								end;						end;					end;			until Done;		end;{**************************}	procedure InitThings;		procedure SetupLimits;			var				Screen : Rect;			begin				Screen := ScreenBits.bounds; {Get current Screen Size}				with Screen do					begin						SetRect(DragArea,left+4,top+24,right-4,bottom-4);						SetRect(GrowArea,left,top+24,right,bottom);					end;			end;		procedure SetUpMenus;				var					index : integer;			begin				for index := beginMenu to endMenu do					myMenus[index] := GetMenu(index);				AddResMenu(myMenus[appleMenu],'DRVR'); {Add Desk Accessories}				for index := beginMenu to endMenu do					InsertMenu(myMenus[index],0);				DrawMenu;			end;		procedure SetUpPort;			var				Dummy:integer;			begin				Dummy:=InitSPort(SPortA,baud2400,stop10,noParity,data7,1000,xOnXOff,xOnXOff);				SendString('SON');				SetBufSize(1000);			end;		procedure SetUpFile;   var    theFile:      AppFile;    Count,    Message:      integer;    i:      integer;    cancel:      Boolean;  			begin    FileIOInit;             {init File I/O}				SetBufSize(32769*2);    CountAppFiles(Message,Count);     {Get finder info and load file if file}    if Message = AppOpen then      begin     if Count>0 then       begin       GetAppFiles(1,TheFile);       NewList(List,ListWindow);       Header.Reply.vRefNum:=TheFile.vRefNum;       Header.Reply.fType:=TheFile.Ftype;       Header.Reply.version:=TheFile.VersNum;       Header.Reply.FName:=TheFile.Fname;       ReadFile(Header.Reply);							Changed:=false;							InMem:=True;							fromFile:=true;       DrawMenu;       cancel:= False;       if count > 1 then         AreYouSure('Sorry I can''t load more than one file at a time',Cancel);       for i := 1 to Count do         ClrAppFiles(i);       end;       end     else     if Count>0 then      begin       for i := 1 to count do        begin         GetAppFiles(i,TheFile);         NewList(List,ListWindow);         Header.Reply.vRefNum:=TheFile.vRefNum;         Header.Reply.fType:=TheFile.Ftype;         Header.Reply.version:=TheFile.VersNum;         Header.Reply.FName:=TheFile.Fname;         ReadFile(Header.Reply);					  		Changed:=false;					  		InMem:=True;						  	fromFile:=true;         DrawMenu;         CalcHeader(Header);         WriteFile(Header.Reply);         PrintFile;         ClrAppFiles(i);         PrintDlgDo:=False;        end;        Done:=True;         DisposeList(List,ListWindow);       end;			end;		procedure SetupMemory;           begin       MoreMasters;       MoreMasters;       MoreMasters;       MaxApplZone;    end;		procedure SetupPrinter; var  			dumPgSetup : TPrint;  		begin     prOpen;  			PgSetUp := THPrint(NewHandle(SizeOf(dumPgSetup))); {make handle}  			PrintDefault(PgSetUp); 	{initialize the fields}  			HLock(Handle(PgSetUp));  {Lock it for some reason??}     PrClose;     PrintDlgDo:=True;			end;		begin			Done:=False;			InMem:=False;			Changed:=False;			FromFile:=False;			FlushEvents(everyEvent,0);			InitGraf(@thePort);			SetUpMemory;			InitFonts;			InitWindows;			InitMenus;			TEInit;			InitDialogs(nil);			InitCursor;			InitAllPacks;			SetupLimits;			SetUpMenus;			SetupPrinter;			{SetUpPort;}			SetupFile		end;{***********************}	begin		initThings;		MainEventLoop;		{AllDone;}	end.