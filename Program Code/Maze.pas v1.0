program Maze;  	{This is the data collector program's main module} 	  {$B+}  	{Set bundle bit so finder will use my icon}	  {$T APPLMaze} 	 {set my file type and creator}  	{$U-}  	{Use my units}  	{$R Jim Surine:Programming:Reasources:Maze.Rsrc}	  {Load my reasources, remember to stick in here just the reasouces you need}  	{$S+}  	{Use Segments because program is larger than 32K}   {$I-}   {Set Folder to write output application}   {$O Jim Surine:Programming:Programs:Mazes:Maze v1.0}      {$U Jim Surine:Programming:Units:My Units:Dialogs}        {Dialog handler}   {$U Jim Surine:Programming:Units:My Units:MazeGlobals}              {$S Segment 1} {Need another segment}     uses    Memtypes,           {Basic types stanadard}    QuickDraw,          {Quickdraw standard}    OSIntf,             {Operating system standard}    ToolIntf,           {Tools standard}      PackIntf,           {Package stuff (List Manager, Decimal to string convert)}    sane,               {For Real number conversions}      PasInOut,           {For writting textfiles}    Dialogs,    MazeGlobals;            {My Dialog Routines}{$S Segment 2}{Main module unit}  const    WindowID = 20792;         {Window template}    AboutID = 17953;          {About Dialog}    PrintingID = 8093;        {info dialog used for non-spool printing}      AppleMenuID = 300;		      {the Apple menu}    AboutItemID = 1;      FileMenuID = 301;		       {the File menu}    NewItemID = 1;    OpenItemID = 2;    CloseItemID = 4;    SaveItemID = 5;    SaveAsItemId = 6;    RevertItemID = 7;    PageSetUpItemID = 9;    PrintItemID = 10;    StopPrintItemID = 11;    QuitItemID = 13;      EditMenuID = 302;	 	      {the Edit menu}    UndoItemID = 1;    CutItemID = 3;    CopyItemID = 4;    PasteItemID = 5;    ClearItemID = 6;        UndoCmd = 0;                  CutCmd = 2;    CopyCmd = 3;    PasteCmd = 4;    Clearcmd = 5;      TitleBarHeight = 18;      {Values used for organizing windows}    MenuBarHeight = 20;    var    {System Globals}      TheWindow : WindowPtr;          {Current Window}    WindowCount : integer;          {Number of My Windows}    Quitting, Finished : Boolean;   {Quitting and then finished}    LastClick : LongInt;            {Time of last click ,for double clicks}    LastMouse : Point;              {Where was it last Clicked}        {Global printer values}      PgSetUp : 								{Page setup info}    THPrint;    MyStRec : 								{print record}    TPrStatus;    PrinterPort : 				{graphic port for printing}    TPPrPort;    DoPrintSetUp :    {Flag for if you want to have standard printing dialog at beginning of print used for finder print}    Boolean;      {System Constant varibles}      MyMenus :                   {All the menus}        array[AppleMenuID..TypeMenuID] of MenuHandle;    Watch : Cursor;             {Holds Watch cursor}    ScreenWidth : Integer;      {Screen Size}    ScreenHeight : integer;    DragArea : Rect;            {Clicking and drawing varible constants}    GrowArea : Rect;    DoubleArea : Integer;  {**************procedures that need to be forwarded**************}{*******************Menu Hilight Procedure*****************}{**********************Window Procedures*****************}  procedure DrawWindow{(var TheWindowData:WindowDataType)};  begin  end; procedure SaveAsText{(var TheWindowData:WindowDataType;              Reply:SfReply;              var OutPut:Text)};  begin  end; procedure LoadAsText{(var TheWindowData:WindowDataType;              Reply:SfReply;              var Input:Text)};  begin  end;  {These procedures handle all window processing that is standard} procedure UpdateDrawWindowPicture (TheWindow : WindowPtr);             var      ThePicture : PicHandle;      OldPort:WindowPtr;        begin    GetPort(OldPort);    SetPort(TheWindow);    ClipRect(TheWindow^.PortRect);    ThePicture := OpenPicture(TheWindow^.PortRect);    DrawPicture(GetWindowPic(TheWindow),TheWindow^.PortRect);    ClosePicture;    SetWindowPic(TheWindow, ThePicture);    SetPort(OldPort);  end; {************MainEventLoop Procedures**********}{This handles all user interaction}{***************DealWithMouseDowns procedures***************}  procedure DoGrow (TheEvent : EventRecord;                  var WhichWindow : WindowPtr);             var      NewSize : LongInt;      NewHeight : Integer;      NewWidth : Integer;      theData : WDHandle;      dataHandle : Handle;      ThePoint : Point;      TempPort : WindowPtr;      ThePicture : PicHandle;     begin    if WhichWindow <> FrontWindow then      SelectWindow(WhichWindow)    else      begin        NewSize := GrowWindow(WhichWindow, TheEvent.where, GrowArea);        if NewSize <> 0 then          begin            NewHeight := HiWord(NewSize);            NewWidth := LoWord(NewSize);            SizeWindow(WhichWindow, NewWidth, NewHeight, true);            getPort(TempPort);            SetPort(WhichWindow); {so we update right window}            InvalRect(WhichWindow^.portRect); { so we will update window}                        dataHandle := Handle(GetWRefCon(TheWindow));            theData := WDHandle(DataHandle);            TheData^^.WindowSize.h := NewWidth;            TheData^^.WindowSize.v := NewHeight;            ThePoint.h := 0;            ThePoint.v := 0;            LocalToGlobal(ThePoint);            TheData^^.WindowLoc := ThePoint;            TheData^^.MaxSized := False;                  DrawWindowPic( TheWindow);                  SetPort(TempPort);          end;      end;  end;   procedure DoDrag (TheEvent : EventRecord;                  WhichWindow : WindowPtr);             var      theData : WDHandle;      dataHandle : Handle;      TheStartPoint, TheEndPoint : Point;      TempPort : WindowPtr;     begin    if WhichWindow <> FrontWindow then      SelectWindow(WhichWindow)    else      begin        GetPort(TempPort);        SetPort(TheWindow);        dataHandle := Handle(GetWRefCon(TheWindow));        theData := WDHandle(DataHandle);        TheStartPoint.h := 0;        TheStartPoint.v := 0;        LocalToGlobal(TheStartPoint);        DragWindow(WhichWindow, TheEvent.Where, DragArea);        TheEndPoint.h := 0;        TheEndPoint.v := 0;        LocalToGlobal(TheEndPoint);        if (TheStartPoint.h <> TheEndPoint.h) and (TheStartPoint.v <> TheEndPoint.v) then          begin            TheData^^.WindowLoc := TheEndPoint;            TheData^^.MaxSized := False;            TheData^^.WindowSize.h := TheWindow^.portRect.right - TheWindow^.portRect.left;            TheData^^.WindowSize.v := TheWindow^.portRect.Bottom - TheWindow^.portRect.top;          end;        SetPort(TempPort);      end;  end;   procedure DoGoAway (TheEvent : EventRecord;                  WhichWindow : WindowPtr);           begin    if WhichWindow <> FrontWindow then      SelectWindow(WhichWindow)    else if TrackGoAway(WhichWindow, TheEvent.Where) then      DoClose;  end;   procedure DoContent (TheEvent : EventRecord;                  WhichWindow : WindowPtr);           begin    if WhichWindow <> FrontWindow then      SelectWindow(WhichWindow);  end; {*************DoMenuBar Procedures ****************}{*************DoMenuChoice Procedures ****************}{*************DoEditChoice Procedures*******************}{**************Scrap Access*********************}  procedure WritePicToScrap;     var      ThePicture : PicHandle;      TheHandle : Handle;     begin    ThePicture := GetWindowPic(TheWindow);    TheHandle := Handle(ThePicture);    Hlock(TheHandle);    if PutScrap(GetHandleSize(TheHandle), 'PICT', TheHandle^) <> noErr then        OKDialog('Error writeing to scrap');    Hunlock(TheHandle);  end;   procedure DoEditChoice (TheItem : Integer);   begin    case TheItem of      UndoItemID :         if not SystemEdit(UndoCmd) then          sysbeep(1);      CutItemID :         if not SystemEdit(CutCmd) then          WritePicToScrap;      CopyItemID :         if not SystemEdit(CopyCmd) then          WritePicToScrap;      PasteItemID :         if not SystemEdit(PasteCmd) then          sysbeep(1);      ClearItemID :         if not SystemEdit(ClearCmd) then          sysbeep(1);    end;  end; {**********DoAppleChoice Procedures*************}  procedure DoAbout;     var      DialogPointer : DialogPtr;     begin    DialogPointer := GetNewDialog(AboutID, nil, pointer(-1));    ShowHide(DialogPointer, true);    Modal(OKType, DialogPointer);    DisposDialog(DialogPointer);    MenuHilight;  end;   procedure DoAppleChoice (TheItem : Integer);     var      accName : str255;      accNumber : integer;     begin    case TheItem of      AboutItemID :         DoAbout;      otherwise        begin          GetItem(MyMenus[AppleMenuID], TheItem, accName);          accNumber := OpenDeskAcc(AccName);          MenuHilight;        end;    end;  end;   {********DoFileChoice Procedures************}   {***************Sub DoFileChoice Procedures**********}    procedure CheckResultError(ResultError:integer;            var error:Boolean);     var      TheError : str255;      TheString:StringHandle;        begin    if ResultError<>noerr then      begin        TheString:=GetString(10000-ResultError);        TheError:=TheString^^;        if TheError='' then          TheError:='Unknown error';        sysbeep(10);        OKDialog(TheError);        Error:=True;      end;  end;    procedure WriteText (Reply : SFReply;                  var error:Boolean);     var      theData : WDHandle;      dataHandle : Handle;      OutPut:Text;      ResultError:integer;      DummyString:StringPtr;      OldVol:integer;      i:integer;        begin    SetCursor(Watch);    error:=False;    dataHandle := Handle(GetWRefCon(TheWindow));    Hlock(DataHandle);{We use a procedure so we need a lock}    theData := WDHandle(DataHandle);        DummyString:=Nil;    ResultError:=GetVol(DummyString,OldVol);    CheckResulterror(ResultError,error);    if ResultError<>noErr then      OKDialog('Could not get current volume')    else      begin        DummyString:=Nil;        ResultError:=SetVol(DummyString,Reply.vRefNum);        CheckResulterror(ResultError,error);        if ResultError<>noErr then          OKDialog('Could not set to correct volume')        else          begin            TextCreator:='Maze';            TextType:='TEXT';                        Rewrite(Output,Reply.Fname);  {Make sure there is a file}            CheckResulterror(IOResult,error);            if IOResult<>noErr then              OKDialog('Could not create dummy file')            else              begin                Close(Output);                CheckResulterror(IOResult,error);                if IOResult<>noErr then                  OKDialog('Could not close dummy file')                else                  begin                    ResultError:=FSDelete (Reply.Fname, Reply.vRefNum);                    CheckResulterror(ResultError,error);                    if ResultError<>noErr then                      OKDialog('Could not delete dummy file')                    else                      begin                        Rewrite(Output,Reply.Fname);                        CheckResulterror(IOResult,error);                        if IOResult<>noErr then                          OKDialog('Could not rewrite file')                        else                          begin                            for i:=1 to 10 do                              Writeln(Output,TheData^^.WindowDatainfo.TypeOfData[i]);                            Writeln(Output,TheData^^.WindowDatainfo.Collecting);                            Writeln(Output,TheData^^.WindowDatainfo.RedrawDelay);                                                        Writeln(Output,TheData^^.WindowLoc.h);                            Writeln(Output,TheData^^.WindowLoc.v);                            Writeln(Output,TheData^^.WindowSize.h);                            Writeln(Output,TheData^^.WindowSize.v);                            SaveAsText(TheData^^, Reply,OutPut);                            CheckResulterror(IOResult,error);                            if IOResult<>noErr then                              OKDialog('error while writing data to disk');                          end;                        Close(Output);                        CheckResulterror(IOResult,error);                        if IOResult<>noErr then                          OKDialog('Could not close file');                      end;                  end;              end;          end;        DummyString:=Nil;        ResultError:=SetVol(DummyString,OldVol);        CheckResulterror(ResultError,error);        if ResultError<>noErr then          OKDIalog('Could not reset to application volume');      end;          if not error then      begin        TheData^^.Reply := Reply;        TheData^^.OnDisk := True;        TheData^^.Changed := False;        SetWTitle(TheWindow, reply.fName);      end;          Hunlock(DataHandle);    SetCursor(Arrow);  end;  procedure ReadText (Reply : SFReply;                var error:Boolean);    var      theData : WDHandle;      dataHandle : Handle;      Input:Text;      ResultError:integer;      DummyString:StringPtr;      OldVol:integer;      i:integer;      Dummy:str255;        begin    SetCursor(Watch);    error:=False;    dataHandle := Handle(GetWRefCon(TheWindow));    Hlock(DataHandle);{We use a procedure so we need a lock}    theData := WDHandle(DataHandle);        DummyString:=Nil;    ResultError:=GetVol(DummyString,OldVol);    CheckResulterror(ResultError,error);    if ResultError<>noerr then      OKDialog('Could not get current volume')    else      begin        DummyString:=Nil;        ResultError:=SetVol(DummyString,Reply.vRefNum);        CheckResulterror(ResultError,error);        if ResultError<>noerr then          OKDialog('Could not set to files volume')        else          begin            Reset(Input,Reply.Fname);            CheckResulterror(IOResult,error);            if IOResult<>noerr then              OKDialog('Could not reset file')            else              begin                for i:=1 to 10 do                  Readln(Input,TheData^^.WindowDatainfo.TypeOfData[i]);                readln(Input,dummy);                if Dummy='TRUE' then                  TheData^^.WindowDatainfo.Collecting:=true                else                  TheData^^.WindowDatainfo.Collecting:=False;                Readln(Input,TheData^^.WindowDatainfo.RedrawDelay);                    TheData^^.LastRedraw:=TickCount;                                TheData^^.Reply:=Reply;                TheData^^.OnDisk :=true;                TheData^^.Changed :=false;                                Readln(Input,TheData^^.WindowLoc.h);                Readln(Input,TheData^^.WindowLoc.v);                Readln(Input,TheData^^.WindowSize.h);                Readln(Input,TheData^^.WindowSize.v);                LoadAsText(TheData^^, Reply,Input);                CheckResulterror(IOResult,error);                if IOResult<>noerr then                  OKDialog('Error during reading of data');              end;            Close(Input);            CheckResulterror(IOResult,error);            if IOResult<>noerr then              OKDialog('Could not close file');          end;        DummyString:=Nil;        ResultError:=SetVol(DummyString,OldVol);        CheckResulterror(ResultError,error);        if ResultError<>noerr then          OKDialog('Could not Set volume back');      end;    SetWTitle(TheWindow, reply.fName);    TheData^^.MaxSized := True;     DoDoubleGrow(TheWindow);    Hunlock(DataHandle);    SetCursor(Arrow);  end; {***************Do New Procedures****************}  {******* NewWindow Procedures ***********}   procedure OffSetWindow (WhichWindow : WindowPtr);     const      offset = 20;       var      windowWidth : integer;      WindowHeight : integer;      HExtra : integer;      VExtra : integer;      HMax : integer;      vMax : integer;      WindowLeft : integer;      WindowTop : integer;      DataHandle:Handle;      TheData:WDHandle;      ThePoint:Point;      OldPort:WindowPtr;        begin    GetPort(OldPort);    SetPort(WhichWindow);    with whichWindow^.portRect do      begin        windowWidth := right - left;        windowHeight := Bottom - top;        WindowHeight := windowHeight + TitleBarHeight;      end;       hextra := ScreenWidth - WindowWidth;    vExtra := ScreenHeight - (WindowHeight + MenuBarHeight);    hMax := (hExtra div offset) + 1;    vMax := (vExtra div offset) + 1;    WindowCount := WindowCount + 1;    WindowLeft := (WindowCount mod hMax) * offset;    WindowTop := (WindowCount mod vMax) * offset;    WindowTop := WindowTop + TitleBarHeight + MenuBarHeight;    MoveWindow(WhichWindow, WindowLeft, WindowTop, False);        dataHandle := Handle(GetWRefCon(WhichWindow));    theData := WDHandle(DataHandle);    TheData^^.WindowSize.h := windowWidth;    TheData^^.WindowSize.v := windowHeight -TitleBarHeight;    ThePoint.h := 0;    ThePoint.v := 0;    LocalToGlobal(ThePoint);    TheData^^.WindowLoc := ThePoint;    TheData^^.MaxSized := False;    SetPort(OldPort);  end;   procedure NewWindow;     var      DataHandle : Handle;      TheString : Str255;     begin    ResrvMem(SizeOf(WindowDataType));    if memError = noerr then      begin        DataHandle := NewHandle(SizeOf(WindowDataType));        TheWindow := GetNewWindow(WindowID, nil, WindowPtr(-1));        SetWRefCon(TheWindow, LongInt(DataHandle));        NumToString(WindowCount, TheString);        SetWTitle(TheWindow, 'Untitled' + TheString);        OffsetWindow(TheWindow);      end    else      begin        sysbeep(10);        okDialog('Memory Error');      end;  end;   procedure DoNew;     var      TempWindowDatainfo : WindowDataInfotype;      i : integer;      theData : WDHandle;      dataHandle : Handle;     begin    TempWindowDatainfo := DefaultWindowDatainfo;    IgnoreErrorCheck := True;    case CollectingMode of      0:StackWindowTypeDialog(TempWindowDatainfo);      1:TapeWindowTypeDialog(TempWindowDatainfo);      2:TDCWindowTypeDialog(TempWindowDatainfo);      3:ADCWindowTypeDialog(TempWindowDatainfo);    end;    IgnoreErrorCheck := false;      if not CancelButton then      begin        NewWindow;            dataHandle := Handle(GetWRefCon(TheWindow));        Hlock(DataHandle);{We call a procedure so we need a lock}        theData := WDHandle(DataHandle);            TheData^^.WindowDataInfo := TempWindowDatainfo;        InitWindowData(TheData^^);        Hunlock(DataHandle);            ShowWindow(TheWindow);      end;  end;   procedure DoOpen;     var      Reply : SfReply;      Error:Boolean;        begin    GetTextReadFile(Reply);    if Reply.good then      begin        newWindow;        ShowWindow(TheWindow);        ReadText(Reply,error);        if error then          DoClose;      end;  end;   {***********DoClose Procedures**********}   procedure CloseAppWindow;     var      theData : WDHandle;      dataHandle : Handle;      ThisWindow : WindowPtr;      TheEvent : EventRecord;     begin    dataHandle := Handle(GetWRefCon(TheWindow));    theData := WDHandle(DataHandle);  {**************************}    CancelButton := False;      if TheData^^.Changed then      begin        YesNoCancelDialog('Do you want to save Changes to ' + TheData^^.Reply.Fname + '?');        if Yesbutton then          doSave;        if CancelButton then          Quitting := False;      end;       if not CancelButton then      begin        ThisWindow := TheWindow;            HideWindow(TheWindow);            if GetNextEvent(ActivMask, TheEvent) then          DealWithActivates(TheEvent);        if GetNextEvent(ActivMask, TheEvent) then          DealWithActivates(TheEvent);                DisposHandle(Datahandle);        DisposeWindow(ThisWindow);      end;  end;   procedure CloseSysWindow; {Needed to close system Windows When Quitting}    var      whichWindow : WindowPeek;      accNumber : integer;     begin    WhichWindow := WindowPeek(FrontWindow);    accNumber := WhichWindow^.WindowKind;    CloseDeskAcc(accNumber);    MenuHilight;  end;   procedure DoClose;   begin    if FrontWindow = TheWindow then      closeAppWindow    else      closeSysWindow;  end;   procedure DoSaveAs;     var      theData : WDHandle;      dataHandle : Handle;      Reply : SFReply;      error:Boolean;        begin    dataHandle := Handle(GetWRefCon(TheWindow));    theData := WDHandle(DataHandle);    Reply := TheData^^.Reply;    GetWriteFile(Reply);    if Reply.Good then      Writetext(Reply,error);  end;   procedure DoSave;     var      theData : WDHandle;      dataHandle : Handle;      Reply : SFReply;      error:Boolean;        begin    dataHandle := Handle(GetWRefCon(TheWindow));    theData := WDHandle(DataHandle);    if TheData^^.OnDisk then      begin        Reply := TheData^^.Reply;        if TheData^^.Changed then          OKCancelDialog('Are you sure you want to write over ' + Reply.fname);        if not CancelButton then          WriteText(Reply,error);      end    else      DoSaveAs;  end;   procedure DoRevert;     var      theData : WDHandle;      dataHandle : Handle;      Reply : SFReply;      error:Boolean;        begin    dataHandle := Handle(GetWRefCon(TheWindow));    theData := WDHandle(DataHandle);    Reply := TheData^^.Reply;    if TheData^^.Changed then      OKCancelDialog('Lose all new data in ' + Reply.fname);    if not CancelButton then      ReadText(Reply,error);  end;   procedure DoPageSetup;     var      trueORfalse : boolean;     begin    PrOpen;    trueORfalse := PrValidate(PgSetUp); { make sure handle is valid}    trueORfalse := PrStlDialog(PgSetUp); { fill the record with the info}    PrClose;  end; {********************DoPrint Procedures*******************}  procedure StartPrinter;   begin    PrOpen;    if DoPrintSetup then      CancelButton := not PrJobDialog(PgSetup)    else      CancelButton := False;    if not CancelButton then      begin        PrinterPort := PrOpenDoc(PgSetup, nil, nil);            if BackGroundPrint then          begin            PgSetup^^.prJob.pIdleProc := @EventLoop; {Background is my program}            HiliteMenu(0);                           {Clear File Blackness}          end;        Printing := True;                            {set Flag so I don't print again}        MenuHilight;        PrOpenPage(PrinterPort, nil);      end;  end; {StartPrinter}   procedure DoPrint;     var      trueorFalse : boolean;      theData : WDHandle;      dataHandle : Handle;      Reply : SFReply;      DialogPointer : DialogPtr;      CurrentPort:WindowPtr;        begin      YesNoCancelDialog('Should this printing be done in the background');    if YesButton then      BackGroundPrint := True    else      BackGroundPrint := False;       trueORfalse := PrValidate(PgSetUp);        PrOpen;    if DoPrintSetup then      CancelButton := not PrJobDialog(PgSetup)    else      CancelButton := False;          if not CancelButton then      begin        PrinterPort := PrOpenDoc(PgSetup, nil, nil);            if BackGroundPrint then          begin            PgSetup^^.prJob.pIdleProc := @EventLoop; {Background is my program}            HiliteMenu(0);                           {Clear File Blackness}          end;        Printing := True;                            {set Flag so I don't print again}        MenuHilight;      end;      if not CancelButton then      begin                PrOpenPage(PrinterPort, nil);                if not BackGroundPrint then          begin            SetCursor(Watch);            DialogPointer := GetNewDialog(PrintingID, nil, pointer(-1));            showWindow(DialogPointer);            drawdialog(DialogPointer);          end;                 GetPort(CurrentPort);        CurrentPort^.PortRect.Top:=CurrentPort^.PortRect.Top+40;                dataHandle := Handle(GetWRefCon(TheWindow));        Hlock(DataHandle);{We call a procedure so we need a lock}        theData := WDHandle(DataHandle);        DrawWindow(TheData^^);                Hunlock(DataHandle);                if not backgroundPrint then          SetCursor(Watch);                PrClosePage(PrinterPort);        PrCloseDoc(PrinterPort);                if PrError <> noErr then          OKDialog('There was a printing error');                  if (PgSetup^^.prJob.bjDocLoop=bSpoolLoop) and (PrError=noerr) then          begin            PrPicFile(PgSetup, nil, nil, nil, myStRec);          end        else          OKDialog('There was a spooling printing error');                  PrClose;            if not BackGroundPrint then          begin            DisposDialog(DialogPointer);            SetCursor(arrow);          end;      end    else      PrClose;       Printing := False;    MenuHilight;  end;   procedure DoFileChoice (TheItem : Integer);   begin    case TheItem of      NewItemID :         DoNew;      OpenItemID :         DoOpen;      CloseItemID :         DoClose;      SaveItemID :         DoSave;      SaveAsItemID :         DoSaveAs;      RevertItemID :         DoRevert;      PageSetUpItemID :         if not Printing then          DoPageSetUp        else          sysbeep(1);      PrintItemID :         if not Printing then          DoPrint        else          sysbeep(1);      StopPrintItemID :         if not Printing then          Sysbeep(1)        else          prSetError(iPrAbort);      QuitItemID :         begin          Quitting := True;          if Printing then            prSetError(iPrAbort);        end;    end;  end;  procedure DoMenuChoice; {(MenuChoice : longint)}     var      TheMenu : Integer;      TheItem : Integer;     begin    if menuChoice <> 0 then      begin        theMenu := HiWord(MenuChoice);        TheItem := LoWord(MenuChoice);            case TheMenu of          AppleMenuID :             DoAppleChoice(TheItem);          FileMenuID :             DoFileChoice(TheItem);          EditMenuID :             DoEditChoice(TheItem);        end;        HiliteMenu(0); {Clear Menu bar of any Black selected things}      end;  end;   procedure DoMenuBar (TheEvent : EventRecord);     var      MenuChoice : LongInt;     begin    MenuChoice := MenuSelect(TheEvent.where);    DoMenuChoice(MenuChoice);  end;   procedure DoDoubleGrow;{(WindowPointedTo:WindowPtr)}     var      theData : WDHandle;      dataHandle : Handle;      TempPort : WindowPtr;     begin    if WindowPointedTo <> FrontWindow then      SelectWindow(WindowPointedTo)    else      begin        GetPort(TempPort);        SetPort(TheWindow);        dataHandle := Handle(GetWRefCon(TheWindow));        Hlock(DataHandle);{We use a with so we need a lock}        theData := WDHandle(DataHandle);            if TheData^^.MaxSized then          with TheData^^ do            begin              HideWindow(WindowPointedTo);              MoveWIndow(WindowPointedTo, WindowLoc.h, WindowLoc.v, true);              SizeWindow(WindowPointedTo, WindowSize.h, WindowSize.v, true);              invalRect(WindowPointedTo^.PortRect);              ShowWindow(WindowPointedTo);              TheData^^.MaxSized := False;              DrawWindowPic(WindowPointedTo);            end        else          begin            HideWindow(WindowPointedTo);            MoveWindow(WindowPointedTo, 5, 40, true);            SizeWindow(WindowPointedTo, ScreenWidth - 10, ScreenHeight - 45, true);            invalRect(WindowPointedTo^.PortRect);            ShowWindow(WindowPointedTo);            TheData^^.MaxSized := True;            DrawWindowPic( WindowPointedTo);          end;        SetPort(TempPort);        Hunlock(DataHandle);      end;  end;   procedure DealWithMouseDowns (theEvent : EventRecord);     var      location : Integer;      windowPointedTo : WindowPtr;      Loc : point;      windowLoc : integer;      VandH : Longint;      Height : Integer;      Width : Integer;     begin    Loc := theEvent.where;    windowLoc := FindWindow(Loc, windowPointedTo);      if ((tickcount - lastclick) < GetdblTime) and (abs(loc.h - LastMouse.h)         < DoubleArea) and (abs(loc.v - LastMouse.v) < DoubleArea) then        {Double click things to happen}        case windowLoc of        inDesk :           ;    {Do Nothing}        inMenuBar :           DoMenuBar(TheEvent);        inSysWindow :           SystemClick(theEvent, windowPointedTo);        inContent :           DoContent(TheEvent, windowPointedTo);        inGrow :           DoGrow(TheEvent, WindowPointedTo);        inDrag :           DoDoubleGrow(WindowPointedTo);        inGoAway :           DoGoAway(TheEvent, WindowPointedTo);      end       else      {Single Click Things to Happen}        case windowLoc of        inDesk :           ;    {Do Nothing}        inMenuBar :           DoMenuBar(TheEvent);        inSysWindow :           begin            SystemClick(theEvent, windowPointedTo);            MenuHilight;          end;        inContent :           DoContent(TheEvent, windowPointedTo);        inGrow :           DoGrow(TheEvent, WindowPointedTo);        inDrag :           DoDrag(TheEvent, WindowPointedTo);        inGoAway :           DoGoAway(TheEvent, WindowPointedTo);      end;       LastClick := TickCount;    LastMouse := Loc;  end;   procedure DealWithActivates; {(theEvent : EventRecord)}     const      ChangeFlag = $0002;       var      WhichWindow : WindowPtr;     begin    with TheEvent do      begin        WhichWindow := WindowPtr(message);        if BitAnd(modifiers, ActiveFlag) <> 0 then          begin            TheWindow := WhichWindow;                  if BitAnd(Modifiers, ChangeFlag) <> 0 then { comming from a system Window?}        {read desk scrap into toolbox scrap}              ;                   MenuHilight;                end{Then}        else          begin            TheWindow := nil;                  if BitAnd(Modifiers, changeFlag) <> 0 then {Exiting to a system window}              begin            {write current toolbox Scrap to desk scrap}                ;              end;                   MenuHilight;          end;{else}      end;{with}  end;   procedure DealWithUpdates (theEvent : EventRecord);     var      UpDateWindow : WindowPtr;      tempPort : WindowPtr;      TheData : WDHandle;      DataHandle : Handle;     begin    UpDateWindow := WindowPtr(theEvent.message);    GetPort(tempPort);    SetPort(UpDateWindow);    dataHandle := Handle(GetWRefCon(UpDateWindow));    Hlock(DataHandle);      {Need to lock it because drawhistogram uses a procedure call}    TheData := WDHandle(DataHandle);    DrawWindowPic( UpDateWindow); {Set windowpic so mac can handle updates itself}    InvalRect(UpdateWindow^.PortRect);  {Make sure whole window is updated at once}    HUnlock(DataHandle);    SetPort(tempPort);  end;   procedure DealWithKeyDowns (theEvent : EventRecord);     var      CharCode : integer;      ch : Char;      MenuChoice : longint;     begin    with TheEvent do      begin        charCode := BitAnd(Message, CharCodeMask);        ch := chr(CharCode);            if BitAnd(theEvent.modifiers, CmdKey) <> 0 then          begin            if what <> AutoKey then              begin                menuChoice := MenuKey(ch);                DoMenuChoice(MenuChoice);              end;          end        else{Dotyping}      end;  end;   procedure EventLoop;     var      Event : EventRecord;      ProcessIt : boolean;      TempPort : WindowPtr;     begin    GetPort(TempPort); {save Port For background printing}    SystemTask;    if collecting then      MyTasks;    ProcessIt := GetNextEvent(everyEvent, Event); { get the next event in queue}    if ProcessIt then      begin        case Event.what of          mouseDown :             if not Quitting then              DealWithMouseDowns(Event);          AutoKey :             if not Quitting then              DealWithKeyDowns(Event);          KeyDown :             if not Quitting then              DealWithKeyDowns(Event);          ActivateEvt :             DealWithActivates(Event);          UpdateEvt :             DealWithUpdates(Event);        end;      end    else      begin        if Quitting and (Event.What = NullEvent) then          begin            if FrontWindow <> nil then              DoClose            else              Finished := true;          end;      end;    SetPort(TempPort); {get back Port For background printing}  end; {*************InitThings Procedures**************}  procedure SetUpCursors;     var      WatchHandle : CursHandle;     begin    WatchHandle := GetCursor(WatchCursor);    Watch := WatchHandle^^;  end;   procedure SetupMemory;     var        i:integer;          begin    for i:=1 to 20 do        MoreMasters;    MaxApplZone;  end;   procedure SetUpMenus;		{ get the menus & display them}     var      index : Integer;     begin    for index := AppleMenuID to TypeMenuID do      begin        myMenus[index] := GetMenu(index);        InsertMenu(myMenus[index], 0);      end;    AddResMenu(myMenus[AppleMenuID], 'DRVR');  end;   procedure SetupLimits;		{ set up the dragging and growing rects}     var      Screen : Rect;     begin    Screen := ScreenBits.bounds;    with Screen do      begin        ScreenHeight := bottom - top;        ScreenWidth := Right - Left;        SetRect(DragArea, left + 4, top + 24, right - 4, bottom - 4);        SetRect(GrowArea, left, top + 24, right, bottom);        GrowArea.left := 150;        GrowArea.top := 100;        DoubleArea := 4;      end;  end;   procedure DoStartup;     var      Message : integer;      Count : integer;      Reply : SFReply;      AFile : AppFile;      i : integer;      error:Boolean;        begin    CountAppFiles(Message, Count);    if (Message = AppOpen) and (Count > 0) then      for i := 1 to count do        begin          GetAppFiles(i, AFile);          Reply.vRefNum := AFile.vRefNum;          Reply.fType := AFile.Ftype;          Reply.version := AFile.VersNum;          Reply.FName := AFile.Fname;          NewWindow;          ShowWindow(TheWindow);          ReadText(Reply,error);          clrappfiles(i);        end    else if (Message = AppPrint) and (Count > 0) then      begin        NewWindow;        DoPageSetUp;        for i := 1 to count do          begin            GetAppFiles(i, AFile);            Reply.vRefNum := AFile.vRefNum;            Reply.fType := AFile.Ftype;            Reply.version := AFile.VersNum;            Reply.FName := AFile.Fname;            ReadText(Reply,error);            DoPrint;            clrappfiles(i);            DoPrintSetup := False;          end;        Quitting := True;        DoClose;      end;  end;   procedure SetupPrinter;     var      TheHandle : Handle;     begin    prOpen;    ResrvMem(SizeOf(PgSetUp));    PgSetUp := THPrint(NewHandle(SizeOf(TPrint))); {make handle}    PrintDefault(PgSetUp); 	{initialize the fields}    TheHandle := Handle(PgSetUp);    HLock(TheHandle);  {Lock it for some reason??}    PrClose;    DoPrintSetup := True;  {Do Print setup when printing}    {mystrec}  end;   procedure InitThings;   begin    SetUpMemory;    FlushEvents(everyEvent, 0);      InitGraf(@thePort);    InitFonts;    InitWindows;    InitMenus;    TEInit;    InitDialogs(nil);    InitCursor;    InitAllPacks;      TheWindow := nil;     {None of my windows up yet}    Finished := False;    Quitting := False;    Drawing:=true;    WindowCount := 0;     {None of my windows up yet}    SetPt(LastMouse, 0, 0);      SetUpLimits;    SetUpMenus;    SetUpcursors;    SetUpPrinter;    DoStartUp;  end;  procedure CloseThings;   begin    {Doesm't open anything}  end;  begin  initThings;  repeat    EventLoop;  until Finished;  CloseThings;end.