program MNtoLSUTransfer;	{$R Jim Surine:Programming:Reasources:Transfer.Rsrc}						{Load my reasources (dialog boxes etc..)}	{$B+}															{Set bundle bit so finder will use my icon}	{$T APPLTran}							{set my file type and creator} {$U-}  {$O Jim Surine:Programming:Programs:Transfers:Transfer v1.0}USES PasInOut,SANE,Memtypes,QuickDraw,OSIntf,ToolIntf,PackIntf,FileIo;		type		{My Types}		arr4=			array[1..4] of real;		{arrary of 4 reals}		ari4=			array[1..4] of integer;	{Arrary of 4 integers}  Files=    array[1..300] of SFReply;		strtype=			string[10];							{string size to shrink record size} 		HeaderType=								{Header storage record definition} 			record 				Reply:SfReply;				{current File system reply from last load} 				NumParticle:Integer;	{counter holds number of particles in list} 				Beam:strtype; 				Date:strtype; 				Event:strtype; 				operator:strtype; 				Plate:strtype; 				part:strtype; 				Rangetostar:strtype; 				ShrinkFactZT:Real; 				ShrinkFactZM:Real; 				ShrinkFactAN:Real; 				Magnification:Real; 				ZZO:Real; 				X:arr4; 				y:arr4; 				z:arr4; 				slopexy:real;	 				slopezy:real; 				Primary:strtype; 				Frag:strtype; 				a:strtype; 				p:strtype; 				M:strtype; 				NB:ari4; 				G1:ari4; 				G2:ari4; 				G3:ari4; 				NH:ari4; 				energyQ:arr4;     FBlack:integer;     BBlack:integer;     NBlack:integer; 				FtoBBlack:real;     FGrey:integer;     BGrey:integer;     NGrey:integer; 				FtoBGrey:real;         NHtotal:integer;     energytotal:real; 			end; 		ParticleType=							{Holds each particle information} 			record 				Number:strtype;				{Particle information} 				xsec:real; 				ysec:real; 				zsec:real; 				GrainCount:real; 				P:real; 				L:real;				beta:real;					{beta}				degrees:real;				{beta expressed in degrees}				azimuth:real;				{azimuth angle}				azidegree:real;			{azimuth angle expressed in degress}				pseudo:real;				{pseudoripidity}									{slope of children particles with respect to the primary}				deltax:real;						{the value calculated from the raw data}				deltay:real;						{the value calculated from the raw data}				deltaz:real;      {the value calculated from the raw data}				bigx:real;				bigz:real;				deltar:real;				xstar:real;				ystar:real;				zstar:real;			end;  var    ReplyRead,ReplyWrite:SFReply;    SortFiles:Files;    input,Output:Text;    Message,Count,i,j:integer;    TheFile:AppFile;    SortName:str255;    Sortcount:integer;    SortTemp:SFReply;    SeparateChr:str255;     {************************}  	procedure CleanHeader(var Header:HeaderType);		var			i:integer;		begin			with Header do				begin					Beam:=''; 				Date:=''; 				Event:=''; 				operator:=''; 				Plate:=''; 				part:=''; 				Rangetostar:=''; 				ShrinkFactZT:=0; 				ShrinkFactZM:=0; 				ShrinkFactAN:=0; 				Magnification:=0; 				ZZO:=0;     for i:= 1 to 4 do        begin 				       X[i]:=0; 				       y[i]:=0; 				       z[i]:=0;        end; 				slopexy:=0;	 				slopezy:=0; 				Primary:=''; 				Frag:=''; 				a:=''; 				p:=''; 				M:='';     for i:= 1 to 4 do        begin 				       NB[i]:=0; 				       G1[i]:=0; 				       G2[i]:=0; 				       G3[i]:=0; 				       NH[i]:=0;            energyQ[i]:=0;        end;     FBlack:=0;     BBlack:=0;     NBlack:=0; 				FtoBBlack:=0;     FGrey:=0;     BGrey:=0;     NGrey:=0; 				FtoBGrey:=0;         NHtotal:=0;     energytotal:=0; 			end;		end;procedure CleanParticle(var Particle:ParticleType);		begin			with Particle do				begin					number:='';					xsec:=0; 				ysec:=0; 				zsec:=0; 				GrainCount:=0; 				P:=0; 				L:=0;					beta:=0;					pseudo:=0;					azimuth:=0;					degrees:=0;					azidegree:=0;					deltax:=0;					deltay:=0;					deltaz:=0;					bigx:=0;					bigz:=0;					deltar:=0;					XStar:=0;					YStar:=0;					ZStar:=0;				end;		end;{*******************************************************}  Procedure OpenToReadStandard(Reply:SFReply);   Begin    Reset(input,Reply.fname);  end;   Procedure OpenToWriteStandard(Reply:SFReply);   Begin    Rewrite(Output,Reply.fname);  end;   Procedure CloseToReadStandard;   Begin    Close(input);  end;   Procedure CloseToWriteStandard;   Begin    Close(Output);  end;	procedure WriteParticleStandard(Particle:ParticleType;Number:Integer);		begin   writeln(Output,chr(10),Number);			with Particle do				begin					writeln(OutPut,SeparateChr,Particle.number);					writeln(OutPut,SeparateChr,xsec:9:9); 				writeln(OutPut,SeparateChr,ysec:9:9); 				writeln(OutPut,SeparateChr,zsec:9:9); 				writeln(OutPut,SeparateChr,GrainCount:9:9); 				writeln(OutPut,SeparateChr,P:9:9); 				writeln(OutPut,SeparateChr,L:9:9);					writeln(OutPut,SeparateChr,beta:9:9);					writeln(OutPut,SeparateChr,pseudo:9:9);					writeln(OutPut,SeparateChr,azimuth:9:9);					writeln(OutPut,SeparateChr,degrees:9:9);					writeln(OutPut,SeparateChr,azidegree:9:9);					writeln(OutPut,SeparateChr,deltax:9:9);					writeln(OutPut,SeparateChr,deltay:9:9);					writeln(OutPut,SeparateChr,deltaz:9:9);					writeln(OutPut,SeparateChr,bigx:9:9);					writeln(OutPut,SeparateChr,bigz:9:9);					writeln(OutPut,SeparateChr,deltar:9:9);					writeln(OutPut,SeparateChr,XStar:9:9);					writeln(OutPut,SeparateChr,YStar:9:9);					writeln(OutPut,SeparateChr,ZStar:9:9);				end;		end;	procedure WriteHeaderStandard(Header:HeaderType);		var			i:integer;		begin			with Header do				begin     writeln(OutPut,SeparateChr,NumParticle);					writeln(OutPut,SeparateChr,Beam); 				writeln(OutPut,SeparateChr,Date); 				writeln(OutPut,SeparateChr,Event); 				writeln(OutPut,SeparateChr,operator); 				writeln(OutPut,SeparateChr,Plate); 				writeln(OutPut,SeparateChr,part); 				writeln(OutPut,SeparateChr,Rangetostar); 				writeln(OutPut,SeparateChr,ShrinkFactZT:9:9); 				writeln(OutPut,SeparateChr,ShrinkFactZM:9:9); 				writeln(OutPut,SeparateChr,ShrinkFactAN:9:9); 				writeln(OutPut,SeparateChr,Magnification:9:9); 				writeln(OutPut,SeparateChr,ZZO:9:9);     for i:= 1 to 4 do        begin 				       writeln(OutPut,SeparateChr,X[i]:9:9); 				       writeln(OutPut,SeparateChr,y[i]:9:9); 				       writeln(OutPut,SeparateChr,z[i]:9:9);        end; 				writeln(OutPut,SeparateChr,slopexy:9:9);	 				writeln(OutPut,SeparateChr,slopezy:9:9); 				writeln(OutPut,SeparateChr,Primary); 				writeln(OutPut,SeparateChr,Frag); 				writeln(OutPut,SeparateChr,a); 				writeln(OutPut,SeparateChr,p); 				writeln(OutPut,SeparateChr,M);     for i:= 1 to 4 do        begin 				       writeln(OutPut,SeparateChr,NB[i]); 				       writeln(OutPut,SeparateChr,G1[i]); 				       writeln(OutPut,SeparateChr,G2[i]); 				       writeln(OutPut,SeparateChr,G3[i]); 				       writeln(OutPut,SeparateChr,NH[i]);            writeln(OutPut,SeparateChr,energyQ[i]:9:9);        end;     writeln(OutPut,SeparateChr,FBlack:9);     writeln(OutPut,SeparateChr,BBlack:9);     writeln(OutPut,SeparateChr,NBlack:9); 				writeln(OutPut,SeparateChr,FtoBBlack:9:9);     writeln(OutPut,SeparateChr,FGrey:9);     writeln(OutPut,SeparateChr,BGrey:9);     writeln(OutPut,SeparateChr,NGrey:9); 				writeln(OutPut,SeparateChr,FtoBGrey:9:9);         writeln(OutPut,SeparateChr,NHtotal);     writeln(OutPut,SeparateChr,energytotal:9:9); 			end;		end;		procedure WriteHeaderExcel(Header:HeaderType);		var			i:integer;		begin			with Header do				begin     Write(OutPut,NumParticle);					Write(OutPut,chr(9),Beam); 				Write(OutPut,chr(9),Date); 				Write(OutPut,chr(9),Event); 				Write(OutPut,chr(9),operator); 				Write(OutPut,chr(9),Plate); 				Write(OutPut,chr(9),part); 				Write(OutPut,chr(9),Rangetostar); 				Write(OutPut,chr(9),ShrinkFactZT:9:9); 				Write(OutPut,chr(9),ShrinkFactZM:9:9); 				Write(OutPut,chr(9),ShrinkFactAN:9:9); 				Write(OutPut,chr(9),Magnification:9:9); 				Write(OutPut,chr(9),ZZO:9:9);     for i:= 1 to 4 do        begin 				       Write(OutPut,chr(9),X[i]:9:9); 				       Write(OutPut,chr(9),y[i]:9:9); 				       Write(OutPut,chr(9),z[i]:9:9);        end; 				Write(OutPut,chr(9),slopexy:9:9);	 				Write(OutPut,chr(9),slopezy:9:9); 				Write(OutPut,chr(9),Primary); 				Write(OutPut,chr(9),Frag); 				Write(OutPut,chr(9),a); 				Write(OutPut,chr(9),p); 				Write(OutPut,chr(9),M);     for i:= 1 to 4 do        begin 				       Write(OutPut,chr(9),NB[i]); 				       Write(OutPut,chr(9),G1[i]); 				       Write(OutPut,chr(9),G2[i]); 				       Write(OutPut,chr(9),G3[i]); 				       Write(OutPut,chr(9),NH[i]);            Write(OutPut,chr(9),energyQ[i]:9:9);        end;     Write(OutPut,chr(9),FBlack:9);     Write(OutPut,chr(9),BBlack:9);     Write(OutPut,chr(9),NBlack:9); 				Write(OutPut,chr(9),FtoBBlack:9:9);     Write(OutPut,chr(9),FGrey:9);     Write(OutPut,chr(9),BGrey:9);     Write(OutPut,chr(9),NGrey:9); 				Write(OutPut,chr(9),FtoBGrey:9:9);         Write(OutPut,chr(9),NHtotal);     Writeln(OutPut,chr(9),energytotal:9:9); 			end;		end;	procedure ReadParticleStandard(VAR Particle:ParticleType);  var     Number:Integer;    		begin   Readln(Input,Number);			with Particle do				begin					Readln(input,number);					Readln(input,xsec); 				Readln(input,ysec); 				Readln(input,zsec); 				Readln(input,GrainCount); 				Readln(input,P); 				Readln(input,L);					Readln(input,beta);					Readln(input,pseudo);					Readln(input,azimuth);					Readln(input,degrees);					Readln(input,azidegree);					Readln(input,deltax);					Readln(input,deltay);					Readln(input,deltaz);					Readln(input,bigx);					Readln(input,bigz);					Readln(input,deltar);					Readln(input,XStar);					Readln(input,YStar);					Readln(input,ZStar);				end;		end;	procedure ReadHeaderStandard(VAR Header:HeaderType);		var			i:integer;		begin			with Header do				begin     Readln(input,NumParticle);					Readln(input,Beam); 				Readln(input,Date); 				Readln(input,Event); 				Readln(input,operator); 				Readln(input,Plate); 				Readln(input,part); 				Readln(input,Rangetostar); 				Readln(input,ShrinkFactZT); 				Readln(input,ShrinkFactZM); 				Readln(input,ShrinkFactAN); 				Readln(input,Magnification); 				Readln(input,ZZO);     for i:= 1 to 4 do        begin 				       Readln(input,X[i]); 				       Readln(input,y[i]); 				       Readln(input,z[i]);        end; 				Readln(input,slopexy);	 				Readln(input,slopezy); 				Readln(input,Primary); 				Readln(input,Frag); 				Readln(input,a); 				Readln(input,p); 				Readln(input,M);     for i:= 1 to 4 do        begin 				       Readln(input,NB[i]); 				       Readln(input,G1[i]); 				       Readln(input,G2[i]); 				       Readln(input,G3[i]); 				       Readln(input,NH[i]);            Readln(input,energyQ[i]);        end;     Readln(input,FBlack);     Readln(input,BBlack);     Readln(input,NBlack); 				Readln(input,FtoBBlack);     Readln(input,FGrey);     Readln(input,BGrey);     Readln(input,NGrey); 				Readln(input,FtoBGrey);         Readln(input,NHtotal);     Readln(input,energytotal); 			end;		end;{*****************************} Procedure OpenToReadFileIo(VAR Reply:SFReply;VAR f:FileRec);   Begin    FReset(f,reply.vRefNum,reply.fName);  end;   Procedure OpenToWriteFileIo(VAR Reply:SFReply;Var f:FileRec);   Begin    FRewrite(f,reply.vRefNum,reply.fName,'DATA','MICR');  end;   Procedure OpenToWriteFileIoLSU(VAR Reply:SFReply;Var f:FileRec);   Begin    FRewrite(f,reply.vRefNum,reply.fName,'DATA','Tran');  end; Procedure CloseToReadFileIo( var f:FileRec);   Begin    FClose(f);  end;   Procedure CloseToWriteFileIo( var f:FileRec);   Begin    FClose(f);  end;	procedure WriteParticleFileIo(Particle:ParticleType;var f:FileRec);		begin		  FPutM(f,@Particle,SizeOf(Particle));		end;	procedure WriteHeaderFileIo(Header:HeaderType;var f:FileRec);		begin				FPutM(f,@Header,SizeOf(Header));		end;	procedure ReadParticleFileIo(VAR Particle:ParticleType;var f:FileRec);		begin    FGetM(f,@Particle,SizeOf(Particle));		end;	procedure ReadHeaderFileIo(VAR Header:HeaderType;var f:FileRec);		begin    FGetM(f,@Header,SizeOf(Header));		end;{**********************************************************************}			procedure GetReadFileStandard(var reply:SFReply);				var					pt:point;					FileType:SFTypeList;				begin					pt.h:=50;					pt.v:=50;					FileType[0][1]:='T';					FileType[0][2]:='E';					FileType[0][3]:='X';					FileType[0][4]:='T';					SFGetFile(pt,'Enter Standard File',nil,1,filetype,nil,reply);				end;	procedure GetReadFileFileIo(var reply:SFReply);				var					pt:point;					FileType:SFTypeList;				begin					pt.h:=50;					pt.v:=50;					FileType[0][1]:='D';					FileType[0][2]:='A';					FileType[0][3]:='T';					FileType[0][4]:='A';					SFGetFile(pt,'Enter FileIo File',nil,1,filetype,nil,reply);				end;  procedure GetWriteFile(var reply:SFReply);				var					pt:point;				begin					pt.h:=50;					pt.v:=50;					SFPutFile(pt,'Save File','',nil,reply);				end;  Procedure ReadStandardWriteFileIo(ReplyRead:SFReply;                                  ReplyWrite:SFReply);  var   FileOut:FileRec;  Header:HeaderType;  Particle:ParticleType;  i:integer;    begin  OpenToReadStandard(ReplyRead);  OpenToWriteFileIo(ReplyWrite,FileOut);  ReadHeaderStandard(Header);  WriteHeaderFileIo(Header,FileOut);  for i := 1 to header.NumParticle do    begin      ReadParticleStandard(Particle);      WriteParticleFileIo(Particle,FileOut);    end;  CloseToReadStandard;  CloseToWriteFileIo(FileOut);end;procedure ReadHeaderLSU(var Header:HeaderType);  var    number:integer;    TheString:Str255;			 LongNumber1:longint;    LongNumber2:longint;    LongNumber3:longint;    LongNumber4:longint;      begin    cleanHeader(Header);    Read(input,LongNumber1);    NumToString(LongNumber1,TheString);    Header.Beam:=TheString;        getdatetime(LongNumber1);				IUDateString(LongNumber1,shortDate,TheString);				Header.Date:=TheString;    read(input,longNumber1);    NumToString(LongNumber1,TheString);          StringToNum(copy(TheString,1,1),Longnumber1);      case longnumber1 of        1:Header.Operator:='Poland';        2:Header.Operator:='LSU';        3:Header.Operator:='Minnesota';      end;            Header.Plate:=Copy(TheString,4,2);      Header.Part:=copy(TheString,6,3);        read(input,LongNumber1);    numToString(LongNumber1,TheString);    Header.frag:=TheString;        read(input,LongNumber2);    numToString(LongNumber2,TheString);    Header.a:=TheString;        LongNumber3:=8-2*LongNumber2-LongNumber1;       NumToString(LongNumber3,TheString);    Header.p:=TheString;        read(input,Number);    Read(input,Number);    Read(input,longNumber4);        if LongNumber1<>0 then      LongNumber1:=1;          NumToString(LongNumber4-LongNumber3-LongNumber2-LongNumber1,TheString);    Header.M:=TheSTring;        Read(input,LongNumber1);    Header.NHTotal:=LongNumber1-LongNumber4;        Header.NumParticle:=LongNumber1;        Read(input,LongNumber1);    Read(input,LongNumber2);        if longNumber2<>0 then      Header.zzo:=LongNumber1/LongNumber2    else      Header.zzo:=0;          Read(input,Header.X[1]);    Read(input,Header.Y[1]);    Read(input,Header.Z[1]);  end;    Procedure ReadParticleLSU(var Particle:ParticleType);      var      LongNumber1,LongNumber2:LongInt;          begin      CleanParticle(Particle);      Read(Input,LongNumber1);      case LongNumber1 Of        1:Particle.Number:='7';        2:Particle.Number:='8';        3:Particle.Number:='2';        4:Particle.Number:='5';        5:Particle.Number:='4';      end;            Read(Input,LongNumber1);      Particle.degrees:=LongNumber1/1000;      Particle.Beta:=(LongNumber1/1000)*(3.141596/180);            Read(Input,LongNumber2);      Particle.Azidegree:=LongNumber2/1000;      Particle.Azimuth:=(LongNumber2/1000)*((2*3.141596)/360);            Particle.Pseudo:=-ln(Tan(Particle.Beta/2));            Read(Input,LongNumber1);      Read(Input,LongNumber1);      Particle.GrainCount:=LongNumber1;    end;      Procedure ReadTheirLSUWriteFileIo(ReplyRead:SFReply;                                  ReplyWrite:SFReply);  var   FileOut:FileRec;  Header:HeaderType;  Particle:ParticleType;  i:integer;    begin  OpenToReadStandard(ReplyRead);    While not eof(Input) do    begin      ReadHeaderLSU(Header);      ReplyWrite.fname:='Plate '+Header.Plate+' Part '+Header.Part;            OpenToWriteFileIoLSU(ReplyWrite,FileOut);      WriteHeaderFileIo(Header,FileOut);      for i := 1 to header.NumParticle do        begin          if ((i-1) mod 4) = 0 then            Readln(Input);          ReadParticleLSU(Particle);          WriteParticleFileIo(Particle,FileOut);        end;              sysbeep(1);            ReadLn(input);              CloseToWriteFileIo(FileOut);    end;  CloseToReadStandard;end; Procedure ReadOurLSUWriteFileIo(ReplyRead:SFReply;                                  ReplyWrite:SFReply);  var   FileOut:FileRec;  Header:HeaderType;  Particle:ParticleType;  i:integer;    begin  OpenToReadStandard(ReplyRead);    While not eof(input) do    begin      ReadHeaderStandard(Header);      ReplyWrite.fname:='Plate '+Header.Plate+' Part '+Header.Part;            OpenToWriteFileIo(ReplyWrite,FileOut);      WriteHeaderFileIo(Header,FileOut);      for i := 1 to header.NumParticle do        begin          ReadParticleStandard(Particle);          WriteParticleFileIo(Particle,FileOut);        end;              sysbeep(1);              CloseToWriteFileIo(FileOut);    end;  CloseToReadStandard;end;Procedure ReadFileIoWriteStandard(ReplyRead:SFReply;ReplyWrite:SFReply);  var  FileIn:FileRec;  Header:HeaderType;  Particle:ParticleType;  i:integer;  begin  OpenToReadFileIo(ReplyRead,Filein);  OpenToWriteStandard(ReplyWrite);  ReadHeaderFileIo(Header,Filein);  WriteHeaderStandard(Header);  for i := 1 to header.NumParticle do    begin      ReadParticleFileIo(Particle,Filein);      WriteParticleStandard(Particle,i);    end;  CloseToReadFileIo(Filein);  CloseToWriteStandard;end;Procedure ReadFileIoAppendStandard(ReplyRead:SFReply;ReplyWrite:SFReply);  var  FileIn:FileRec;  Header:HeaderType;  Particle:ParticleType;  i:integer;  begin  OpenToReadFileIo(ReplyRead,Filein);  ReadHeaderFileIo(Header,Filein);  WriteHeaderStandard(Header);  for i := 1 to header.NumParticle do    begin      ReadParticleFileIo(Particle,Filein);      WriteParticleStandard(Particle,i);    end;  CloseToReadFileIo(Filein);end;Procedure ReadFileIoAppendExcelHeader(ReplyRead:SFReply;ReplyWrite:SFReply);  var  FileIn:FileRec;  Header:HeaderType;  Particle:ParticleType;  i:integer;  begin  OpenToReadFileIo(ReplyRead,Filein);  ReadHeaderFileIo(Header,Filein);  WriteHeaderExcel(Header);  CloseToReadFileIo(Filein);end;	procedure InitThings;		begin			FlushEvents(everyEvent,0);			InitGraf(@thePort);			InitFonts;			InitWindows;			InitMenus;			TEInit;			InitDialogs(nil);			InitCursor;			InitAllPacks;				MaxApplZone;				MoreMasters;				MoreMasters;				MoreMasters;    FileIoInit;				SetBufSize(32769*2);		end;{***********************}	begin		initThings;  CountAppFiles(Message,Count);  SeparateChr:='';  {Select Files Run}    if (Message = AppOpen) and (Count > 0) then    begin     getWriteFile(ReplyWrite);     if ReplyWrite.Good then      begin       OpenToWriteStandard(ReplyWrite);              {Store file Reply's in array to sort}              for i:=1 to count do         begin          GetAppFiles(i,TheFile);          ReplyRead.vRefNum:=TheFile.vRefNum;          ReplyRead.fType:=TheFile.Ftype;          ReplyRead.version:=TheFile.VersNum;          ReplyRead.FName:=TheFile.Fname;          SortFiles[i]:=ReplyRead;         end;                {Sort by filename}              for i:=1 to count-1 do        begin          SortName:=SortFiles[i].FName;          sortcount:=i;          for j:= i+1 to count do             begin                if SortFiles[j].FName< SortName then                  begin                    SortName:=SortFiles[j].FName;                    sortcount:=j;                  end;             end;          SortTemp:=SortFiles[i];          SortFiles[i]:=SortFiles[sortcount];          SortFiles[sortcount]:=SortTemp;         end;                {Do Stuff With Files}              {Write Stadard Text File for LSU to Read}              SeparateChr:=Chr(10); {Need Line Feeds For LSU}       WriteLn(Output,SeparateChr,Count);       for i:=1 to count do          ReadFileIoAppendStandard(SortFiles[i],ReplyWrite);       {Write Headers for excel to read}              {WriteLn(Output,SeparateChr,Count);        for i:=1 to count do          ReadFileIoAppendExcelHeader(ReplyRead:SFReply;ReplyWrite:SFReply);}                 {Read Standard Text Files Created With This Program and convert to Micro}              {for i:=1 to count do          begin            ReplyWrite.fname:=SortFiles[i]+'.trns';            ReadStandardWriteFileIo(SortFiles[i],ReplyWrite);          end;}              {Read FileIo Micro files and Write Standard Text Files For Conversions}              {for i:=1 to count do          begin            ReplyWrite.fname:=SortFiles[i]+'.trns';            ReadFileIoWriteStandard(ReplyRead,ReplyWrite);          end;}       CloseToWriteStandard;      end;    end      else      {If Direct Run}       begin    GetReadFileStandard(ReplyRead);    if ReplyRead.Good then      begin        GetWriteFile(ReplyWrite);        if ReplyWrite.Good then          begin                      {Do Your Stuff}                        {Read Their LSU data files and write partial micro datafile}            ReadTheirLSUWriteFileIo(ReplyRead,ReplyWrite);                        {Read our LSU text data files and write partial micro datafile}            {ReadOurLSUWriteFileIo(ReplyRead,ReplyWrite);}                        {Read Standard Text Files Created With This Program and convert to Micro}            {ReadStandardWriteFileIo(ReplyRead,ReplyWrite);}                        {Read FileIo Micro files and Write Standard Text Files For Conversions}            {ReadFileIoWriteStandard(ReplyRead:SFReply;ReplyWrite:SFReply);}                        {Read LSU Text File and Create the Fileio file it was from}          end;      end;    end;    	end.