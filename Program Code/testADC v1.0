 program test; {$U-} {Use My own include Librarys}	{$R-} {use my own Resources} {$R DeviceRsrc}	{Load my reasources (dialog boxes etc..)} uses  Memtypes,          {Basic types stanadard}  QuickDraw,         {Quickdraw standard}  OSIntf,            {Operating system standard}  ToolIntf,          {Tools standard}  PackIntf,          {Package stuff (List Manager, Decimal to string convert)}  Serial,            {RS232 port driver}  sane;              {For Real number conversions}    var    number1,number2:longint;    i:integer;      const   DebugDialogID = 6002; SetDialog=True; GetDialof=False;    procedure SetGetDlgLongInt (Item : integer;        var theLongInt : LongInt;        DialogPointer : DialogPtr;        SetGet : Boolean);{Works with long integers} var  ItemType : integer;  TextHandle : Handle;  Box : rect;  TheString : str255;begin GetDItem(DialogPointer, item, ItemType, TextHandle, Box); if (ItemType = StatText) or (ItemType=EditText) then  if SetGet then   begin    NumToString(TheLongInt, TheString);    SetItext(TextHandle, TheString);   end  else   begin    GetItext(TextHandle, TheString);    StringtoNum(TheString, TheLongInt);   end else  sysbeep(1);end;procedure SetGetDlgStr255 (Item : integer;        var TheString : str255;        DialogPointer : DialogPtr;        SetGet : Boolean);{Works with strings} var  ItemType : integer;  TextHandle : Handle;  Box : rect;begin GetDItem(DialogPointer, Item, ItemType, TextHandle, Box); if (ItemType = StatText) or (ItemType=EditText) then  if SetGet then   SetItext(TextHandle, TheString)  else   GetItext(TextHandle, TheString) else  sysbeep(1);end;procedure DebugDialog (TheInteger1 : longint;        TheString1 : str255;        TheInteger2 : longint);{Use it for debugging} var  DialogPointer : DialogPtr;itemhit:integer;begin DialogPointer := GetNewDialog(DebugDialogID, nil, pointer(-1)); SetGetDlgLongInt(3, TheInteger1, DialogPointer, SetDialog); SetGetDlgstr255(4, TheString1, DialogPointer, SetDialog); SetGetDlgLongInt(5, TheInteger2, DialogPointer, SetDialog); ModalDialog(nil, itemHit); DisposDialog(DialogPointer);end; function readByte:Byte;  var    ch:char;    GotChar:Boolean;    Count:integer;      begin     GotChar:=False;    Count:=0;    repeat      Count:=Count+1;      if InReady(SPortA) then        begin          GetChar(SPortA,ch);          if SerResult<>noErr then  {error on get char}            debugdialog(0,'GetChar error',0)          else            GotChar:=True;        end      else        if SerResult<>noErr then  {error on inready}          debugdialog(0,'inready error',0);    until GotChar or (Count>10);    if Count>10 then      debugdialog(0,'readbyte 10 error',0);    ReadByte := Ord(ch);  end; procedure ReadFrame(var Number:longint);   var    Found:Boolean;    Count:integer;    Byte1,Byte2,Byte3,Byte4:Byte;      begin    found:=False;    Count:=0;    repeat      begin        count:=Count+1;        Byte1:= readByte;        if BitAnd(Byte1,$C0) = $00 then          begin            Byte2:=readByte;            if BitAnd(Byte2,$C0) = $40 then              begin                Byte3:=readByte;                if BitAnd(Byte3,$C0) = $80 then                  begin                    Byte4:=readByte;                    if BitAnd(Byte4,$C0) = $C0 then                      begin                        Found:=True;                        Number:=ord4(BitAnd(Byte1,$3F))+ord4(BitAnd(Byte2,$3F))                          *64+ord4(BitAnd(Byte3,$3F))*4096+ord4(BitAnd(Byte4,$3F))*262144;                      end;                  end;              end;          end;      end;    until found or (Count=10);    if Count = 10 then      debugdialog(0,'readframe 10 error',0);  end; Procedure SendByte(TheByte:Byte);  var    ch:char;    SentChar:Boolean;    Count:integer;      begin     ch:=Chr(TheByte);    SentChar:=False;    Count:=0;    repeat      Count:=Count+1;      if OutReady(SPortA) then        begin          SendChar(SPortA,ch);          if SerResult<>noErr then  {error on send char}            debugdialog(0,'SendChar error',0)          else            SentChar:=True;        end      else        if SerResult<>noErr then  {error on Outready}          debugdialog(0,'outready error',0);    until SentChar or (Count>10);    if Count>10 then      debugdialog(0,'Sendbyte 10 error',0);  end; procedure SendFrame(Number:longint);   var    Count:integer;    Byte1,Byte2,Byte3,Byte4:Byte;      begin    Byte1:=BitAnd(Number,$00003F);    Byte2:=BitAnd(Number,$000FC0) div 64 + 64;    Byte3:=BitAnd(Number,$03F000) div 4096 + 128;    Byte4:=BitAnd(Number,$FC0000) div 262144 +192;    SendByte(Byte4);    SendByte(Byte3);    SendByte(Byte2);    SendByte(Byte1);  end; procedure SetupMemory;   begin  MoreMasters;  MoreMasters;  MoreMasters;  MoreMasters;  MaxApplZone; end; procedure SetUpPort; begin  if InitSPort(SPortA, baud9600, stop20, noParity, data8, 5000, none, none) <> noerr then    debugdialog(0,'initport error',0); end;procedure initthings; begin  FlushEvents(everyEvent, 0);  InitGraf(@thePort);  InitFonts;  InitWindows;  InitMenus;  TEInit;  InitDialogs(nil);  InitCursor;  InitAllPacks;  SetUpMemory;  setUpPort; end; procedure CloseThings; begin  CloseSPort(SPortA); end;begin  initThings;    for i:=1 to 10 do    begin     {number1:=tickcount;     SendFrame(number1);}          ReadFrame(Number2);          {if number1 = number2 then       DebugDialog(Number1,'the right number returned',Number2)     else       DebugDialog(Number1,'the wrong number returned',Number2);}            DebugDialog(Number2,'The Number Returned',0);    end;      CloseThings;end.