Program CollectorShell;   {$U Jim Surine:Programming:Units:Axis}   {$U Jim Surine:Programming:Units:Dialogs}        {Dialog handler}   {$U Jim Surine:Programming:Units:RecordInteger}   {$U Jim Surine:Programming:Units:RecordReal}   {$U Jim Surine:Programming:Units:Histogram}      {The Collector uses histograms}   {$U Jim Surine:Programming:Units:MultiFileSelect}   {$R Jim Surine:Programming:Collector:CollectorRsrc}   {$S+}     uses    Memtypes,           {Basic types stanadard}    QuickDraw,          {Quickdraw standard}    OSIntf,             {Operating system standard}    ToolIntf,           {Tools standard}      PackIntf,           {Package stuff (List Manager, Decimal to string convert)}    MacPrint,           {Printer driver}    sane,               {For Real number conversions}       Axis,    Dialogs,            {My Dialog Routines}    MultiFileSelect,    Histogram,    RecordInteger;{$S MyPart} const   PrintingID = 8093;        {info dialog used for non-spool printing}   FileCreator = 'NUMB';    Type   RecordIntegerPtr=^RecordIntegerType;   HistogramPtr=^HistogramType;      myHistogramInfoType=record              FirstNum:real;              SecondNum:Real;            end;   myRecordIntegerInfoType=record              FirstNum:real;              SecondNum:Real;            end;             var    PgSetUp : 								{Page setup info}   THPrint;   MyStRec : 								{print record}   TPrStatus;   PrinterPort : 				{graphic port for printing}   TPPrPort;   DoPrintSetUp :    {Flag for if you want to have standard printing dialog at beginning of print used for finder print}   Boolean;   TheHistogramInfoFile:SFReply;   TheRecordIntegerInfoFile:SFReply;   procedure DoPrintHistogram(var Histogram:HistogramType);   var    trueorFalse : boolean;    Reply : SFReply;    DialogPointer : DialogPtr;    CurrentPort:WindowPtr;        begin       trueORfalse := PrValidate(PgSetUp);        PrOpen;    if DoPrintSetup then      CancelButton := not PrJobDialog(PgSetup)    else      CancelButton := False;          if not CancelButton then      PrinterPort := PrOpenDoc(PgSetup, nil, nil);      if not CancelButton then      begin        PrOpenPage(PrinterPort, nil);                DialogPointer := GetNewDialog(PrintingID, nil, pointer(-1));        showWindow(DialogPointer);        drawdialog(DialogPointer);                 GetPort(CurrentPort);        CurrentPort^.PortRect.Top:=CurrentPort^.PortRect.Top+40;                DrawHistogram(Histogram);                        PrClosePage(PrinterPort);        PrCloseDoc(PrinterPort);                if PrError <> noErr then          OKDialog('There was a printing error');                  if (PgSetup^^.prJob.bjDocLoop=bSpoolLoop) and (PrError=noerr) then          PrPicFile(PgSetup, nil, nil, nil, myStRec)        else          OKDialog('There was a spooling printing error');                  PrClose;        DisposDialog(DialogPointer);      end    else      PrClose;  end; procedure GetTextReadFile (var reply : SFReply);     var      Thepoint : point;      FileTypeArray : SFTypeList;     begin    Thepoint.h := 50;    Thepoint.v := 50;      FileTypeArray[0] := 'TEXT';    SFGetFile(Thepoint, 'Text File to Open', nil, 1, FileTypeArray, nil, reply);    CancelButton := not Reply.Good;  end;procedure GetWriteFile (var reply : SFReply);     var      Thepoint : point;     begin    Thepoint.h := 50;    Thepoint.v := 50;    SFPutFile(Thepoint, 'Save Filename', Reply.Fname, nil, reply);    CancelButton := not Reply.Good;  end; procedure CheckResultError(ResultError:integer;            var error:Boolean);     var      TheError : str255;      TheString:StringHandle;        begin    if ResultError<>noerr then      begin        TheString:=GetString(10000-ResultError);        TheError:=TheString^^;        if TheError='' then          TheError:='Unknown error';        sysbeep(10);        OKDialog(TheError);        Error:=True;      end;  end; procedure ReadRecordIntegerText (Reply : SFReply;                var error:Boolean;                var TheRecordInteger:RecordIntegerType);    var      InFile:Text;      ResultError:integer;      DummyString:StringPtr;      OldVol:integer;      i:integer;      Dummy:str255;        begin    error:=False;         DummyString:=Nil;    ResultError:=GetVol(DummyString,OldVol);    CheckResulterror(ResultError,error);    if ResultError<>noerr then      OKDialog('Could not get current volume')    else      begin        DummyString:=Nil;        ResultError:=SetVol(DummyString,Reply.vRefNum);        CheckResulterror(ResultError,error);        if ResultError<>noerr then          OKDialog('Could not set to files volume')        else          begin            Reset(InFile,Reply.Fname);            CheckResulterror(IOResult,error);            if IOResult<>noerr then              OKDialog('Could not reset file')            else              begin                for i:=1 to 16 do                  Readln(InFile,Dummy);                                  LoadRecordIntegerAsText (TheRecordInteger,Reply,InFile);                                CheckResulterror(IOResult,error);                if IOResult<>noerr then                  OKDialog('Error during reading of data');              end;            Close(InFile);            CheckResulterror(IOResult,error);            if IOResult<>noerr then              OKDialog('Could not close file');          end;        DummyString:=Nil;        ResultError:=SetVol(DummyString,OldVol);        CheckResulterror(ResultError,error);        if ResultError<>noerr then          OKDialog('Could not Set volume back');      end;  end;  procedure WriteHistogramText (var Reply : SFReply;                  var error:Boolean;                  var Histogram:HistogramType);     var      OutFile:Text;      ResultError:integer;      DummyString:StringPtr;      OldVol:integer;      i:integer;        begin    error:=False;        DummyString:=Nil;    ResultError:=GetVol(DummyString,OldVol);    CheckResulterror(ResultError,error);    if ResultError<>noErr then      OKDialog('Could not get current volume')    else      begin        DummyString:=Nil;        ResultError:=SetVol(DummyString,Reply.vRefNum);        CheckResulterror(ResultError,error);        if ResultError<>noErr then          OKDialog('Could not set to correct volume')        else          begin            TextCreator:=FileCreator;            TextType:='TEXT';                        Rewrite(OutFile,Reply.Fname);  {Make sure there is a file}            CheckResulterror(IOResult,error);            if IOResult<>noErr then              OKDialog('Could not create dummy file')            else              begin                Close(OutFile);                CheckResulterror(IOResult,error);                if IOResult<>noErr then                  OKDialog('Could not close dummy file')                else                  begin                    ResultError:=FSDelete (Reply.Fname, Reply.vRefNum);                    CheckResulterror(ResultError,error);                    if ResultError<>noErr then                      OKDialog('Could not delete dummy file')                    else                      begin                        Rewrite(OutFile,Reply.Fname);                        CheckResulterror(IOResult,error);                        if IOResult<>noErr then                          OKDialog('Could not rewrite file')                        else                          begin                            {Dummy Header Stuff, first zero important, makes sure it's a histogram}                                                        for i:=1 to 10 do                              Writeln(OutFile,'0');                            Writeln(OutFile,'FALSE');                            Writeln(OutFile,'0');                                                        Writeln(OutFile,'20');                            Writeln(OutFile,'20');                            Writeln(OutFile,'200');                            Writeln(OutFile,'200');                            SaveHistogramAsText (Histogram,Reply,OutFile);                                                        CheckResulterror(IOResult,error);                            if IOResult<>noErr then                              OKDialog('error while writing data to disk');                          end;                        Close(OutFile);                        CheckResulterror(IOResult,error);                        if IOResult<>noErr then                          OKDialog('Could not close file');                      end;                  end;              end;          end;        DummyString:=Nil;        ResultError:=SetVol(DummyString,OldVol);        CheckResulterror(ResultError,error);        if ResultError<>noErr then          OKDIalog('Could not reset to application volume');      end;  end;  procedure WriteHistogramInfoFile (var Reply : SFReply;                  var error:Boolean;                  var TheHistogramInfo:myHistogramInfoType);     var      OutFile:Text;      ResultError:integer;      DummyString:StringPtr;      OldVol:integer;        begin    error:=False;        DummyString:=Nil;    ResultError:=GetVol(DummyString,OldVol);    CheckResulterror(ResultError,error);    if ResultError<>noErr then      OKDialog('Could not get current volume')    else      begin        DummyString:=Nil;        ResultError:=SetVol(DummyString,Reply.vRefNum);        CheckResulterror(ResultError,error);        if ResultError<>noErr then          OKDialog('Could not set to correct volume')        else          begin            TextCreator:=FileCreator;            TextType:='TEXT';                        Rewrite(OutFile,Reply.Fname);  {Make sure there is a file}            CheckResulterror(IOResult,error);            if IOResult<>noErr then              OKDialog('Could not create dummy file')            else              begin                Close(OutFile);                CheckResulterror(IOResult,error);                if IOResult<>noErr then                  OKDialog('Could not close dummy file')                else                  begin                    ResultError:=FSDelete (Reply.Fname, Reply.vRefNum);                    CheckResulterror(ResultError,error);                    if ResultError<>noErr then                      OKDialog('Could not delete dummy file')                    else                      begin                        Rewrite(OutFile,Reply.Fname);                        CheckResulterror(IOResult,error);                        if IOResult<>noErr then                          OKDialog('Could not rewrite file')                        else                          begin                                                            {Writeln(OutFile,TheInfo.FirstNum);}                            {Writeln(OutFile,TheInfo.SecondNum);}                                                        CheckResulterror(IOResult,error);                            if IOResult<>noErr then                              OKDialog('error while writing data to disk');                           end;                        Close(OutFile);                        CheckResulterror(IOResult,error);                        if IOResult<>noErr then                          OKDialog('Could not close file');                      end;                  end;              end;          end;        DummyString:=Nil;        ResultError:=SetVol(DummyString,OldVol);        CheckResulterror(ResultError,error);        if ResultError<>noErr then          OKDIalog('Could not reset to application volume');      end;  end;   procedure WriteRecordIntegerInfoFile (var Reply : SFReply;                  var error:Boolean;                  var TheRecordIntegerInfo:myRecordIntegerInfoType);     var      OutFile:Text;      ResultError:integer;      DummyString:StringPtr;      OldVol:integer;        begin    error:=False;        DummyString:=Nil;    ResultError:=GetVol(DummyString,OldVol);    CheckResulterror(ResultError,error);    if ResultError<>noErr then      OKDialog('Could not get current volume')    else      begin        DummyString:=Nil;        ResultError:=SetVol(DummyString,Reply.vRefNum);        CheckResulterror(ResultError,error);        if ResultError<>noErr then          OKDialog('Could not set to correct volume')        else          begin            TextCreator:=FileCreator;            TextType:='TEXT';                        Rewrite(OutFile,Reply.Fname);  {Make sure there is a file}            CheckResulterror(IOResult,error);            if IOResult<>noErr then              OKDialog('Could not create dummy file')            else              begin                Close(OutFile);                CheckResulterror(IOResult,error);                if IOResult<>noErr then                  OKDialog('Could not close dummy file')                else                  begin                    ResultError:=FSDelete (Reply.Fname, Reply.vRefNum);                    CheckResulterror(ResultError,error);                    if ResultError<>noErr then                      OKDialog('Could not delete dummy file')                    else                      begin                        Rewrite(OutFile,Reply.Fname);                        CheckResulterror(IOResult,error);                        if IOResult<>noErr then                          OKDialog('Could not rewrite file')                        else                          begin                                                        {Writeln(OutFile,TheRecordIntegerInfo.FirstNum:9:9);}                            {Writeln(OutFile,TheRecordIntegerInfo.SecondNum:9:9);}                                                        CheckResulterror(IOResult,error);                            if IOResult<>noErr then                              OKDialog('error while writing data to disk');                           end;                        Close(OutFile);                        CheckResulterror(IOResult,error);                        if IOResult<>noErr then                          OKDialog('Could not close file');                      end;                  end;              end;          end;        DummyString:=Nil;        ResultError:=SetVol(DummyString,OldVol);        CheckResulterror(ResultError,error);        if ResultError<>noErr then          OKDIalog('Could not reset to application volume');      end;  end;  procedure DoHistogramSaveAs(var Histogram:HistogramType);     var      Reply : SFReply;      error:Boolean;        begin    Reply.fname:='Untitled';    GetWriteFile(Reply);    if Reply.Good then      WriteHistogramtext(Reply,error,Histogram);  end;procedure DoRecordIntegerOpen(var TheRecordInteger:RecordIntegerType);     var      Reply : SfReply;      Error:Boolean;        begin    GetTextReadFile(Reply);    if Reply.good then      ReadRecordIntegerText(Reply,error,TheRecordInteger);  end;  Function Deramp(TheRecordInteger:RecordIntegerType;                  TheLoc,                  WhichOne:integer):Real;  var  A,B,C:real;   begin    case WhichOne of    0:      begin        a:=1056.652;        b:=135.636;        c:=15.922;      end;    1:      begin        a:=1069.67;        b:=152.433;        c:=58.437;      end;    2:      Begin        a:=1065.652;        b:=136.86;        c:=16.219;      end;  end;  Deramp:=B*(EXP((TheRecordInteger.RecordIntegerData[WhichOne+TheLoc*3]-C)/A)-1); end; Procedure ProcessHistogram(var TheHistogram:HistogramType;    var TheFile:SFReply);      var     TheHistogramInfo:MyHistogramInfoType;    TempFile:SFReply;    i:integer;    error:Boolean;      begin    for i:=1 to 30 do      writeln;    DrawHistogram(TheHistogram);    TempFile:=TheFile;    TempFile.Fname:=TempFile.Fname+'.Hst';    WriteHistogramtext(TempFile,error,TheHistogram);      DoPrintSetUp:=False;{Don't put up print dialog box just print it}    DoPrintHistogram(TheHistogram);        {Do Calc for Histograminfo}        TempFile:=TheFile;    TempFile.Fname:=TempFile.Fname+'.HstInfo';      WriteHistogramInfoFile(TheHistogramInfoFile,error,TheHistogramInfo);  end;  Procedure ProcessRecordInteger(var TheRecordInteger:RecordIntegerType;                      var TheFile:SFReply);var   TheHistogramPointer1,   TheHistogramPointer2,   TheHistogramPointer3,   TheHistogramPointer4,   TheHistogramPointer5:HistogramPtr;   Deramp1,Deramp2,Deramp3:real;   i,j:integer;   error:boolean;   TheHistogramInfo:myHistogramInfoType;   TheRecordIntegerInfo:myRecordIntegerInfoType;   TempFile:SFReply;   begin  writeln('number recorded ',TheRecordInteger.NumberRecorded);  for i:= 0 to 20 do    begin      for j:= 1 to 3 do        write(TheRecordInteger.RecordIntegerData[j+i*3],'   ');      writeln;    end;    TheHistogramPointer1:=HistogramPtr(NewPtr(SizeOf(HistogramType)));  TheHistogramPointer2:=HistogramPtr(NewPtr(SizeOf(HistogramType)));  TheHistogramPointer3:=HistogramPtr(NewPtr(SizeOf(HistogramType)));  TheHistogramPointer4:=HistogramPtr(NewPtr(SizeOf(HistogramType)));  TheHistogramPointer5:=HistogramPtr(NewPtr(SizeOf(HistogramType)));    with TheHistogramPointer1^.HistogramInfo do    begin      LowerDataBound :=0;      UpperDataBound :=4000;      LowerDataInclude := true;      UpperDataInclude := true;      NumberOfDataBins :=1000;      Title :='A histogram plot';      LowerDisplayBound:= 0;      UpperDisplayBound := 4000;      LowerDisplayInclude :=true;      UpperDisplayInclude :=true;      NumberOfDisplayBins :=1000;      LowerVerticleBound:=0; {zero both for auto scaling}      UpperVerticleBound:=0;       DrawOption:=0;    end;      InitHistogram (TheHistogramPointer1^ ,TheHistogramPointer1^.HistogramInfo);  InitHistogram (TheHistogramPointer2^ ,TheHistogramPointer1^.HistogramInfo);  InitHistogram (TheHistogramPointer3^ ,TheHistogramPointer1^.HistogramInfo);  with TheHistogramPointer4^.HistogramInfo do    begin      LowerDataBound :=-1;      UpperDataBound :=4;      LowerDataInclude := true;      UpperDataInclude := true;      NumberOfDataBins :=1000;      Title :='A histogram plot';      LowerDisplayBound:= -1;      UpperDisplayBound := 4;      LowerDisplayInclude :=true;      UpperDisplayInclude :=true;      NumberOfDisplayBins :=1000;      LowerVerticleBound:=0; {zero both for auto scaling}      UpperVerticleBound:=0;       DrawOption:=0;    end;  InitHistogram (TheHistogramPointer4^ ,TheHistogramPointer4^.HistogramInfo);  InitHistogram (TheHistogramPointer5^ ,TheHistogramPointer4^.HistogramInfo);  for i:= 1 to TheRecordInteger.NumberRecorded div 200 do    begin      Deramp1:=Deramp(TheRecordInteger,i,0);      Deramp2:=Deramp(TheRecordInteger,i,1);      Deramp3:=Deramp(TheRecordInteger,i,2);            AddToHistogram(TheHistogramPointer1^,Deramp1,1);      AddToHistogram(TheHistogramPointer2^,Deramp2,1);      AddToHistogram(TheHistogramPointer3^,Deramp3,1);            if Deramp2<>0 then        begin          AddToHistogram(TheHistogramPointer4^,Deramp1/Deramp2,1);          AddToHistogram(TheHistogramPointer5^,Deramp3/Deramp2,1);        end;    end;  TempFile:=TheFile;  TempFile.Fname:=TempFile.Fname+'.RecIntInfo';    WriteRecordIntegerInfoFile(TheRecordIntegerInfoFile,error,TheRecordIntegerInfo);  TempFile:=TheFile;  TempFile.Fname:=TempFile.Fname+'.1';        ProcessHistogram(TheHistogramPointer1^,TempFile);  TempFile:=TheFile;  TempFile.Fname:=TempFile.Fname+'.2';        ProcessHistogram(TheHistogramPointer2^,TempFile);    TempFile:=TheFile;  TempFile.Fname:=TempFile.Fname+'.3';        ProcessHistogram(TheHistogramPointer3^,TempFile);    TempFile:=TheFile;  TempFile.Fname:=TempFile.Fname+'.4';        ProcessHistogram(TheHistogramPointer4^,TempFile);  TempFile:=TheFile;  TempFile.Fname:=TempFile.Fname+'.5';        ProcessHistogram(TheHistogramPointer5^,TempFile);    DisposPtr(ptr(TheHistogramPointer1));  DisposPtr(ptr(TheHistogramPointer2));  DisposPtr(ptr(TheHistogramPointer3));  DisposPtr(ptr(TheHistogramPointer4));  DisposPtr(ptr(TheHistogramPointer5));end;procedure DoMultiRecordIntegerOpen;     var      Reply : SfReply;      Error:Boolean;      TheRecordIntegerPointer:RecordIntegerPtr;      mydirID : longint;      Cancel : boolean;      files : FileListHdl;      NumberOfFiles:integer;      i:integer;        begin    TheRecordIntegerPointer:=RecordIntegerPtr(NewPtr(SizeOf(RecordIntegerType)));    files := FileListHdl(newhandle(sizeof(FileListtype)));    getfolder(mydirid, Cancel);    if Not Cancel then      begin        getallinfolder(mydirid, files, NumberOfFiles);        for i:= 1 to NumberOfFiles do          begin            hLock(Handle(Files));            ReadRecordIntegerText (files^^[i],error,TheRecordIntegerPointer^);            if not error then              ProcessRecordInteger(TheRecordIntegerPointer^,files^^[i]);            HUnloCk(Handle(Files));          end;      end;    DisposHandle(Handle(files));    DisposPtr(ptr(TheRecordIntegerPointer));  end;procedure SetupPrinter;     var      TheHandle : Handle;     begin    prOpen;    ResrvMem(SizeOf(PgSetUp));    PgSetUp := THPrint(NewHandle(SizeOf(TPrint))); {make handle}    PrintDefault(PgSetUp); 	{initialize the fields}    TheHandle := Handle(PgSetUp);    HLock(TheHandle);  {Lock it for some reason??}    PrClose;    DoPrintSetup := True;  {Do Print setup when printing}    {mystrec}  end;  procedure InitThings;   begin    SetupPrinter;    penNormal;  end;  begin  InitThings;  doMultiRecordIntegerOpen;end.