Program Graphs;	{$R GraphsRsrc}										{Load my resources (dialog boxes etc..)}	{$B+}															     {Set bundle bit so finder will use my icon}	{$T APPLGRPH}										  {set my file type and creator} {$U-} 	{$R-}USES Memtypes,QuickDraw,OSIntf,ToolIntf,PackIntf,MacPrint,FileIo;const	OKbutton 		=1;	QuitButton 		=2;	OpenButton		=3;	ModePrint		=4;	ModePrev		=5;	Graph2d			=6;	Graph3d			=7;	OnlyDialog		=7764;type	{Jim Surine's Types}arr4=			array[1..4] of real;		{arrary of 4 reals}		ari4=			array[1..4] of integer;	{Arrary of 4 integers}		strtype=			string[10];							{string size to shrink record size} 		HeaderType=								{Header storage record definition} 			record 				Reply:SfReply;				{current File system reply from last load} 				NumParticle:Integer;	{counter holds number of particles in list} 				Beam:strtype; 				Date:strtype; 				Event:strtype; 				operator:strtype; 				Plate:strtype; 				part:strtype; 				Rangetostar:strtype; 				ShrinkFactZT:Real; 				ShrinkFactZM:Real; 				ShrinkFactAN:Real; 				Magnification:Real; 				ZZO:Real; 				X:arr4; 				y:arr4; 				z:arr4; 				slopexy:real;	 				slopezy:real; 				Primary:strtype; 				Frag:strtype; 				a:strtype; 				p:strtype; 				M:strtype; 				NB:ari4; 				G1:ari4; 				G2:ari4; 				G3:ari4; 				NH:ari4; 				energyQ:arr4;     FBlack:integer;     BBlack:integer;     NBlack:integer; 				FtoBBlack:real;     FGrey:integer;     BGrey:integer;     NGrey:integer; 				FtoBGrey:real;         NHtotal:integer;     energytotal:real; 			end;		ParticlePtr=							{pointers are used to access particles in list because list can hold}			^ParticleType;					{only 32K of data not much for particles 212 bytes long so only a pointer}															{to the data is saved in the list leaving about max 3000 particle}															 		ParticleType=							{Holds each particle information} 			record 				Number:strtype;				{Particle information} 				xsec:real; 				ysec:real; 				zsec:real; 				GrainCount:real; 				P:real; 				L:real;				beta:real;					{beta}				degrees:real;				{beta expressed in degrees}				azimuth:real;				{azimuth angle}				azidegree:real;			{azimuth angle expressed in degress}				pseudo:real;				{pseudoripidity}									{slope of children particles with respect to the primary}				deltax:real;						{the value calculated from the raw data}				deltay:real;						{the value calculated from the raw data}				deltaz:real;                         {the value calculated from the raw data}				bigx:real;				bigz:real;				deltar:real;				xstar:real;				ystar:real;				zstar:real;			end;		dataset		= array[1..300] of real;var 	pseudorap,phi					:dataset; 	header							:headertype; 	loop							:integer;	WRecord							:WindowRecord;	theWindow						:WindowPtr;	theDialog						:DialogPtr;	itemHit,itemNo,ItemType			:integer;	graf2d,graf3d,PrintIt			:boolean;	canceled						         :boolean;	drawRect,screenRect				:rect;  	item							          :Handle;  	box								          :Rect;	PgSetUp							         :THPrint;	PrinterPort						      :TPPrPort;	myStRec							         :TPrStatus;firstTime               :boolean;Message,count,q         :integer;theFile                 :Appfile;function Power10 (Expo : integer) : longint;		var			power : longint;			i : integer;		begin			power := 1;			if power <> 0 then				for i := 1 to expo do			power := Power * 10;			power10 := Power;		end;	procedure Real2String (var WholeNumber : Real;		var TheString : Str255;		DecAcc:Integer);		var			integerPart, decimalPart : str255;		begin			NumToString(trunc(abs(wholeNumber)), IntegerPart);			if wholeNumber<0 then				IntegerPart:=concat('-',IntegerPart);			NumToString(round(abs(wholeNumber - trunc(wholeNumber)) * power10(DecAcc)), decimalPart);			TheSTring := concat(IntegerPart, '.', copy('000000', 1, DecAcc - length(DecimalPart)), decimalPart);		end;Procedure InitStuff;	begin		InitGraf(@thePort);	{ we need QuickDraw}		MoreMasters;		MoreMasters;		MoreMasters;		MoreMasters;		MoreMasters;		MoreMasters;  		InitFonts;		{ we need Fonts		}  		InitWindows;	{ we need Windows	}  		InitMenus;		{ we need Menus		}  		TEInit;			{ we need Text Edit	}  		InitDialogs(nil);  		InitCursor;  {Get rid of that stupid watch}  		SetBufSize(64000);	end;	Procedure StartPrinter;	procedure InitPageSetup;		var  			dumPgSetup : TPrint;		begin  			PgSetUp := THPrint(NewHandle(SizeOf(dumPgSetup))); {make handle}  			PrintDefault(PgSetUp); 	{initialize the fields}  			HLock(Handle(PgSetUp));		end;	procedure PageSetup;		var  			trueORfalse : boolean;		begin  			trueORfalse := PrValidate(PgSetUp); { make sure handle is valid}  			trueORfalse := PrStlDialog(PgSetUp); { fill the record with the info}		end;	begin		PrOpen;		if firstTime then     begin		      InitPageSetup;        PageSetUp;        firstTime:=false;    end;		drawRect:=PgSetUp^^.prInfo.rPage;		canceled:= not PrJobDialog(PgSetup);		if not canceled then			begin			PrinterPort:=PrOpenDoc(PgSetup,nil,nil);			end;	end; {StartPrinter}Procedure StopPrinter;	begin		PrCloseDoc(PrinterPort);		PrPicFile(PgSetup,nil,nil,nil,myStRec);	end;Procedure MakeSomeWindow(title:str255;						rectangle:rect);  var  	somerefcon	:longint;  begin  	theWindow:=NewWindow(@WRecord,rectangle,title,true,noGrowDocProc,pointer(-1),false,somerefcon);  end;procedure ClickContinue;	const		contbox	=29464;		onlybutton =1;	var		ContDialog	:DialogPtr;		ItemSmashed	:integer;	begin		ContDialog:=GetNewDialog(contbox,nil,pointer(-1));		repeat			ModalDialog(nil,ItemSmashed);		until ItemSmashed = onlybutton;		CloseDialog(ContDialog);	end;	procedure GetReadFile(var reply:SFReply);			var			pt:point;			FileType:SFTypeList;			begin			pt.h:=80;			pt.v:=50;			FileType[0][1]:='D';			FileType[0][2]:='A';			FileType[0][3]:='T';			FileType[0][4]:='A';			SFGetFile(pt,'Enter File',nil,1,filetype,nil,reply);		end;	procedure ReadFile(Reply:SFReply);			var			f:filerec;			i:integer;			Particle:ParticleType;			theError:str255;			begin			FReset(f,reply.vRefNum,reply.fName);			if not reply.good then				begin					sysbeep(1);					GetErrorMessage(IOR,TheError);				end			else				begin					FGetM(f,@Header,SizeOf(Header));					Header.Reply:=Reply;     for i := 1 to Header.NumParticle do				    begin					       FGetM(f,@Particle,SizeOf(Particle));            Phi[i]:=Particle.azidegree;					       PseudoRap[i]:=particle.Pseudo;        end;				end;			FClose(f);		end;procedure buttonOnrOff(item2do:integer;turnedOn:boolean);	var		itemcntlhand:controlhandle;	begin		GetDItem(theDialog,item2do,itemType,item,box);		itemcntlhand:= controlhandle(item);		if turnedOn then			SetCtlValue(itemcntlhand,1)		else			SetCtlValue(itemcntlhand,0);	end;{---------------------------------------------------------------------------}procedure DrawGraph2d;    var     temp,theString :str255;	procedure DrawHistogram(title:str255;			axislabel	:str255;			nbins,nberpts	:integer;			data		:dataset;			histmin,histmax	:real;			where		:rect);	var		frequency		:array[1..300] of integer;		loop,goop			:integer;		theRect			:rect;		whichbin,maxfreq,mark	:integer;		yoffset,xoffset,width,height:integer;    title1,title2,temp:str255;    ts:integer;   	procedure printi (i:integer);		var    AString       : str255;		begin  			numtostring(i,astring);  			drawstring(astring);		end; (*print integer*)	begin		{convert "where" rect to offsets and dimensions}		height := trunc((where.bottom - 50 - where.top - 50)/3);		xoffset := where.left + 30;		yoffset := trunc(2*(where.bottom -where.top )/3-50);		width := where.right - xoffset - 40;		{clear array}		for loop := 1 to 300 do			frequency[loop]:=0;		{put in bins}		maxfreq:=0;		for loop:=1 to nberpts do			begin			whichbin := trunc((data[loop] - histmin) / (histmax - histmin) * nbins + 1);			if (whichbin>0) and (whichbin<121) then        begin        frequency[whichbin]:=frequency[whichbin]+1;			     if frequency[whichbin]>maxfreq then				        maxfreq:=frequency[whichbin];        end;			end;		{Draw the boxes}		for loop:=1 to nbins do			begin			with theRect do				begin				top:=yoffset-trunc((height/maxfreq)*frequency[loop]);				bottom:=yoffset;				left:=trunc((width/(nbins))*(loop-1))+ xoffset;				right := trunc((width / (nbins)) * (loop)+1) + xoffset;				end;			FrameRect(theRect);			for mark:=1 to frequency[loop]-1 do				begin				moveto(theRect.left,yoffset-trunc(height/Maxfreq*mark));				lineto(theRect.right-1,yoffset-trunc(height/Maxfreq*mark));				end;			end;		{draw axes}		moveto(xoffset, yoffset);  		lineto(width + xoffset, 0 + yoffset);  		moveto(0 + xoffset, 0 + yoffset);  		lineto(0 + xoffset, -height + yoffset);		{Label axes}		textfont(geneva);    if theRect.right>600 then textsize(18)    else textsize(9);		for loop:= 1 to 13 do			begin    goop:=loop-3;			moveto(trunc(width/(histmax-histmin)*(goop-histmin))+ xoffset,yoffset);			lineto(trunc(width/(histmax-histmin)*(goop-histmin))+ xoffset,yoffset+8);			moveto(trunc(width/(histmax-histmin)*(goop-histmin))+ xoffset+2,yoffset+25);			printi(goop);			end;		for loop:=1 to maxfreq do			begin			moveto(xoffset,yoffset-trunc(height/Maxfreq*loop));			lineto(xoffset-10,yoffset-trunc(height/Maxfreq*loop));    if not odd(maxfreq) then        begin        if (not odd(loop)) or (maxfreq<5) then         begin            if loop<10 then moveto(xoffset-22,yoffset-trunc(height/Maxfreq*loop)+10)			         else moveto(xoffset-35,yoffset-trunc(height/Maxfreq*loop)+10);             printi(loop);         end;        end    else         begin        if (odd(loop)) or (maxfreq<5) then         begin		          	moveto(xoffset-20,yoffset-trunc(height/Maxfreq*loop)+10);			          printi(loop);         end;        end;			end;		{Title and Description}    if theRect.right>600 then ts:=24    else ts:=12;  textsize(ts);		textface([bold]);    title1:='Beam: '+Header.Beam+'          Date: '+Header.Date;    title1:=title1+'           Plate: '+Header.Plate+' Part: '+Header.Part;		moveto(trunc(width/2-StringWidth(title1)/2),yoffset-height-6*ts);    drawstring(title1);    title2:='Operator: '+Header.operator+'          F to B Black ';      NumTostring(Header.FBlack,temp);      title2:=title2+temp+'/';      numToString(Header.BBLack,Temp);      title2:=title2+temp+'          F to B Grey ';      numToString(Header.FGrey,Temp);      title2:=title2+temp+'/';      numToString(Header.BGrey,Temp);      title2:=title2+temp;		moveto(trunc(width/2-StringWidth(title2)/2),yoffset-height-4*ts);    drawstring(title2);		moveto(trunc(width/2-StringWidth(title)/2),yoffset-height-ts);  drawstring(title);		moveto(trunc(xoffset+width/2-StringWidth(axislabel)/2),yoffset+60);		textface([]);		drawstring(axislabel);		textfont(systemFont);    textsize(12);	end;	begin {DrawGraph2D}		if not PrintIt then			makesomewindow('Pseudorapidity Histogram',screenRect);    if PrintIt then	   		PrOpenPage(PrinterPort,nil);    TheString:=Header.Primary+' ->'+' ';    if Header.a<>''then theString:=theString+Header.a+'a + ';    theString:=theString+Header.p+'p + '+Header.m+'M + ';    NumtoSTring(Header.NBlack,Temp);    TheString:=TheString+Temp+'NB + ';    NumtoSTring(Header.NGrey,Temp);    TheString:=TheString+Temp+'NG ';    Real2String(Header.EnergyTotal,Temp,2);    TheString:=TheString+'    '+Temp+'MeV'; 		DrawHistogram(theString,'Pseudorapidity',120,Header.NumParticle,pseudorap, -2, 10,drawRect);		if not PrintIt then			begin				ClickContinue;				closeWindow(theWindow);			end		else PrClosePage(PrinterPort);	end;{---------------------------------------------------------------------------}Procedure DrawGraph3D;		const			costheta = 0.2588190451;			sintheta = 0.9659258263;	var		scalefactor,zscale	:real;		xoffset,yoffset		 :integer;		mindim				        :integer;  thestring,temp    :str255;  frequency         :array[1..120,1..90] of integer;  	procedure printi(i:integer);		var			AString:str255;		begin			numtostring(i,astring);			drawstring(astring);		end;(*printinteger*)	procedure Moveto3D(x,y,z:real);		var			x2d,y2d:integer;		begin    z:=-z;			x2d:=trunc((x+y*costheta+xoffset)*scalefactor);			y2d:=trunc((z+y*sintheta+yoffset)*scalefactor);			moveto(x2d,y2d);		end;	procedure LineTo3D(x,y,z:real);		var			x2d,y2d:integer;		begin    z:=-z;			x2d:=trunc((x+y*costheta+xoffset)*scalefactor);			y2d:=trunc((z+y*sintheta+yoffset)*scalefactor);			Lineto(x2d,y2d);		end;	procedure DrawAxes;		var			 i,j:integer;    title1,title2:str255;		begin			textfont(geneva);    textface([bold]);    if mindim>600 then textsize(24)    else textsize(12);    with drawRect do        begin        title1:='Beam: '+Header.Beam+'      Plate: '+Header.Plate+'    Part: '+Header.Part;        moveto(trunc((left+right)/2-StringWidth(title1)/2),top+40);        if PrintIt then drawstring(title1);				    TheString:=Header.Primary+' ->'+' '+Header.a+'a + '+' '+Header.p+'p + '+Header.m+'M + ';        NumtoSTring(Header.NBlack,Temp);        TheString:=TheString+Temp+'NB + ';        NumtoSTring(Header.NGrey,Temp);        TheString:=TheString+Temp+'NG ';        Real2String(Header.EnergyTotal,Temp,2);        TheString:=TheString+'     '+Temp+'MeV';        title2:=theString;        moveto(trunc((left+right)/2-StringWidth(title2)/2),top+80);			     if PrintIt then drawstring(title2);        end;    textface([]);			 moveto3d(450,1000,-100);		  drawstring('Pseudorapidity');			 moveto3d(1200,trunc(5*1000/9)-40,0);			 drawstring('Phi');    if mindim>600 then textsize(18)    else textsize(9);			 for i:=-1 to 11 do				    begin		          MoveTo3D(i*100,1015,-20);					       printi(i-1);					       MoveTo3D(i*100,0,0);					       LineTo3D(i*100,1000,0);					       penpat(gray);					       if i<>11then						          begin						              for j:=1 to 4 do							                 begin							                 MoveTo3D(i*100+j*20,0,0);							                 lineTo3D(i*100+j*20,1000,0);							                 end;						          end;					       penpat(black);        end;    for i:=0 to 9 do        begin					       MoveTo3D(-100,trunc(i*1000/9),0);					       LineTo3D(1100,trunc(i*1000/9),0);					       penpat(ltgray);					       if i<>9 then						          begin						              for j:=1 to 4 do		                      begin							                 MoveTo3D(-100,trunc((5*i+j)*200/9),0);							                 lineTo3D(1100,trunc((5*i+j)*200/9),0);							                 end;						          end;					       penpat(black);					       MoveTo3D(1120,trunc(i*1000/9),0);					       if odd(i) then printi(i*40);				    end;    textfont(systemFont);    textsize(12);		end;{DrawAxes}Procedure BinData;    var        xbin,ybin   :integer;        i,j         :integer;            begin        for i:=1 to 120 do            for j:=1 to 90 do                frequency[i,j]:=0;        for i:=1 to Header.NumParticle do            if (pseudorap[i]<10) and (pseudorap[i]>=-2) and (phi[i]>=0) and (phi[i]<=360) then                begin                    xbin:=trunc(10*(pseudorap[i]+2));                    ybin:=trunc(0.25*(phi[i]));                    if ybin=0 then ybin:=1;                    frequency[xbin,ybin]:=frequency[xbin,ybin]+1;                end;    end;    Procedure DrawBoxes;    const        x3 = 0.033;        x4 = 0.066;        x1 = 0.033;        x2 = 0.066;        y3 = 1.33;        y4 = 1.33;        y1 = 2.66;        y2 = 2.66;    var        xbin,ybin   :integer;        x,y,z         :real;        MyPoly      :PolyHandle;            procedure mvspace(x,y,z:real);{convert to the coordinates shown on the graph}        begin            moveto3d((x+1)*100,y/360*1000,z);        end;            procedure linespace(x,y,z:real);        begin            lineto3d((x+1)*100,y/360*1000,z);        end;            begin        for ybin:= 1 to 90 do            for xbin:= 1 to 120 do                if frequency[xbin,ybin]>0 then                     begin                        x:=xbin/10-2;                        y:=4*ybin;                        z:=20*frequency[xbin,ybin];                        MyPoly:=OpenPoly;                        mvspace(x+x3,y+y3,z);                        linespace(x+x3,y+y3,0);                        linespace(x+x1,y+y1,0);                        linespace(x+x2,y+y2,0);                        linespace(x+x2,y+y2,z);                        linespace(x+x4,y+y4,z);                        linespace(x+x3,y+y3,z);                        ClosePoly;                        FillPoly(myPoly,white);                        KillPoly(myPoly);                        linespace(x+x3,y+y3,0);                        linespace(x+x1,y+y1,0);                        linespace(x+x2,y+y2,0);                        linespace(x+x2,y+y2,z);                        linespace(x+x4,y+y4,z);                        linespace(x+x3,y+y3,z);                        linespace(x+x1,y+y1,z);                        linespace(x+x2,y+y2,z);                        mvspace(x+x1,y+y1,z);                        linespace(x+x1,y+y1,0);                        end;    end;    	begin{DrawGraph3D}		with drawRect do			begin				mindim:=right-left;				if (bottom-top) > (right-left) then mindim:=bottom-top;			end;		scalefactor:=mindim/1500-0.08;		xoffset:=200;		yoffset:=trunc(-0.05*mindim+220);		zscale:=4*mindim/1500;		if not PrintIt then			makesomewindow('3-D Histogram',screenRect);    if PrintIt then	   		PrOpenPage(PrinterPort,nil);  DrawAxes;  BinData;  DrawBoxes;		if not PrintIt then			begin				ClickContinue;				closeWindow(theWindow);			end		else PrClosePage(PrinterPort);	end;{----------------------------- Main Program -------------------------------}begin	InitStuff;	with screenRect do  		begin  			top:=40;  			left:=5;  			bottom:=370;  			right:=505;  		end;  firstTime:=true;{------------------------------}        CountAppFiles(Message,Count);     {Get finder info and load file if file}    if Message = 0 then     if Count>0 then        begin                for q := 1 to count do                    begin                        GetAppFiles(q,TheFile);                        Header.Reply.vRefNum:=TheFile.vRefNum;                        Header.Reply.fType:=TheFile.Ftype;                        Header.Reply.version:=TheFile.VersNum;                        Header.Reply.FName:=TheFile.Fname;                        header.reply.good:=true;                        ReadFile(Header.Reply);						                  canceled:=false;                        PrintIt:=true;						                  if q=1 then startPrinter;						                  if not canceled then							                     begin									                       drawgraph2d;									                       drawgraph3d;							                     end;                        ClrAppFiles(q);                    end;								            stopPrinter;        end;                      {----------------------------------}      	GetReadFile(header.Reply);	ReadFile(header.reply);	theDialog:=GetNewDialog(OnlyDialog,nil,pointer(-1));	GetDItem(theDialog,8,itemType,item,box);	SetIText(item,header.reply.fname);	{Set Defaults}	buttonOnrOff(ModePrint,true);	PrintIt:=true;	buttonOnrOff(Graph2d,true);	graf2d:=true;	buttonOnrOff(Graph3d,true);	graf3d:=true;	repeat		begin			ModalDialog(nil,itemHit);			case itemHit of				ModePrint:					begin						buttonOnrOff(ModePrint,true);						buttonOnrOff(ModePrev,false);						PrintIt:=true;					end;				ModePrev:					begin						buttonOnrOff(ModePrev,true);						buttonOnrOff(ModePrint,false);						PrintIt:=false;						drawRect:=screenRect;					end;				Graph2D:					begin						graf2D:= not(graf2d);						buttonOnrOff(Graph2d,graf2d);					end;				Graph3D:					begin						graf3D:= not(graf3d);						buttonOnrOff(Graph3d,graf3d);					end;				OKbutton:					begin						canceled:=false;						if PrintIt then startPrinter;						if not canceled then							begin								if graf2d then									drawgraph2d;								if graf3d then									drawgraph3d;								if PrintIt then stopPrinter;							end;					end;				Openbutton:					begin						GetReadFile(header.Reply);						ReadFile(Header.Reply);						GetDItem(theDialog,8,itemType,item,box);						SetIText(item,Header.Reply.fname);					end;			end;		end;	until itemHit=QuitButton;end.