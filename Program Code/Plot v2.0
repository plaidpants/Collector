program Plot;{$U Jim Surine:Programming:Units:My Units:Axis}{$O Jim Surine:Programming:Programs:Plots:Plot v1.0}uses Memtypes,            {Basic types stanadard} QuickDraw,           {Quickdraw standard} OSIntf,              {Operating system standard} ToolIntf,            {Tools standard}  PackIntf,           {Package stuff (List Manager, Decimal to string convert)} sane, Axis;  const  errwidth=2;  type  dataarray=array[1..50] of real;var  xoffset,yoffset,xscale,yscale:real;      voltage,bin,sigma:dataarray;  input:text;  i:integer;  myrect:rect;  Temp2Rect:Rect;  Temp1Rect:RealRect;  Xmax,Ymax,Xmin,Ymin:Real;  TempPort:WindowPtr;  Temp:integer;  procedure scalegraph(var xdata,ydata:dataarray; numpoints:integer);  var    i:integer;      begin  Xmax:=xdata[1];  Xmin:=xdata[1];  for i:=2 to numpoints do    begin    if xdata[i]>Xmax then      Xmax:=xdata[i];    if xdata[i]<Xmin then      Xmin:=xdata[i];    end;  Ymax:=ydata[1];  Ymin:=ydata[1];  for i:=2 to numpoints do    begin    if ydata[i]>Ymax then      Ymax:=ydata[i];    if ydata[i]<Ymin then      Ymin:=ydata[i];    end;  end;  procedure scalegraph2(axis:rect);  var    i:integer;  begin  xoffset:=Xmin;  xscale:=(axis.right-axis.left)/(Xmax-Xmin);  yoffset:=Ymax;  yscale:=(axis.bottom-axis.top)/(Ymax-Ymin);  end;  procedure drawpoints(var xdata,ydata:dataarray; numpoints:integer;axis:rect);  var     i:integer;    x,y:integer;  begin  for i:= 1 to numpoints do    begin    x:=axis.left+trunc(xscale*(xdata[i]-xoffset));    y:=axis.top-trunc(yscale*(ydata[i]-yoffset));    moveto(x,y);    lineto(x,y);    {writeln(x,y);}    end;  end;procedure drawlines(var xdata,ydata:dataarray; numpoints:integer;axis:rect);  var     i:integer;    x,y:integer;  begin  x:=axis.left+trunc(xscale*(xdata[1]-xoffset));  y:=axis.top-trunc(yscale*(ydata[1]-yoffset));  moveto(x,y);  for i:= 1 to numpoints do    begin    x:=axis.left+trunc(xscale*(xdata[i]-xoffset));    y:=axis.top-trunc(yscale*(ydata[i]-yoffset));    lineto(x,y);    end;  end;  procedure drawcircles(var xdata,ydata:dataarray; numpoints:integer;        axis:rect;radius:integer; fillthem:boolean);  var     i:integer;    x,y:integer;    circlerect:rect;  begin  for i:= 1 to numpoints do    begin    x:=axis.left+trunc(xscale*(xdata[i]-xoffset));    y:=axis.top-trunc(yscale*(ydata[i]-yoffset));    circlerect.top:=y-radius;    circlerect.bottom:=y+radius+1;    circlerect.left:=x-radius;    circlerect.right:=x+radius+1;    if fillthem then      paintoval(circlerect)    else      frameoval(circlerect);    end;  end;        procedure drawsquares(var xdata,ydata:dataarray; numpoints:integer;        axis:rect;radius:integer; fillthem:boolean);  var     i:integer;    x,y:integer;    circlerect:rect;  begin  for i:= 1 to numpoints do    begin    x:=axis.left+trunc(xscale*(xdata[i]-xoffset));    y:=axis.top-trunc(yscale*(ydata[i]-yoffset));    circlerect.top:=y-radius;    circlerect.bottom:=y+radius+1;    circlerect.left:=x-radius;    circlerect.right:=x+radius+1;    if fillthem then      paintrect(circlerect)    else      framerect(circlerect);    end;  end;  procedure drawerrors(var xdata,ydata,ysigma:dataarray; numpoints:integer;        axis:rect);  var     i:integer;    x,yhi,ylo:integer;    circlerect:rect;  begin  for i:= 1 to numpoints do    begin    x:=axis.left+trunc(xscale*(xdata[i]-xoffset));    yhi:=axis.top-trunc(yscale*(ydata[i]+ysigma[i]-yoffset));    ylo:=axis.top-trunc(yscale*(ydata[i]-ysigma[i]-yoffset));    moveto(x-errwidth,yhi);    lineto(x+errwidth,yhi);    moveto(x,yhi);    lineto(x,ylo);    moveto(x-errwidth,ylo);    lineto(x+errwidth,ylo);    end;  end;  {------------------main program---------------}beginreset(input,'Jim Surine:Programming:Codes:Unit Code:bobs data');i:=0;while not eof(input) do  begin  i:=i+1;  readln(input,voltage[i],bin[i]);  voltage[i]:=voltage[i]/1;  bin[i]:=bin[i]/1;  sigma[i]:=voltage[i]*0.1;  end;close(input);scalegraph(bin,voltage,i);temp:=round(power(10,trunc(log(XMax))));XMax:=trunc(Xmax/(temp)+1)*temp;{XMax:=1;}Temp1Rect.upperX:=XMax;{temp:=round(power(10,trunc(log(XMin))));XMin:=trunc(XMin/(temp)-1)*temp;}XMin:=0;Temp1Rect.lowerX:=XMin;writeln(Ymax);YMax:=1;temp:=round(power(10,trunc(log(Ymax))));Ymax:=trunc(Ymax/(temp)+1)*temp; {Ymax:=1;}Temp1Rect.UpperY:=YMax; {temp:=round(power(10,trunc(log(YMin))));YMin:=trunc(YMin/(temp)-1)*temp;}Ymin:=0;Temp1Rect.LowerY:=YMin;getPort(TempPort);Temp2Rect:=TempPort^.PortRect;      DrawAxis(Temp1Rect,Temp2Rect);scalegraph2(Temp2Rect);drawcircles(bin,voltage,i,Temp2Rect,2,false);drawerrors(bin,voltage,sigma,i,Temp2Rect);{drawsquares(bin,voltage,i,Temp2Rect,5,false);}drawlines(bin,voltage,i,Temp2Rect);repeat until keypressed;end.