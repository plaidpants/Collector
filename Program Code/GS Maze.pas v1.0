    Program Maze;	  {$B+}  	{Set bundle bit so finder will use my icon}	  {$T APPLGSMZ} 	 {set my file type and creator}  	{$S+}  	{Use Segments because program is larger than 32K}   {$I-}   {Set Folder to write output application}   {$O Jim Surine:Programming:Programs:GS Maze v1.0}     uses    Memtypes,           {Basic types stanadard}    QuickDraw,          {Quickdraw standard}    OSIntf,             {Operating system standard}    ToolIntf,           {Tools standard}      PackIntf,           {Package stuff (List Manager, Decimal to string convert)}    sane;               {For Real number conversions}	CONST		MaxX=320;		MaxY=200;			AppleMenu=300;		AboutItem=301;			FileMenu=400;		NewItem=401;		OpenItem=402;		CloseItem=403;		SaveItem=404;		SaveAsItem=405;		RevertItem=406;		QuitItem=401;			EditMenu=500;		UndoItem=501;		CutItem=503;		CopyItem=504;		PasteItem=505;		ClearItem=506;		MoveMenu=600;		XPlusItem=601;		YPlusItem=602;		ZPlusItem=603;		DPlusItem=604;		XMinusItem=605;		YMinusItem=606;		ZMinusItem=607;		DMinusItem=608;			MaxDrawDepth = 2;		MaxDrawWidth = 2;			XMaxMazeSize=10;		YMaxMazeSize=10;		ZMaxMazeSize=9;	Type		MazeSideDrawingOrderType=			Record				NumberOfSideDrawingOrders:Byte;				SideDrawingOrders:Packed array [0..0,0..0] of					Record						NumberOfSides:byte;						Sides:Packed array [0..5,0..255] of 							record								Maze,								Draw:											record										X,										Y,										Z,										Side,										Brightness:Signedbyte;									end;							end;					end;			end;		MazeShapeType=			Packed Record				NumberOfShapes:byte;				Shapes:Packed Array[-MaxDrawWidth..MaxDrawWidth,-MaxDrawWidth..MaxDrawWidth,0..MaxDrawDepth,0..255,0..3] of					Packed record				 		ShapeRegion:RgnHandle;						ShapePolygon:PolyHandle;					end;			end;				MazeShapeDefinitionType=			Packed Record				NumberOfShapeDefinitions:byte;				ShapeDefinitions:Packed Array [0..255] of					Packed record						NumberOfShapePoints:byte;						ShapePoints:Packed Array [0..255] of 							Record								ShapeX,								ShapeY:byte;							end;					end;			end;				MazePictureType=			Packed Record				NumberOfPictures:integer;				Pictures:Array[0..10] of					Packed record						NumberOfShapes:byte;						Shapes:Packed Array[0..3] of							Packed record								ShapeNumber,								ShapePattern,								ShapeType:byte;							end;					end;			end;				MazeType=			record				XMazeSize,				YMazeSize,				ZMazeSize:integer;				Maze:packed array [0..XMaxMazeSize,0..YMaxMazeSize,0..ZMaxMazeSize] of					record						MazeDrawOrderNumber:integer;						MazeBrightness:integer;						MazePicture: array [0..3] of integer;					end;			end;				MazePatternsType=			array [0..255,0..255] of integer;				PatternsType=			array [0..255] of Pattern;				VAR			Quitting,		Finished:Boolean;				ThePatterns:PatternsType;				TheMazeShapeDefinitions:MazeShapeDefinitionType;		TheMazeRect:Rect;		TheMazeShapes:MazeShapeType;		TheMazePatterns:MazePatternsType;		TheMazePicture:MazePictureType;		TheMazeSideDrawingOrder:MazeSideDrawingOrderType;		TheMaze:MazeType;		TheMazeWindowPointer:WindowPtr;		XMaze,YMaze,ZMaze,DMaze,BMaze,OutsideBrightnessMaze:byte;  procedure SetUpCursors;     var      WatchHandle : CursHandle;     begin    WatchHandle := GetCursor(WatchCursor);    Watch := WatchHandle^^;  end;   procedure SetupMemory;     var        i:integer;          begin    for i:=1 to 20 do        MoreMasters;    MaxApplZone;  end; 	var		AppleMenuStr,		FileMenuStr,		EditMenuStr,		MoveMenuStr:str255;		MenuHeight:integer;	Procedure SetUpMenus;				begin			AppleMenuStr:=ConCat(	'>>@\XN300\0',														'==About Maze...\N301\0',														'==-\N302D\0..');			FileMenuStr:=ConCat(	'>>  File  \N400\0',														'==Quit\N401*Qq\0.');			EditMenuStr:=ConCat(	'>>  Edit  \N500\0',														'==Undo\N501*ZzV\0',														'==-\N502D\0',														'==Cut\N503*Xx\0',														'==Copy\N504*Cc\0',														'==Paste\N505*Vv\0',														'==Clear\N506\0.');			MoveMenuStr:=ConCat(	'>>  Move  \N600\0',														'==X Plus\N601\0',														'==Y Plus\N602\0',														'==Z Plus\N603\0',														'==D Plus\N604\0',														'==X Minus\N605\0',														'==Y Minus\N606\0',														'==Z Minus\N607\0',														'==D Minus\N608\0.');			SetMTitleStart(10);						InsertMenu(NewMenu(@MoveMenuStr[1]),0);			InsertMenu(NewMenu(@EditMenuStr[1]),0);			InsertMenu(NewMenu(@FileMenuStr[1]),0);			InsertMenu(NewMenu(@AppleMenuStr[1]),0);					FixAppleMenu(AppleMenu);			MenuHeight:=FixMenuBar;			DrawMenuBar;		end;   procedure SetupLimits;		{ set up the dragging and growing rects}     var      Screen : Rect;     begin    Screen := ScreenBits.bounds;    with Screen do      begin        ScreenHeight := bottom - top;        ScreenWidth := Right - Left;        SetRect(DragArea, left + 4, top + 24, right - 4, bottom - 4);        SetRect(GrowArea, left, top + 24, right, bottom);        GrowArea.left := 150;        GrowArea.top := 100;        DoubleArea := 4;      end;  end;  procedure InitThings;   begin    SetUpMemory;    FlushEvents(everyEvent, 0);      InitGraf(@thePort);    InitFonts;    InitWindows;    InitMenus;    TEInit;    InitDialogs(nil);    InitCursor;    InitAllPacks;      Finished := False;    Quitting := False;      SetUpLimits;    SetUpMenus;    SetUpcursors;  end;   procedure CloseThings;   begin    {Maze doesn't open anything}  end;  	Procedure WindowContent;					var			i,			MazeDrawOrderBrightness,MazeDrawOrder,			MazeX,MazeY,MazeZ,MazeSide,MazeBrightNess,			DrawX,DrawY,DrawZ,DrawSide,DrawPicture,DrawBrightness:integer;			TheMazeRegion,			OldRegionHandle:RgnHandle;					begin			SetPort(TheMazeWindowPointer);					OldRegionHandle:=GetClipHandle;						TheMazeRegion:=NewRgn;			RectRgn(TheMazeRegion,TheMazeRect);   		SetClipHandle(TheMazeRegion);   					SetPenPat(ThePatterns[0]);			PaintRect(TheMazeRect);						with TheMaze.Maze[Xmaze,YMaze,ZMaze] do				begin					MazeDrawOrderBrightness:=BitAnd(MazeBrightness,$7F);					if BitAnd(MazeBrightness,$80) = $80 then						MazeDrawOrderBrightness:=MazeDrawOrderBrightness+OutsideBrightnessMaze;											MazeDrawOrder:=MazeDrawOrderNumber;				end;				   		for i := 0 to TheMazeSideDrawingOrder.SideDrawingOrders[MazeDrawOrder,MazeDrawOrderBrightness].NumberOfSides do   			begin   				With TheMazeSideDrawingOrder.SideDrawingOrders[MazeDrawOrder,MazeDrawOrderBrightness].Sides[DMaze,i] do   					begin   						DrawX:=Draw.X;   						DrawY:=Draw.Y;   						DrawZ:=Draw.Z;   						DrawSide:=Draw.Side;   						    					MazeX:=Maze.X+XMaze;   						MazeY:=Maze.Y+YMaze;   						MazeZ:=Maze.Z+ZMaze;   	  				MazeSide:=Maze.Side;   	  				MazeBrightness:=Maze.Brightness;						end;   				with TheMaze.Maze[MazeX,MazeY,MazeZ] do   					begin   						DrawPicture:=MazePicture[MazeSide];  						DrawBrightness:=BitAnd(MazeBrightness,$7F)+MazeBrightness;							if BitAnd(MazeBrightness,$80) = $80 then								DrawBrightness:=DrawBrightness+OutsideBrightnessMaze;   					end;   					   				for i:= 0 to TheMazePicture.Pictures[DrawPicture].NumberOfShapes do   					begin   						SetPenPat(ThePatterns[TheMazePatterns[TheMazePicture.Pictures[DrawPicture].Shapes[i].ShapePattern,DrawBrightness]]);							case TheMazePicture.Pictures[DrawPicture].Shapes[i].ShapeType of								0:									PaintRgn(TheMazeShapes.Shapes[DrawX,DrawY,DrawZ,DrawSide,TheMazePicture.Pictures[DrawPicture].Shapes[i].ShapeNumber].ShapeRegion);								1:									FramePoly(TheMazeShapes.Shapes[DrawX,DrawY,DrawZ,DrawSide,TheMazePicture.Pictures[DrawPicture].Shapes[i].ShapeNumber].ShapePolygon);								2:									DiffRgn(TheMazeRegion,TheMazeShapes.Shapes[DrawX,DrawY,DrawZ,DrawSide,TheMazePicture.Pictures[DrawPicture].Shapes[i].ShapeNumber].ShapeRegion,TheMazeRegion);							end;						end;  			end;  						SetClipHandle(OldRegionHandle);			DisposeRgn(TheMazeRegion);		end;		var		myWindTitle:str255;			Procedure SetUpWindow;		var			myWind:newWindowParamBlk;				begin			myWindTitle:='Maze';						With MyWind do				begin					param_length:=Sizeof(NewWindowParamBlk);					Wframe:=$DDA0;					WTitle:=@myWindTitle;					wRefCon:=0;					wZoom.top:=13+13;					wZoom.Left:=1;					wZoom.Bottom:=200-13;					wZoom.right:=320-17;					wColor:=nil;					wYOrigin:=0;					wXOrigin:=0;					wDataH:=200;					wDataW:=320;					wMaxH:=200;					wMaxW:=320;					wScrollver:=40;					wScrollHor:=16;					wPageVer:=40;					wPageHor:=160;					wInfoRefCon:=0;					wInfoHeight:=0;					wFrameDefProc:=nil;					wInfoDefProc:=nil;					wContDefProc:=@WindowContent;					wPosition:=wZoom;					wPlane:=-1;					wStorage:=nil;				end;			TheMazeWindowPointer:=NewWindow(myWind);		end;		procedure SetUpColors;		var				i,j:integer;			Colors: ColorTable;			ThePattern:Pattern;  		ColorTextFile:Text;  		NumberOfPatterns,  		NumberOfMazePatterns:integer;  				begin			Reset(ColorTextFile,'THECOLORS');			for i := 0 to 15 do				readln(ColorTextFile,Colors[i]);			SetColorTable(0, Colors);						Readln(ColorTextFile,NumberOfPatterns);			for	i := 0 to NumberOfPatterns do    		begin    			for j:= 0 to 7 do    				Readln(ColorTextFile,ThePattern[j*2],ThePattern[j*2+1]);					ThePatterns[i]:=ThePattern;  	  	end;  	  	  	  Readln(ColorTextFile,NumberOfMazePatterns);			for	i := 0 to NumberOfMazePatterns do    		for j:= 0 to 127 do    			Readln(ColorTextFile,TheMazePatterns[i,j]);  	  Close(ColorTextFile);		end;		const		Xmost=301;		Ymost=151;		XLeast=0;		YLeast=0;	function ThreeD(X,Y,Z:integer):point;		begin			ThreeD.h:=trunc(((XMost/(Z/14+1)*X)+XLeast)/14+Xmost div 2);			ThreeD.v:=-trunc(((YMost/(Z/14+1)*Y)+YLeast)/14-Ymost div 2);		end;			procedure MakeSide(x,y,z,side:integer);			var			XX,YY,ZZ:integer;			ThePoint:point;			SidePoly:PolyHandle;					begin			SidePoly:=OpenPoly;			XX:=x*14-7;			YY:=y*14+7;			ZZ:=z*14+14;			ThePoint:=ThreeD(XX,YY,ZZ);			MoveTo(ThePoint.h,ThePoint.v);			if side = 0 then 				YY:=y*14-7			else				XX:=x*14+7;			ThePoint:=ThreeD(XX,YY,ZZ);			LineTo(ThePoint.h,ThePoint.v);			if side = 2 then				YY:=y*14-7			else				ZZ:=z*14;			ThePoint:=ThreeD(XX,YY,ZZ);			LineTo(ThePoint.h,ThePoint.v);			if side = 0 then				YY:=y*14+7			else 				XX:=x*14-7;			ThePoint:=ThreeD(XX,YY,ZZ);			LineTo(ThePoint.h,ThePoint.v);			if side = 2 then				YY:=y*14+7			else 				ZZ:=z*14+14;			ThePoint:=ThreeD(XX,YY,ZZ);			LineTo(ThePoint.h,ThePoint.v);			ClosePoly;						{TheSides[x,y,z,side]:=NewRgn;			OpenRgn;			framePoly(SidePoly);			CloseRgn(TheSides[x,y,z,side]);						TheSmallSides[x,y,z,side]:=NewRgn;			CopyRgn(TheSides[x,y,z,side],TheSmallSides[x,y,z,side]);			insetRgn(TheSmallSides[x,y,z,side],1,1);			}			KillPoly(SidePoly);		end;	Procedure SetUpSides;				var			i:integer;					begin			setPort(TheMazeWindowPointer);			{for i := 0 to DrawDepth do				begin					for j := -i div 2+1 to i div 2+1 do  	 				for k := -i div 2-2  to i div 2 +1 do  	 					MakeSide(j,k,i,0);  	 									for j := -i div 2-2  to i div 2 + 1 do  	 				for k := -i div 2-2 to i div 2 + 1 do  	 					MakeSide(j,k,i,1);		  	 			for j := -i div 2-1 to i div 2+1 do  	 				for k := -i div 2-1 to i div 2+1 do  	 					MakeSide(j,k,i,2);				end;}		end;		Procedure ReadMaze(var TheMaze:MazeType;								var TheReply:SFReply);										var			MazeTextFile:Text;			i,j,k:integer;					begin			Reset(MazeTextFile,TheReply.fullpathname);			readln(TheMaze.XMazeSize);			readln(TheMaze.YMazeSize);			readln(TheMaze.YMazeSize);			for i:=0 to TheMaze.XMazeSize do				for j:=0 to TheMaze.YMazeSize do					for k:=0 to TheMaze.ZMazeSize do						with TheMaze.Maze[i,j,k] do							begin								Readln(MazeDrawOrderNumber);								Readln(MazeBrightness);								for Side:= 0 to 3 do									Readln(MazePicture[Side]);							end;			Close(MazeTextFile);		end;									procedure OpenMaze(var TheMaze:MazeType);			var			TheReply:SFReply;					begin			SFGetFile(50,50,'Open Maze File',nil,TheReply);			if Reply.Good then				ReadMaze(TheMaze,TheReply);		end;			procedure initMaze(var TheMaze:MazeType);		var			i,j,k,Side:integer;					begin			for i:=0 to TheMaze.XMazeSize do				for j:=0 to TheMaze.YMazeSize do					for k:=0 to TheMaze.ZMazeSize do						with TheMaze.Maze[i,j,k] do							begin								MazeDrawOrderNumber:=0;								MazeBrightness:=0;								for side := 0 to 3 do									MazePicture[side]:=0;							end;		end;		Procedure initMazeInfo(Var TheMaze:MazeType);			begin			TheMaze.XMazeSize:=0;			TheMaze.YMazeSize:=0;			TheMaze.YMazeSize:=0;		end;			Procedure SetUpDrawOrder;				begin				end;		procedure ShutDownSides;		var			i:integer;					begin			for i := 0 to Depth do	   		begin	   			for j := -i div 2 to i div 2 do	   				for k := -i div 2 to i div 2 do	   					DisposeRgn(TheSides[j,k,i,2]);				   			for j := -i div 2-1 to i div 2+1 do	   				for k := -i div 2-1 to i div 2+1 do	   					begin	   						DisposeRgn(TheSides[j,k,i,0]);	   						DisposeRgn(TheSides[j,k,i,1]);	   					end;				end;		end;	procedure ProcessMenu(CodeWord:LongInt);		var			MenuNum:integer;			itemNum:integer;			begin			MenuNum:=HiWord(CodeWord);			ItemNum:=LoWord(CodeWord);						case itemNum of				Aboutitem:;								QuitItem:Quitting:=True;								XPlusItem:XMaze:=XMaze+1;				YPlusItem:YMaze:=YMaze+1;				ZPlusItem:ZMaze:=ZMaze+1;				DPlusItem:DMaze:=DMaze+1;				XMinusItem:XMaze:=XMaze-1;				YMinusItem:YMaze:=YMaze-1;				ZMinusItem:ZMaze:=ZMaze-1;				DMinusItem:DMaze:=DMaze-1;			end;			HiliteMenu(False,menuNum);		end;		procedure mainEventLoop;		var			Event:EventRecord;			code:integer;				begin			event.TaskMask:=$1FFF;			Quitting:=False;			Finished:=False;					repeat				Code:=TaskMaster(-1,Event);				Case Code of					NullEvent:;					MouseDown:;					MouseUp:;					KeyDown:;					AutoKey:;					UpDateEvt:;					activateEvt:;					switchEvt:;					DeskaccEvt:;					wInDesk:;					WinMenuBar:ProcessMenu(Event.TaskData);					wInContent:;					wInDrag:;					wInGrow:;					wInGoAway:;					wInZoom:;					wInInfo:;					wInFrame:;				end;				If Quitting then					Finished:=True;			until Finished;		end;		Begin		InitThings;			{SetUpWindow;		SetUpColors;		SetUpSides;		SetUpMaze;		InitCursor;		MainEventLoop;		ShutDownSides;}		CloseThings;	end.