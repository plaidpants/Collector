program Collector;  	{This is the data collector program's main module} 	  {$B+}  	{Set bundle bit so finder will use my icon}	  {$T APPLColl} 	 {set my file type and creator}  	{$U-}  	{Use my units}  	{$R Jim Surine:Programming:Reasources:Collector.Rsrc}	  {Load my reasources, remember to stick in here just the reasouces you need}  	{$S+}  	{Use Segments because program is larger than 32K}   {$I-}   {Set Folder to write output application}   {$O Jim Surine:Programming:Programs:Collectors:Collector v2.2.3}      {$U Jim Surine:Programming:Units:My Units:Dialogs}        {Dialog handler}   {$U Jim Surine:Programming:Units:Mews Units:Serial}   {$U Jim Surine:Programming:Units:My Units:Patterns}           {Graphs need axis}   {$U Jim Surine:Programming:Units:My Units:Axis2}           {Graphs need axis}   {$U Jim Surine:Programming:Units:My Units:Histogram}      {The Collector uses histograms}   {$U Jim Surine:Programming:Units:My Units:GrayScale}      {The Collector uses gray scales}   {$U Jim Surine:Programming:Units:My Units:RecordInteger}   {$U Jim Surine:Programming:Units:My Units:RecordReal}   {$U Jim Surine:Programming:Units:My Units:RecordLongInt}   {$U Jim Surine:Programming:Units:My Units:Plot}   {$U Jim Surine:Programming:Units:My Units:AutoRecord}   {$U Jim Surine:Programming:Units:My Units:CollectorGlobals}   {$U Jim Surine:Programming:Units:My Units:Stack}            {Collector type defining routines}   {$U Jim Surine:Programming:Units:My Units:Tape}            {Collector type defining routines}   {$U Jim Surine:Programming:Units:My Units:TDC}            {Collector type defining routines}   {$U Jim Surine:Programming:Units:My Units:ADC}            {Collector type defining routines}     {$S units1} {Need another segment}     uses    Memtypes,           {Basic types stanadard}    QuickDraw,          {Quickdraw standard}    OSIntf,             {Operating system standard}    ToolIntf,           {Tools standard}      PackIntf,           {Package stuff (List Manager, Decimal to string convert)}    MacPrint,           {Printer driver}    Serial,             {RS232 port driver}    sane,               {For Real number conversions}      PasInOut,           {For writting textfiles}{$S units2}{Need another segment, already too long}    Dialogs,            {My Dialog Routines}    Patterns,    Axis2,{$S units5}    Histogram,          {Routines for histogram graph}    GrayScale,          {Routines for Gray Scale graph}{$S units3}{Need another segment, already too long}    RecordInteger,    RecordReal,    RecordLongInt,    Plot,    AutoRecord,    {$S units4}{Need another segment, already too long}    CollectorGlobals,    Stack,              {Main modifier routines for collector so it collects TDC data}    Tape,{$S units5}    TDC,{$S units8}    ADC;    {$S }{Main module unit}  const    WindowID = 20792;         {Window template}    AboutID = 17953;          {About Dialog}    WindowDataID = 25074;     {Window Data parameters editing dialog}    PrintingID = 8093;        {info dialog used for non-spool printing}      AppleMenuID = 300;		      {the Apple menu}    AboutItemID = 1;      FileMenuID = 301;		       {the File menu}    NewItemID = 1;    OpenItemID = 2;    CloseItemID = 4;    SaveItemID = 5;    SaveAsItemId = 6;    RevertItemID = 7;    PageSetUpItemID = 9;    PrintItemID = 10;    StopPrintItemID = 11;    SaveSettingsItemID = 13;    QuitItemID = 15;      EditMenuID = 302;	 	      {the Edit menu}    UndoItemID = 1;    CutItemID = 3;    CopyItemID = 4;    PasteItemID = 5;    ClearItemID = 6;      OptionsMenuID = 303;      {Options Menu}    DrawingItemID = 1;    DataItemID = 2;    CollectingItemID = 3;    TypeItemID = 4;    InfoItemID = 5;    AddToWindowID = 6;      CollectingMenuID = 304;   {Collecting Menu}    StartCollectingItemID = 1;    StopCollectingItemID = 2;    ResetItemID = 3;    RecordToFileItemID = 5;    ReadFromFileItemID = 6;      WindowMenuID = 305;       {Window Menu}    RedrawItemID = 1;    RedrawAllItemID = 2;    HideItemID = 3;    TileItemID = 4;    StackItemID = 5;    StartDrawingItemID=6;    StopDrawingItemID=7;    TypeMenuID = 306;       {Window Menu}    StackCollectorItemID = 1;    TapeDriveCollectorItemID = 2;    TDCCollectorItemID = 3;    ADCCollectorItemID = 4;      UndoCmd = 0;                  CutCmd = 2;    CopyCmd = 3;    PasteCmd = 4;    Clearcmd = 5;      TitleBarHeight = 18;      {Values used for organizing windows}    MenuBarHeight = 20;      RedrawDelayDefault = 600; {in 60th's of second for window updates during collection}  var    {System Globals}      TheWindow : WindowPtr;          {Current Window}    WindowCount : integer;          {Number of My Windows}    Quitting, Finished : Boolean;   {Quitting and then finished}    LastClick : LongInt;            {Time of last click ,for double clicks}    LastMouse : Point;              {Where was it last Clicked}    Printing : Boolean;             {Are we printing}    BackGroundPrint : Boolean;      {Should we background print when printing}    Collecting : Boolean;           {Should the program be collecting data}    Drawing:Boolean;    CollectingMode:Integer;        {Global printer values}      PrRecHdl : 								{Page setup info}        THPrint;    MyStRec : 								{print record}        TPrStatus;    MyPrPort : 				{graphic port for printing}        TPPrPort;    DoPrintSetUp :    {Flag for if you want to have standard printing dialog at beginning of print used for finder print}        Boolean;      {System Constant varibles}       MyMenus :                   {All the menus}    array[AppleMenuID..TypeMenuID] of MenuHandle;    Watch : Cursor;             {Holds Watch cursor}    ScreenWidth : Integer;      {Screen Size}    ScreenHeight : integer;    DragArea : Rect;            {Clicking and drawing varible constants}    GrowArea : Rect;    DoubleArea : Integer;    {**************procedures that need to be forwarded**************}   procedure EventLoop;  forward;   {*******************Menu Hilight Procedure*****************}  procedure FixWindowMenu;     var      SearchWindow : WindowPeek;      ThisWindow : WindowPtr;      TheString : Str255;      TheHandle : Handle;     begin    TheHandle := Handle(myMenus[WindowMenuID]);    ReleaseResource(TheHandle);    myMenus[WindowMenuID] := GetMenu(WindowMenuID);      ThisWindow := FrontWindow;    SearchWindow := WindowPeek(ThisWindow);    while SearchWindow <> nil do      begin        ThisWindow := WindowPtr(SearchWindow);        GetWTitle(ThisWindow, TheString);        AppendMenu(MyMenus[WindowMenuID], TheString);        SearchWindow := SearchWindow^.nextwindow;      end;  end;   procedure MenuHilight;     var      theData : WDHandle;      dataHandle : Handle;      WindowKind : Integer;      ThisWindow : WindowPeek;        i:integer;          begin    FixWindowMenu;        {Type Menu Stuff}         if WindowKind <> 1 then     begin       Enableitem(MyMenus[TypeMenuID], 0);        Enableitem(MyMenus[TypeMenuID], StackCollectorItemID);        Enableitem(MyMenus[TypeMenuID], TapeDriveCollectorItemID);        Enableitem(MyMenus[TypeMenuID], TDCCollectorItemID);       Enableitem(MyMenus[TypeMenuID], ADCCollectorItemID);        for i:= StackCollectorItemID to ADCCollectorItemID do            SetItemMark (MyMenus[TypeMenuID],i,chr(noMark));       SetItemMark (MyMenus[TypeMenuID],StackCollectorItemID+CollectingMode,chr(checkMark));     end   else       Disableitem(MyMenus[TypeMenuID], 0);     if FrontWindow <> nil then      begin        ThisWindow := WindowPeek(FrontWindow);        if ThisWindow^.WindowKind > 7 then          WindowKind := 0; {My WIndow}        if (ThisWindow^.WindowKind <= 7) and (ThisWindow^.WindowKind >= 1) then          WindowKind := 1;  {My Dialog or Alert}        if ThisWindow^.WindowKind < 0 then          WindowKind := 2;  {Desk Accessory}                  dataHandle := Handle(GetWRefCon(FrontWindow));        theData := WDHandle(DataHandle);        Hlock(dataHandle);            {Apple Menu Stuff}          if WindowKind <> 1 then          Enableitem(MyMenus[AppleMenuID], 0)  {Apple Menu}        else          DisableItem(MyMenus[AppleMenuID], 0);         {Edit Menu Stuff}          Enableitem(MyMenus[EditMenuID], 0); {Edit Menu Always Enabled}        Enableitem(MyMenus[EditMenuID], CopyItemID);            if WindowKind = 2 then          Enableitem(MyMenus[EditMenuID], UndoItemID)        else          Disableitem(MyMenus[EditMenuID], UndoItemID);             if WindowKind <> 0 then          begin            Enableitem(MyMenus[EditMenuID], CutItemID);   {Cut,Paste,Clear}            Enableitem(MyMenus[EditMenuID], PasteItemID);            Enableitem(MyMenus[EditMenuID], ClearItemID);          end        else          begin            DisableItem(MyMenus[EditMenuID], CutItemID);   {Cut,Paste,Clear}            DisableItem(MyMenus[EditMenuID], PasteItemID);            DisableItem(MyMenus[EditMenuID], ClearItemID);          end;     {FileMenu Stuff}        if WindowKind <> 1 then          begin            Enableitem(MyMenus[fileMenuID], 0); {File Menu}                  Enableitem(MyMenus[fileMenuID], NewItemID); {New}            Enableitem(MyMenus[fileMenuID], OpenItemID); {Open}            Enableitem(MyMenus[fileMenuID], CloseItemID); {Close}            if Printing then              begin                Enableitem(MyMenus[fileMenuID], StopPrintItemID); {Stop Print}                DisableItem(MyMenus[fileMenuID], PageSetupItemID); {PageSetup}              end            else              begin                DisableItem(MyMenus[fileMenuID], StopPrintItemID); {Stop Print}                Enableitem(MyMenus[fileMenuID], PageSetupItemID); {PageSetup}              end;                   Enableitem(MyMenus[fileMenuID], QuitItemID); {Quit}                  if WindowKind = 0 then              begin                Enableitem(MyMenus[fileMenuID], SaveAsItemID); {SaveAs}                if TheData^^.OnDisk then                  begin                    Enableitem(MyMenus[fileMenuID], SaveItemID); {Save}                    Enableitem(MyMenus[fileMenuID], RevertItemID); {Revert}                  end                else                  begin                    DisableItem(MyMenus[fileMenuID], SaveItemID); {Save}                    DisableItem(MyMenus[fileMenuID], RevertItemID); {Revert}                  end;                         if Printing then                  DisableItem(MyMenus[fileMenuID], PrintItemID) {Print}                else                  Enableitem(MyMenus[fileMenuID], PrintItemID); {print}              end            else              begin                DisableItem(MyMenus[fileMenuID], SaveAsItemID); {SaveAs}                DisableItem(MyMenus[fileMenuID], SaveItemID); {Save}                DisableItem(MyMenus[fileMenuID], RevertItemID); {Revert}                DisableItem(MyMenus[fileMenuID], PrintItemID) {Print}              end          end        else          DisableItem(MyMenus[fileMenuID], 0);                       if WindowKind = 0 then          EnableItem(MyMenus[OptionsMenuID], 0)        else          DisableItem(MyMenus[OptionsMenuID], 0);             if WindowKind <> 1 then          begin            EnableItem(MyMenus[CollectingMenuID], 0);            if Collecting then              begin                DisableItem(MyMenus[CollectingMenuID], StartCollectingItemID);                EnableItem(MyMenus[CollectingMenuID], StopCollectingItemID);              end            else              begin                EnableItem(MyMenus[CollectingMenuID], StartCollectingItemID);                DisableItem(MyMenus[CollectingMenuID], StopCollectingItemID);              end          end        else          DisableItem(MyMenus[CollectingMenuID], 0);        if Drawing then          begin            DisableItem(MyMenus[WindowMenuID], StartDrawingItemID);            EnableItem(MyMenus[WindowMenuID], StopDrawingItemID);          end        else          begin            EnableItem(MyMenus[WindowMenuID], StartDrawingItemID);            DisableItem(MyMenus[WindowMenuID], StopDrawingItemID);          end;                  Hunlock(dataHandle);      end    else      begin        DisableItem(MyMenus[OptionsMenuID], 0);        DisableItem(MyMenus[EditMenuID], 0);        EnableItem(MyMenus[AppleMenuID], 0);        EnableItem(MyMenus[FileMenuID], 0);        Enableitem(MyMenus[fileMenuID], NewItemID);        Enableitem(MyMenus[fileMenuID], OpenItemID);        EnableItem(MyMenus[fileMenuID], QuitItemID);        if Printing then          begin            Enableitem(MyMenus[fileMenuID], StopPrintItemID); {Stop Print}            DisableItem(MyMenus[fileMenuID], PageSetUpItemID); {PageSetup}          end        else          begin            DisableItem(MyMenus[fileMenuID], StopPrintItemID); {Stop Print}            Enableitem(MyMenus[fileMenuID], PageSetUpItemID); {PageSetup}          end;        Disableitem(MyMenus[fileMenuID], CloseItemID);        Disableitem(MyMenus[fileMenuID], SaveItemID);        Disableitem(MyMenus[fileMenuID], SaveAsItemID);        Disableitem(MyMenus[fileMenuID], RevertItemID);        Disableitem(MyMenus[fileMenuID], PrintItemID);            begin          EnableItem(MyMenus[CollectingMenuID], 0);          if Collecting then            begin              DisableItem(MyMenus[CollectingMenuID], StartCollectingItemID);              EnableItem(MyMenus[CollectingMenuID], StopCollectingItemID);            end          else            begin              EnableItem(MyMenus[CollectingMenuID], StartCollectingItemID);              DisableItem(MyMenus[CollectingMenuID], StopCollectingItemID);            end        end      end;    DrawMenuBar;  end;   {**********************Window drawing Procedures*****************}  procedure DrawWindow(var TheWindowData:WindowDataType;                  ThePort:WIndowPtr);  Var    OldPort:WindowPtr;      begin    GetPort(OldPort);    case TheWindowData.WindowDataInfo.TypeOfData[1] of      0:        DrawHistogram(TheWindowData.WindowData.Histogram,ThePort);      1:        DrawGrayScale(TheWindowData.WindowData.GrayScale,ThePort);      2:        DrawRecordInteger (TheWindowData.WindowData.RecordInteger,ThePort);      3:        DrawRecordReal (TheWindowData.WindowData.RecordReal,ThePort);      4:        DrawAutoRecord (TheWindowData.WindowData.AutoRecord,ThePort);    end;    SetPort(OldPort);  end;  procedure DrawWindowPic (AWindow : WindowPtr);             var      ThePicture : PicHandle;      DataHandle:Handle;      TheData:WDHandle;      OldPort:WindowPtr;        begin    GetPort(OldPort);    SetPort(AWindow);    DataHandle:=Handle(GetWRefCon(AWindow));    HLock(DataHandle);    TheData:=WDHandle(DataHandle);    ThePicture := GetWindowPic(AWindow);    if Drawing or (ThePicture = nil) then        begin          if ThePicture <> nil then            KillPicture(ThePicture);          ClipRect(AWindow^.PortRect);          ThePicture := OpenPicture(AWindow^.PortRect);             showpen;                EraseRect(AWindow^.PortRect);                DrawWindow(TheData^^,AWindow); {Predefined procedure}                penPat(White);                PenMode(Pator);                DrawGrowIcon(AWindow);             hidepen;          ClosePicture;                    SetWindowPic(AWindow, ThePicture);          TheData^^.LastReDraw := Tickcount;        end     else        begin          ClipRect(AWindow^.PortRect);          ThePicture := OpenPicture(AWindow^.PortRect);          showpen;          DrawPicture(GetWindowPic(AWindow),AWindow^.PortRect);          hidepen;          ClosePicture;                    SetWindowPic(AWindow, ThePicture);          TheData^^.LastReDraw := Tickcount;        end;    HUnlock(DataHandle);    SetPort(OldPort);  end;{********************* init window procedures ****************}procedure initWindowDatainfo(var TheWindowData:WindowDataType;                      ThePort:WIndowPtr); begin  TheWindowData.Changed := True;  case TheWindowData.WindowDataInfo.TypeofData[1] of   0 :     case CollectingMode of       0:StackinitHistograminfo(TheWindowData,ThePort);       1:TapeinitHistograminfo(TheWindowData,ThePort);       2:TDCinitHistograminfo(TheWindowData,ThePort);       3:ADCinitHistograminfo(TheWindowData,ThePort);     end;   1 :     case CollectingMode of       0:StackinitGrayScaleinfo(TheWindowData,ThePort);       1:TapeinitGrayScaleinfo(TheWindowData,ThePort);       2:TDCinitGrayScaleinfo(TheWindowData,ThePort);       3:{ADCinitGrayScaleinfo(TheWindowData);}     end;   2 :     case CollectingMode of       0:StackInitRecordIntegerinfo(TheWindowData,ThePort);       1:TapeInitRecordIntegerinfo(TheWindowData,ThePort);       2:TDCInitRecordIntegerinfo(TheWindowData,ThePort);       3:{ADCInitRecordIntegerinfo(TheWindowData);}     end;   3:          case CollectingMode of       0:StackinitRecordRealInfo(TheWindowData,ThePort);       1:TapeinitRecordRealInfo(TheWindowData,ThePort);       2:TDCinitRecordRealInfo(TheWindowData,ThePort);       3:{ADCinitRecordRealInfo(TheWindowData);}     end;   4:     case CollectingMode of       0:{StackinitAutoRecordInfo(TheWindowData)};       1:{TapeinitAutoRecordInfo(TheWindowData)};       2:TDCinitAutoRecordInfo(TheWindowData,ThePort);       3:{ADCinitAutoRecordInfo(TheWindowData);}     end;  end; end; procedure InitWindowDataWindowData(var TheWindowData:WindowDataType;                      ThePort:WindowPtr);   begin  TheWindowData.Changed := True;  case TheWindowData.WindowDataInfo.TypeofData[1] of   0 :     initHistogram(TheWindowData.WindowData.Histogram,ThePort);   1 :     initGrayScale(TheWindowData.WindowData.GrayScale,ThePort);   2 :     InitRecordInteger(TheWindowData.WindowData.RecordInteger,ThePort);   3:     initRecordReal(TheWindowData.WindowData.RecordReal,ThePort);   4:     initAutoRecord(TheWindowData.WindowData.AutoRecord,ThePort);  end; end; procedure InitWindowDataType(var TheWindowData:WindowDataType;            ThePort:WindowPtr);      begin    TheWindowData.Changed := True;    InitWindowDataInfo(TheWindowData,ThePort);    InitWindowDataWindowData(TheWindowData,ThePort);  end;   procedure initWindowData (var TheWindowData : WindowDataType;                ThePort:WindowPtr);     var      ThePoint : Point;      TheString : Str255;      OldPort:WindowPtr;        begin    GetPort(OldPort);    SetPort(ThePort);    with TheWindowData do      begin        Changed := True;        OnDisk := False;        GetWTitle(TheWindow, TheString); {Get untiled# from window}        Reply.Fname := TheString;        MaxSized := False;                ThePoint.h := 0;        ThePoint.v := 0;        LocalToGlobal(ThePoint);        WindowLoc := ThePoint;            WindowSize.h := TheWindow^.portRect.right - TheWindow^.portRect.left;        WindowSize.v := TheWindow^.portRect.Bottom - TheWindow^.portRect.top;            with WindowDataInfo do          begin            Collecting := true;            RedrawDelay := 0*RedrawDelayDefault * (WindowCount + 1);          end;      end;          initWindowDataType(TheWindowData,ThePort);    SetPort(OldPort);  end;  {********************* Close window procedures ****************} procedure CloseWindowDataWindowData(var TheWindowData:WindowDataType);   begin  TheWindowData.Changed := True;  case TheWindowData.WindowDataInfo.TypeofData[1] of   0 :     CloseHistogram(TheWindowData.WindowData.Histogram);   1 :     CloseGrayScale(TheWindowData.WindowData.GrayScale);   2 :     CloseRecordInteger(TheWindowData.WindowData.RecordInteger);   3:     CloseRecordReal(TheWindowData.WindowData.RecordReal);   4:     CloseAutoRecord(TheWindowData.WindowData.AutoRecord);  end; end; procedure CloseWindowDataType(var TheWindowData:WindowDataType);     begin    TheWindowData.Changed := True;    CloseWindowDataWindowData(TheWindowData);  end;  procedure CloseWindowData (var TheWindowData : WindowDataType);     begin    with TheWindowData do      begin      end;    CloseWindowDataType(TheWindowData);  end;{*********************** window dialogs **********************}  Procedure WindowDrawingDialog(var TheWindowData:WindowDataType;                  ThePort:WindowPtr);  begin     case TheWindowData.WindowDataInfo.TypeofData[1] of      0:        HistogramDisplayDialog(TheWindowData.WindowData.Histogram,ThePort);      1:        GrayScaleDisplayDialog(TheWindowData.WindowData.GrayScale,ThePort);      2:        RecordIntegerDisplayDialog(TheWindowData.WindowData.RecordInteger,ThePort);      3:        RecordRealDisplayDialog(TheWindowData.WindowData.RecordReal,ThePort);      4:        AutoRecordDisplayDialog(TheWindowData.WindowData.AutoRecord,ThePort);    end;  end; Procedure WindowDataDialog(var TheWindowData:WindowDataType;                                    ThePort:WindowPtr);  begin     case TheWindowData.WindowDataInfo.TypeofData[1] of      0:        HistogramDataDialog(TheWindowData.WindowData.Histogram,ThePort);      1:        GrayScaleDataDialog(TheWindowData.WindowData.GrayScale,ThePort);      2:        RecordIntegerDataDialog(TheWindowData.WindowData.RecordInteger,ThePort);      3:        RecordRealDataDialog(TheWindowData.WindowData.RecordReal,ThePort);      4:        AutoRecordDataDialog(TheWindowData.WindowData.AutoRecord,ThePort);    end;  end;   Procedure WindowinfoDialog(var TheWindowData:WindowDataType);  begin     case TheWindowData.WindowDataInfo.TypeofData[1] of      0:        HistograminfoDialog(TheWindowData.WindowData.Histogram);      1:        GrayScaleinfoDialog(TheWindowData.WindowData.GrayScale);      2:        RecordIntegerinfoDialog(TheWindowData.WindowData.RecordInteger);      3:        RecordRealinfoDialog(TheWindowData.WindowData.RecordReal);      4:        AutoRecordinfoDialog(TheWindowData.WindowData.AutoRecord);    end;  end;  procedure SetGetWindowDataInfoDialog (var TheWindowDataInfo : WindowDataInfoType;                  var DialogPointer : DialogPtr;                  SetGet : boolean);           begin    with TheWindowDataInfo do      begin        setGetDlgInteger(3, RedrawDelay, DialogPointer, SetGet);        SetgetDlgBoolean(4, Collecting, DialogPointer, SetGet);        SelectText(DialogPointer, 3);      end;  end;   procedure WindowDataInfoDialog (var TheWindowDataInfo : WindowDataInfoType);     var      DialogPointer : DialogPtr;     begin    DialogPointer := GetNewDialog(WindowDataID, nil, pointer(-1));    SetGetwindowDataInfoDialog(TheWindowDataInfo, dialogPointer, true);    ShowHide(DialogPointer, true);    MenuHilight;    Modal(OKCancelType, DialogPointer);    if not CancelButton then      SetGetWindowDataInfoDialog(TheWindowDataInfo, DialogPointer, false);    DisposDialog(DialogPointer);    MenuHilight;  end;{************************** save and load window procedures *******************} procedure SaveWindowAsText(var TheWindowData:WindowDataType;              Reply:SfReply;              var OutPut:Text);    var         i:integer;      begin    for i:=1 to 10 do      Writeln(Output,TheWindowData.WindowDatainfo.TypeOfData[i]);    Writeln(Output,TheWindowData.WindowDatainfo.Collecting);    Writeln(Output,TheWindowData.WindowDatainfo.RedrawDelay);        Writeln(Output,TheWindowData.WindowLoc.h);    Writeln(Output,TheWindowData.WindowLoc.v);    Writeln(Output,TheWindowData.WindowSize.h);    Writeln(Output,TheWindowData.WindowSize.v);    case TheWindowData.WindowDataInfo.TypeOfData[1] of      0:        SaveHistogramAsText ( TheWindowData.WindowData.Histogram, Reply,OutPut);      1:        SaveGrayScaleAsText (TheWindowData.WindowData.GrayScale, Reply,OutPut);      2:        SaveRecordIntegerAsText (TheWindowData.WindowData.RecordInteger, Reply,OutPut);      3:        SaveRecordRealAsText (TheWindowData.WindowData.RecordReal, Reply,OutPut);      4:        SaveAutoRecordAsText (TheWindowData.WindowData.AutoRecord, Reply,OutPut);    end;  end; procedure LoadWindowAsText(var TheWindowData:WindowDataType;              Reply:SfReply;              var Input:Text);    var        i:integer;        dummy:str255;          begin    for i:=1 to 10 do      Readln(Input,TheWindowData.WindowDatainfo.TypeOfData[i]);    readln(Input,dummy);    if Dummy='TRUE' then      TheWindowData.WindowDatainfo.Collecting:=true    else      TheWindowData.WindowDatainfo.Collecting:=False;    Readln(Input,TheWindowData.WindowDatainfo.RedrawDelay);    TheWindowData.LastRedraw:=TickCount;    TheWindowData.Reply:=Reply;    TheWindowData.OnDisk :=true;    TheWindowData.Changed :=false;    Readln(Input,TheWindowData.WindowLoc.h);    Readln(Input,TheWindowData.WindowLoc.v);    Readln(Input,TheWindowData.WindowSize.h);    Readln(Input,TheWindowData.WindowSize.v);    case TheWindowData.WindowDataInfo.TypeOfData[1] of      0:        LoadHistogramAsText ( TheWindowData.WindowData.Histogram, Reply,Input);      1:        LoadGrayScaleAsText (TheWindowData.WindowData.GrayScale, Reply,Input);      2:        LoadRecordIntegerAsText (TheWindowData.WindowData.RecordInteger, Reply,Input);      3:        LoadRecordRealAsText (TheWindowData.WindowData.RecordReal, Reply,Input);      4:        LoadAutoRecordAsText (TheWindowData.WindowData.AutoRecord, Reply,Input);    end;  end;  {************MainEventLoop Procedures**********}{This handles all user interaction}  procedure DealWithActivates(theEvent : EventRecord);     const      ChangeFlag = $0002;       var      WhichWindow : WindowPtr;     begin    with TheEvent do      begin        WhichWindow := WindowPtr(message);        if BitAnd(modifiers, ActiveFlag) <> 0 then          begin            TheWindow := WhichWindow;                  if BitAnd(Modifiers, ChangeFlag) <> 0 then { comming from a system Window?}        {read desk scrap into toolbox scrap}              ;                   MenuHilight;                end{Then}        else          begin            TheWindow := nil;                  if BitAnd(Modifiers, changeFlag) <> 0 then {Exiting to a system window}              begin            {write current toolbox Scrap to desk scrap}                ;              end;                   MenuHilight;          end;{else}      end;{with}  end;  {***************DealWithMouseDowns procedures***************}  procedure DoDoubleGrow(WindowPointedTo:WindowPtr);     var      theData : WDHandle;      dataHandle : Handle;      TempPort : WindowPtr;     begin    if WindowPointedTo <> FrontWindow then      SelectWindow(WindowPointedTo)    else      begin        GetPort(TempPort);        SetPort(TheWindow);        dataHandle := Handle(GetWRefCon(TheWindow));        Hlock(DataHandle);{We use a with so we need a lock}        theData := WDHandle(DataHandle);            if TheData^^.MaxSized then          with TheData^^ do            begin              HideWindow(WindowPointedTo);              MoveWIndow(WindowPointedTo, WindowLoc.h, WindowLoc.v, true);              SizeWindow(WindowPointedTo, WindowSize.h, WindowSize.v, true);              invalRect(WindowPointedTo^.PortRect);              ShowWindow(WindowPointedTo);              TheData^^.MaxSized := False;              DrawWindowPic(WindowPointedTo);            end        else          begin            HideWindow(WindowPointedTo);            MoveWindow(WindowPointedTo, 5, 40, true);            SizeWindow(WindowPointedTo, ScreenWidth - 10, ScreenHeight - 45, true);            invalRect(WindowPointedTo^.PortRect);            ShowWindow(WindowPointedTo);            TheData^^.MaxSized := True;            DrawWindowPic( WindowPointedTo);          end;        SetPort(TempPort);        Hunlock(DataHandle);      end;  end;  {*************DoMenuBar Procedures ****************}{*************DoMenuChoice Procedures ****************}  procedure DoCollectingChoice (TheItem : integer);   begin    case TheItem of      StartCollectingItemID :         Collecting := True;      StopCollectingItemID :         Collecting := False;      ResetItemID :         ;      ReadFromFileItemID :         ;      RecordToFileItemID :         ;    end;    MenuHilight;  end;   procedure DoOptionsChoice (TheItem : integer);     var      theData : WDHandle;      dataHandle : Handle;      TempWindowDataInfo : WindowDataInfoType;      OldPort : WindowPtr;      DialogPointer : DialogPtr;     begin    GetPort(OldPort);    SetPort(TheWindow);    dataHandle := Handle(GetWRefCon(TheWindow));    Hlock(DataHandle);{we use a with so we need a lock}    theData := WDHandle(DataHandle);    case TheItem of        DrawingItemID :         begin          WindowDrawingDialog(thedata^^,TheWindow);          if not cancelButton then            begin              thedata^^.Changed := True;              DrawWindowPic( TheWIndow); {Time to Update whole window}              InvalRect(TheWindow^.PortRect);            end;        end;          DataItemID :         begin          WindowDataDialog(thedata^^,TheWindow);          if not CancelButton then            begin              thedata^^.Changed := True;              DrawWindowPic(TheWindow); {Time to Update whole window}              InvalRect(TheWindow^.PortRect);            end;        end;          CollectingItemID :         begin          WindowDataInfoDialog(thedata^^.WindowDataInfo);          if not CancelButton then            thedata^^.Changed := True;        end;          TypeItemID :         begin          case CollectingMode of          0:StackWindowTypeDialog(thedata^^.WindowDataInfo);          1:TapeWindowTypeDialog(thedata^^.WindowDataInfo);          2:TDCWindowTypeDialog(thedata^^.WindowDataInfo);          3:ADCWindowTypeDialog(thedata^^.WindowDataInfo);          end;          if not CancelButton then            begin              thedata^^.Changed := True;              initWindowDataType(TheData^^,TheWindow);              DrawWindowPic( TheWindow); {Time to Update whole window}              InvalRect(TheWindow^.PortRect);            end;        end;      InfoItemID :         begin          WindowInfoDialog(thedata^^);        end;    end;      Hunlock(Datahandle);    SetPort(OldPort);  end; {*************DoEditChoice Procedures*******************}{**************Scrap Access*********************}  procedure WritePicToScrap;     var      TheResult : integer;      ThePicture : PicHandle;      TheHandle : Handle;     begin    ThePicture := GetWindowPic(TheWindow);    TheHandle := Handle(ThePicture);    Hlock(TheHandle);    TheResult := PutScrap(GetHandleSize(TheHandle), 'PICT', TheHandle^);    Hunlock(TheHandle);    if theResult <> noErr then      sysbeep(1);  end;   procedure DoEditChoice (TheItem : Integer);   begin    case TheItem of      UndoItemID :         if not SystemEdit(UndoCmd) then          sysbeep(1);      CutItemID :         if not SystemEdit(CutCmd) then          WritePicToScrap;      CopyItemID :         if not SystemEdit(CopyCmd) then          WritePicToScrap;      PasteItemID :         if not SystemEdit(PasteCmd) then          sysbeep(1);      ClearItemID :         if not SystemEdit(ClearCmd) then          sysbeep(1);    end;  end; {**********DoAppleChoice Procedures*************}  procedure DoAbout;     var      DialogPointer : DialogPtr;     begin    DialogPointer := GetNewDialog(AboutID, nil, pointer(-1));    ShowHide(DialogPointer, true);    MenuHilight;    Modal(OKType, DialogPointer);    DisposDialog(DialogPointer);    MenuHilight;  end;   procedure DoAppleChoice (TheItem : Integer);     var      accName : str255;      accNumber : integer;     begin    case TheItem of      AboutItemID :         DoAbout;      otherwise        begin          GetItem(MyMenus[AppleMenuID], TheItem, accName);          accNumber := OpenDeskAcc(AccName);          MenuHilight;        end;    end;  end;   {********DoFileChoice Procedures************}   {***************Sub DoFileChoice Procedures**********}     procedure GetReadFile (var reply : SFReply);     var      pt : point;      FileTypeArray : SFTypeList;     begin    pt.h := 50;    pt.v := 50;      FileTypeArray[0] := 'HIST';    FileTypeArray[0] := 'GREY';    FileTypeArray[0] := 'PLOT';    FileTypeArray[0] := 'TEXT';        SFGetFile(pt, 'File to Open', nil, 4, FileTypeArray, nil, reply);    CancelButton := not Reply.Good;  end;   procedure GetTextReadFile (var reply : SFReply);     var      pt : point;      FileTypeArray : SFTypeList;     begin    pt.h := 50;    pt.v := 50;      FileTypeArray[0] := 'TEXT';    SFGetFile(pt, 'File to Open', nil, 1, FileTypeArray, nil, reply);    CancelButton := not Reply.Good;  end;  procedure GetWriteFile (var reply : SFReply);     var      pt : point;     begin    pt.h := 50;    pt.v := 50;    SFPutFile(pt, 'Save Filename', Reply.Fname, nil, reply);    CancelButton := not Reply.Good;  end;   procedure CheckResultError(ResultError:integer;            var error:Boolean);     var      TheError : str255;      TheString:StringHandle;        begin    if ResultError<>noerr then      begin        TheString:=GetString(10000-ResultError);        Hlock(Handle(TheString));        TheError:=TheString^^;        Hunlock(Handle(TheString));        if TheError='' then          TheError:='Unknown error';        sysbeep(10);        OKDialog(TheError);        Error:=True;      end;  end;    procedure WriteText (Reply : SFReply;                  var error:Boolean);     var      theData : WDHandle;      dataHandle : Handle;      OutPut:Text;      ResultError:integer;      DummyString:StringPtr;      OldVol:integer;      i:integer;        begin    SetCursor(Watch);    error:=False;    dataHandle := Handle(GetWRefCon(TheWindow));    Hlock(DataHandle);{We use a procedure so we need a lock}    theData := WDHandle(DataHandle);        DummyString:=Nil;    ResultError:=GetVol(DummyString,OldVol);    CheckResulterror(ResultError,error);    if ResultError<>noErr then      OKDialog('Could not get current volume')    else      begin        DummyString:=Nil;        ResultError:=SetVol(DummyString,Reply.vRefNum);        CheckResulterror(ResultError,error);        if ResultError<>noErr then          OKDialog('Could not set to correct volume')        else          begin            TextCreator:='Coll';            TextType:='TEXT';                        Rewrite(Output,Reply.Fname);  {Make sure there is a file}            CheckResulterror(IOResult,error);            if IOResult<>noErr then              OKDialog('Could not create dummy file')            else              begin                Close(Output);                CheckResulterror(IOResult,error);                if IOResult<>noErr then                  OKDialog('Could not close dummy file')                else                  begin                    ResultError:=FSDelete (Reply.Fname, Reply.vRefNum);                    CheckResulterror(ResultError,error);                    if ResultError<>noErr then                      OKDialog('Could not delete dummy file')                    else                      begin                        Rewrite(Output,Reply.Fname);                        CheckResulterror(IOResult,error);                        if IOResult<>noErr then                          OKDialog('Could not rewrite file')                        else                          begin                            SaveWindowAsText(TheData^^, Reply,OutPut);                            CheckResulterror(IOResult,error);                            if IOResult<>noErr then                              OKDialog('error while writing data to disk');                          end;                        Close(Output);                        CheckResulterror(IOResult,error);                        if IOResult<>noErr then                          OKDialog('Could not close file');                      end;                  end;              end;          end;        DummyString:=Nil;        ResultError:=SetVol(DummyString,OldVol);        CheckResulterror(ResultError,error);        if ResultError<>noErr then          OKDIalog('Could not reset to application volume');      end;          if not error then      begin        TheData^^.Reply := Reply;        TheData^^.OnDisk := True;        TheData^^.Changed := False;        SetWTitle(TheWindow, reply.fName);      end;          Hunlock(DataHandle);    SetCursor(Arrow);  end;  procedure ReadText (Reply : SFReply;                var error:Boolean);    var      theData : WDHandle;      dataHandle : Handle;      Input:Text;      ResultError:integer;      DummyString:StringPtr;      OldVol:integer;      i:integer;      Dummy:str255;        begin    SetCursor(Watch);    error:=False;    dataHandle := Handle(GetWRefCon(TheWindow));    Hlock(DataHandle);{We use a procedure so we need a lock}    theData := WDHandle(DataHandle);        DummyString:=Nil;    ResultError:=GetVol(DummyString,OldVol);    CheckResulterror(ResultError,error);    if ResultError<>noerr then      OKDialog('Could not get current volume')    else      begin        DummyString:=Nil;        ResultError:=SetVol(DummyString,Reply.vRefNum);        CheckResulterror(ResultError,error);        if ResultError<>noerr then          OKDialog('Could not set to files volume')        else          begin            Reset(Input,Reply.Fname);            CheckResulterror(IOResult,error);            if IOResult<>noerr then              OKDialog('Could not reset file')            else              begin                LoadWindowAsText(TheData^^, Reply,Input);                CheckResulterror(IOResult,error);                if IOResult<>noerr then                  OKDialog('Error during reading of data');              end;            Close(Input);            CheckResulterror(IOResult,error);            if IOResult<>noerr then              OKDialog('Could not close file');          end;        DummyString:=Nil;        ResultError:=SetVol(DummyString,OldVol);        CheckResulterror(ResultError,error);        if ResultError<>noerr then          OKDialog('Could not Set volume back');      end;    SetWTitle(TheWindow, reply.fName);    TheData^^.MaxSized := True;     DoDoubleGrow(TheWindow);    Hunlock(DataHandle);    SetCursor(Arrow);  end; {***************Do New Procedures****************}  {******* NewWindow Procedures ***********}   procedure OffSetWindow (WhichWindow : WindowPtr);     const      offset = 20;       var      windowWidth : integer;      WindowHeight : integer;      HExtra : integer;      VExtra : integer;      HMax : integer;      vMax : integer;      WindowLeft : integer;      WindowTop : integer;      DataHandle:Handle;      TheData:WDHandle;      ThePoint:Point;      OldPort:WindowPtr;        begin    GetPort(OldPort);    SetPort(WhichWindow);    with whichWindow^.portRect do      begin        windowWidth := right - left;        windowHeight := Bottom - top;        WindowHeight := windowHeight + TitleBarHeight;      end;       hextra := ScreenWidth - WindowWidth;    vExtra := ScreenHeight - (WindowHeight + MenuBarHeight);    hMax := (hExtra div offset) + 1;    vMax := (vExtra div offset) + 1;    WindowCount := WindowCount + 1;    WindowLeft := (WindowCount mod hMax) * offset;    WindowTop := (WindowCount mod vMax) * offset;    WindowTop := WindowTop + TitleBarHeight + MenuBarHeight;    MoveWindow(WhichWindow, WindowLeft, WindowTop, False);        dataHandle := Handle(GetWRefCon(WhichWindow));    theData := WDHandle(DataHandle);    Hlock(DataHandle);    TheData^^.WindowSize.h := windowWidth;    TheData^^.WindowSize.v := windowHeight -TitleBarHeight;    ThePoint.h := 0;    ThePoint.v := 0;    LocalToGlobal(ThePoint);    TheData^^.WindowLoc := ThePoint;    TheData^^.MaxSized := False;    Hunlock(DataHandle);    SetPort(OldPort);  end;   procedure NewWindow;     var      DataHandle : Handle;      TheString : Str255;     begin    ResrvMem(SizeOf(WindowDataType));    if memError = noerr then      begin        DataHandle := NewHandle(SizeOf(WindowDataType));        TheWindow := GetNewWindow(WindowID, nil, WindowPtr(-1));        SetWRefCon(TheWindow, LongInt(DataHandle));        NumToString(WindowCount, TheString);        SetWTitle(TheWindow, 'Untitled' + TheString);        OffsetWindow(TheWindow);      end    else      begin        sysbeep(10);        okDialog('Memory Error');      end;  end;   procedure DoNew;     var      TempWindowDatainfo : WindowDataInfotype;      i : integer;      theData : WDHandle;      dataHandle : Handle;     begin    TempWindowDatainfo := DefaultWindowDatainfo;    IgnoreErrorCheck := True;    case CollectingMode of      0:StackWindowTypeDialog(TempWindowDatainfo);      1:TapeWindowTypeDialog(TempWindowDatainfo);      2:TDCWindowTypeDialog(TempWindowDatainfo);      3:ADCWindowTypeDialog(TempWindowDatainfo);    end;    IgnoreErrorCheck := false;      if not CancelButton then      begin        NewWindow;            dataHandle := Handle(GetWRefCon(TheWindow));        Hlock(DataHandle);{We call a procedure so we need a lock}        theData := WDHandle(DataHandle);            TheData^^.WindowDataInfo := TempWindowDatainfo;        InitWindowData(TheData^^,TheWindow);        Hunlock(DataHandle);            ShowWindow(TheWindow);      end;  end;    procedure DoSaveAs;     var      theData : WDHandle;      dataHandle : Handle;      Reply : SFReply;      error:Boolean;        begin    dataHandle := Handle(GetWRefCon(TheWindow));    theData := WDHandle(DataHandle);    Hlock(dataHandle);    Reply := TheData^^.Reply;    Hunlock(dataHandle);    GetWriteFile(Reply);    if Reply.Good then      Writetext(Reply,error);  end;   procedure DoSave;     var      theData : WDHandle;      dataHandle : Handle;      Reply : SFReply;      error:Boolean;        begin    dataHandle := Handle(GetWRefCon(TheWindow));    theData := WDHandle(DataHandle);    Hlock(DataHandle);    if TheData^^.OnDisk then      begin        Reply := TheData^^.Reply;        if TheData^^.Changed then          OKCancelDialog('Are you sure you want to write over ' + Reply.fname);        if not CancelButton then          WriteText(Reply,error);      end    else      DoSaveAs;    Hunlock(DataHandle);  end;    {***********DoClose Procedures**********}   procedure CloseAppWindow;     var      theData : WDHandle;      dataHandle : Handle;      ThisWindow : WindowPtr;      TheEvent : EventRecord;     begin    dataHandle := Handle(GetWRefCon(TheWindow));    theData := WDHandle(DataHandle);    Hlock(dataHandle);        CancelButton := False;      if TheData^^.Changed then      begin        YesNoCancelDialog('Do you want to save Changes to ' + TheData^^.Reply.Fname + '?');        if Yesbutton then          doSave;        if CancelButton then          Quitting := False;      end;          Hunlock(dataHandle);        if not CancelButton then      begin        ThisWindow := TheWindow;            HideWindow(TheWindow);            if GetNextEvent(ActivMask, TheEvent) then          DealWithActivates(TheEvent);        if GetNextEvent(ActivMask, TheEvent) then          DealWithActivates(TheEvent);                  Hlock(dataHandle);        CloseWindowData(TheData^^);        Hunlock(dataHandle);                 DisposHandle(Datahandle);        DisposeWindow(ThisWindow);      end;  end;   procedure CloseSysWindow; {Needed to close system Windows When Quitting}    var      whichWindow : WindowPeek;      accNumber : integer;     begin    WhichWindow := WindowPeek(FrontWindow);    accNumber := WhichWindow^.WindowKind;    CloseDeskAcc(accNumber);    MenuHilight;  end;   procedure DoClose;   begin    if FrontWindow = TheWindow then      closeAppWindow    else      closeSysWindow;  end;  procedure DoOpen;     var      Reply : SfReply;      Error:Boolean;        begin    GetTextReadFile(Reply);    if Reply.good then      begin        newWindow;        ShowWindow(TheWindow);        ReadText(Reply,error);        if error then          DoClose;      end;  end;    procedure DoRevert;     var      theData : WDHandle;      dataHandle : Handle;      Reply : SFReply;      error:Boolean;        begin    dataHandle := Handle(GetWRefCon(TheWindow));    theData := WDHandle(DataHandle);    Hlock(dataHandle);    Reply := TheData^^.Reply;    if TheData^^.Changed then      OKCancelDialog('Lose all new data in ' + Reply.fname);    if not CancelButton then      ReadText(Reply,error);    Hunlock(dataHandle);  end;   procedure DoPageSetup;     var      trueORfalse : boolean;     begin    PrOpen;    trueORfalse := PrValidate(PrRecHdl); { make sure handle is valid}    trueORfalse := PrStlDialog(PrRecHdl); { fill the record with the info}    PrClose;  end; {********************DoPrint Procedures*******************}   procedure DoPrint;     var      trueorFalse : boolean;      theData : WDHandle;      dataHandle : Handle;      Reply : SFReply;      DialogPointer : DialogPtr;      CurrentPort:WindowPtr;        begin      {YesNoCancelDialog('Should this printing be done in the background');        if YesButton then      BackGroundPrint := True    else      BackGroundPrint := False;}           BackGroundPrint := False;        PrOpen;    if PrValidate(PrRecHdl) then      CancelButton := not PrStlDialog(PrRecHdl);    if DoPrintSetup then      CancelButton := not PrJobDialog(PrRecHdl)    else      CancelButton := False;          if not CancelButton then      begin        MyPrPort := PrOpenDoc(PrRecHdl, nil, nil);        Printing := True;                            {set Flag so I don't print again}        if BackGroundPrint then          begin            PrRecHdl^^.prJob.pIdleProc := @EventLoop; {Background is my program}            GetPort(CurrentPort);            MenuHilight;            SetPort(CurrentPort);          end;        if not BackGroundPrint then          begin            GetPort(CurrentPort);            SetCursor(Watch);                        DialogPointer := GetNewDialog(PrintingID, nil, pointer(-1));            showWindow(DialogPointer);            drawdialog(DialogPointer);                        SetPort(CurrentPort);          end;        PrOpenPage(MyPrPort, nil);        GetPort(CurrentPort);               dataHandle := Handle(GetWRefCon(TheWindow));        Hlock(DataHandle);      {We call a procedure so we need a lock}        theData := WDHandle(DataHandle);        DrawWindow(TheData^^,CurrentPort);        Hunlock(DataHandle);                        PrClosePage(MyPrPort);        PrCloseDoc(MyPrPort);                getPort(CurrentPort);        if PrError <> noErr then          OKDialog('There was a printing error');        SetPort(CurrentPort);                  if (PrRecHdl^^.prJob.bjDocLoop=bSpoolLoop) and (PrError=noerr) then          begin            {Swap Out Main Program}            PrPicFile(PrRecHdl, nil, nil, nil, myStRec);          end;        getPort(CurrentPort);        if PrError <> noErr then          OKDialog('There was a spooling printing error');        SetPort(CurrentPort);            if not BackGroundPrint then          begin            DisposDialog(DialogPointer);            SetCursor(arrow);          end;      end;       PrClose;    Printing := False;    MenuHilight;  end;   procedure DoFileChoice (TheItem : Integer);   begin    case TheItem of      NewItemID :         DoNew;      OpenItemID :         DoOpen;      CloseItemID :         DoClose;      SaveItemID :         DoSave;      SaveAsItemID :         DoSaveAs;      RevertItemID :         DoRevert;      PageSetUpItemID :         if not Printing then          DoPageSetUp        else          sysbeep(1);      PrintItemID :         if not Printing then          DoPrint        else          sysbeep(1);      StopPrintItemID :         if not Printing then          Sysbeep(1)        else          prSetError(iPrAbort);      QuitItemID :         begin          Quitting := True;          if Printing then            prSetError(iPrAbort);        end;    end;  end; {*****************Windows menu procedures*****************}  procedure SelectWindowMenu (TheString : Str255);     var      SearchWindow : WindowPeek;      ThisWindow : WindowPtr;      TheHandle : Handle;      TheTitle : Str255;     begin    ThisWindow := FrontWindow;    SearchWindow := WindowPeek(ThisWindow);    while SearchWindow <> nil do      begin        ThisWindow := WindowPtr(SearchWindow);        GetWTitle(ThisWindow, TheTitle);        if TheTitle = TheString then          begin            showwindow(ThisWindow);            SelectWindow(ThisWindow);          end;        SearchWindow := SearchWindow^.nextwindow;      end;  end;   procedure HideWindowMenu;     var      SearchWindow : WindowPeek;      ThisWindow : WindowPtr;      Number : integer;     begin    ThisWindow := FrontWindow;    SearchWindow := WindowPeek(ThisWindow);    if (SearchWindow^.WindowKind = userKind) and SearchWindow^.Visible then      begin        Number := 0;        while SearchWindow <> nil do          begin            if (SearchWindow^.WindowKind = userKind) and SearchWindow^.Visible then              Number := Number + 1;            SearchWindow := SearchWindow^.nextwindow;          end;        if Number <> 1 then          HideWindow(ThisWindow)        else          OKDialog('You can not hide all your windows.');      end    else      OKDialog('You can not hide system windows.');  end;   procedure StackWindowMenu;     var      SearchWindow : WindowPeek;      ThisWindow : WindowPtr;      OldPort : WindowPtr;     begin    getPort(OldPort);    ThisWindow := FrontWindow;    SearchWindow := WindowPeek(ThisWindow);    WindowCount := 0;    while SearchWindow <> nil do      begin        if SearchWindow^.WindowKind = userKind then          begin            ThisWindow := WindowPtr(SearchWindow);            SetPort(ThisWindow);            SizeWindow(ThisWindow, 200, 200, true);            OffsetWindow(ThisWindow);            DrawWindowPic(ThisWindow);            InvalRect(ThisWindow^.PortRect);            showWindow(ThisWindow);          end;        SearchWindow := SearchWindow^.nextwindow;      end;    SetPort(OldPort);  end;   procedure OffSetTileWindow (WhichWindow : WindowPtr);     const      offset = 20;       var      windowWidth : integer;      WindowHeight : integer;      HExtra : integer;      VExtra : integer;      HMax : integer;      vMax : integer;      WindowLeft : integer;      WindowTop : integer;      ThePoint:Point;      dataHandle:Handle;      TheData:WDHandle;      OldPort:WindowPtr;        begin    getPort(OldPort);    SetPort(WhichWindow);    with whichWindow^.portRect do      begin        windowWidth := right - left + 2;        windowHeight := Bottom - top + 2;        WindowHeight := windowHeight + TitleBarHeight;      end;       HMax := ScreenWidth div windowWidth;    VMax := ScreenHeight div windowHeight;      WindowLeft := (WindowCount mod HMax) * windowWidth;    WindowTop := ((WindowCount div HMax) mod VMax) * windowHeight;    WindowTop := WindowTop + TitleBarHeight + MenuBarHeight;    MoveWindow(WhichWindow, WindowLeft, WindowTop, False);      WindowCount := WindowCount + 1;        dataHandle := Handle(GetWRefCon(WhichWindow));    theData := WDHandle(DataHandle);    Hlock(dataHandle);    TheData^^.WindowSize.h := windowWidth;    TheData^^.WindowSize.v := windowHeight-TitleBarHeight;    ThePoint.h := 0;    ThePoint.v := 0;    LocalToGlobal(ThePoint);    TheData^^.WindowLoc := ThePoint;    TheData^^.MaxSized := False;    Hunlock(dataHandle);    SetPort(OldPort);  end;   procedure TileWindowMenu;     var      SearchWindow : WindowPeek;      ThisWindow : WindowPtr;      OldPort : WindowPtr;     begin    GetPort(OldPort);    WindowCount := 0;    ThisWindow := FrontWindow;    SearchWindow := WindowPeek(ThisWindow);    while SearchWindow <> nil do      begin        if SearchWindow^.WindowKind = userKind then          begin            ThisWindow := WindowPtr(SearchWindow);            SetPort(ThisWindow);            SizeWindow(ThisWindow, 168, 150, true);            OffsetTileWindow(ThisWindow);            DrawWIndowPic(ThisWindow);            invalRect(ThisWindow^.PortRect);            showWindow(ThisWindow);          end;        SearchWindow := SearchWindow^.nextwindow;      end;    SetPort(OldPort);  end;   procedure RedrawAllWindowMenu;     var      SearchWindow : WindowPeek;      ThisWindow : WindowPtr;      OldPort : WindowPtr;     begin    GetPort(OldPort);    ThisWindow := FrontWindow;    SearchWindow := WindowPeek(ThisWindow);    while SearchWindow <> nil do      begin        ThisWindow := WindowPtr(SearchWindow);        DrawWindowPic(ThisWindow);        invalRect(ThisWindow^.PortRect);        SearchWindow := SearchWindow^.NextWindow;      end;    SetPort(OldPort);  end;   procedure RedrawWindowMenu;     var      SearchWindow : WindowPeek;      ThisWindow : WindowPtr;      OldPort : WindowPtr;     begin    GetPort(OldPort);    ThisWindow := FrontWindow;    if ThisWindow <> nil then      begin        SetPort(ThisWindow);        SearchWindow := WindowPeek(ThisWindow);        DrawWindowPic(ThisWindow);        invalrect(ThisWindow^.PortRect);      end;    SetPort(OldPort);  end;   procedure DoWindowChoice (TheItem : Integer);     var      thestring : str255;      OldPort : WindowPtr;     begin    GetPort(OldPort);    SetPort(TheWindow);    case TheItem of      RedrawItemID :         RedrawWindowMenu;      RedrawAllItemID :         RedrawAllWindowMenu;      HideItemID :         HideWindowMenu;      TileItemID :         TileWindowMenu;      StackItemID :         StackWindowMenu;      StartDrawingItemID:        begin          Drawing:=True;          MenuHilight;        end;      StopDrawingItemID:        begin          Drawing:=False;          MenuHilight;        end;      otherwise        begin          getItem(MyMenus[WindowMenuID], TheItem, TheString);          SelectWindowMenu(TheString);        end;    end;    SetPort(OldPort);  end;  procedure DoTypeChoice (TheItem : Integer);     begin    case collectingMode of        0:StackClose;        1:TapeClose;        2:TDCClose;        3:ADCClose;     end;         case TheItem of      StackCollectorItemID :         CollectingMode:=0;      TapeDriveCollectorItemID :         CollectingMode:=1;      TDCCollectorItemID :         CollectingMode:=2;      ADCCollectorItemID :         CollectingMode:=3;    end;        MenuHilight;        case collectingMode of        0:StackInit;        1:TapeInit;        2:TDCInit;        3:ADCInit;     end;  end;   procedure DoMenuChoice (MenuChoice : longint);     var      TheMenu : Integer;      TheItem : Integer;     begin    if menuChoice <> 0 then      begin        theMenu := HiWord(MenuChoice);        TheItem := LoWord(MenuChoice);            case TheMenu of          AppleMenuID :             DoAppleChoice(TheItem);          FileMenuID :             DoFileChoice(TheItem);          EditMenuID :             DoEditChoice(TheItem);          OptionsMenuID :             DoOptionsChoice(TheItem);          CollectingMenuID :             DoCollectingChoice(TheItem);          WindowMenuID :             DoWindowChoice(TheItem);          TypeMenuID:            DoTypeChoice(TheItem);        end;        HiliteMenu(0); {Clear Menu bar of any Black selected things}      end;  end;   procedure DoMenuBar (TheEvent : EventRecord);     var      MenuChoice : LongInt;     begin    MenuChoice := MenuSelect(TheEvent.where);    DoMenuChoice(MenuChoice);  end;    procedure DoGrow (TheEvent : EventRecord;                  var WhichWindow : WindowPtr);             var      NewSize : LongInt;      NewHeight : Integer;      NewWidth : Integer;      theData : WDHandle;      dataHandle : Handle;      ThePoint : Point;      TempPort : WindowPtr;      ThePicture : PicHandle;     begin    if WhichWindow <> FrontWindow then      SelectWindow(WhichWindow)    else      begin        NewSize := GrowWindow(WhichWindow, TheEvent.where, GrowArea);        if NewSize <> 0 then          begin            NewHeight := HiWord(NewSize);            NewWidth := LoWord(NewSize);            SizeWindow(WhichWindow, NewWidth, NewHeight, true);            getPort(TempPort);            SetPort(WhichWindow); {so we update right window}            InvalRect(WhichWindow^.portRect); { so we will update window}                        dataHandle := Handle(GetWRefCon(TheWindow));            theData := WDHandle(DataHandle);            Hlock(dataHandle);            TheData^^.WindowSize.h := NewWidth;            TheData^^.WindowSize.v := NewHeight;            ThePoint.h := 0;            ThePoint.v := 0;            LocalToGlobal(ThePoint);            TheData^^.WindowLoc := ThePoint;            TheData^^.MaxSized := False;            Hunlock(dataHandle);            DrawWindowPic( TheWindow);                  SetPort(TempPort);          end;      end;  end;   procedure DoDrag (TheEvent : EventRecord;                  WhichWindow : WindowPtr);             var      theData : WDHandle;      dataHandle : Handle;      TheStartPoint, TheEndPoint : Point;      TempPort : WindowPtr;     begin    if WhichWindow <> FrontWindow then      SelectWindow(WhichWindow)    else      begin        GetPort(TempPort);        SetPort(TheWindow);        dataHandle := Handle(GetWRefCon(TheWindow));        theData := WDHandle(DataHandle);        Hlock(dataHandle);        TheStartPoint.h := 0;        TheStartPoint.v := 0;        LocalToGlobal(TheStartPoint);        DragWindow(WhichWindow, TheEvent.Where, DragArea);        TheEndPoint.h := 0;        TheEndPoint.v := 0;        LocalToGlobal(TheEndPoint);        if (TheStartPoint.h <> TheEndPoint.h) and (TheStartPoint.v <> TheEndPoint.v) then          begin            TheData^^.WindowLoc := TheEndPoint;            TheData^^.MaxSized := False;            TheData^^.WindowSize.h := TheWindow^.portRect.right - TheWindow^.portRect.left;            TheData^^.WindowSize.v := TheWindow^.portRect.Bottom - TheWindow^.portRect.top;          end;        Hunlock(dataHandle);        SetPort(TempPort);      end;  end;   procedure DoGoAway (TheEvent : EventRecord;                  WhichWindow : WindowPtr);           begin    if WhichWindow <> FrontWindow then      SelectWindow(WhichWindow)    else if TrackGoAway(WhichWindow, TheEvent.Where) then      DoClose;  end;   procedure DoContent (TheEvent : EventRecord;                  WhichWindow : WindowPtr);           begin    if WhichWindow <> FrontWindow then      SelectWindow(WhichWindow);  end;   procedure DealWithMouseDowns (theEvent : EventRecord);     var      location : Integer;      windowPointedTo : WindowPtr;      Loc : point;      windowLoc : integer;      VandH : Longint;      Height : Integer;      Width : Integer;     begin    Loc := theEvent.where;    windowLoc := FindWindow(Loc, windowPointedTo);      if ((tickcount - lastclick) < GetdblTime) and (abs(loc.h - LastMouse.h)         < DoubleArea) and (abs(loc.v - LastMouse.v) < DoubleArea) then        {Double click things to happen}        case windowLoc of        inDesk :           ;    {Do Nothing}        inMenuBar :           DoMenuBar(TheEvent);        inSysWindow :           SystemClick(theEvent, windowPointedTo);        inContent :           DoContent(TheEvent, windowPointedTo);        inGrow :           DoGrow(TheEvent, WindowPointedTo);        inDrag :           DoDoubleGrow(WindowPointedTo);        inGoAway :           DoGoAway(TheEvent, WindowPointedTo);      end       else      {Single Click Things to Happen}        case windowLoc of        inDesk :           ;    {Do Nothing}        inMenuBar :           DoMenuBar(TheEvent);        inSysWindow:           begin            SystemClick(theEvent, windowPointedTo);            MenuHilight;          end;        inContent :           DoContent(TheEvent, windowPointedTo);        inGrow :           DoGrow(TheEvent, WindowPointedTo);        inZoomIn,InZoomOut:            if TrackBox(WindowPointedTo,Loc,windowLoc) then                DoDoubleGrow(WindowPointedTo);        inDrag :           DoDrag(TheEvent, WindowPointedTo);        inGoAway :           DoGoAway(TheEvent, WindowPointedTo);      end;       LastClick := TickCount;    LastMouse := Loc;  end;   procedure DealWithUpdates (theEvent : EventRecord);     var      UpDateWindow : WindowPtr;      tempPort : WindowPtr;      TheData : WDHandle;      DataHandle : Handle;     begin    UpDateWindow := WindowPtr(theEvent.message);    GetPort(tempPort);    SetPort(UpDateWindow);    dataHandle := Handle(GetWRefCon(UpDateWindow));    Hlock(DataHandle);      {Need to lock it because drawhistogram uses a procedure call}    TheData := WDHandle(DataHandle);    DrawWindowPic( UpDateWindow); {Set windowpic so mac can handle updates itself}    InvalRect(UpdateWindow^.PortRect);  {Make sure whole window is updated at once}    HUnlock(DataHandle);    SetPort(tempPort);  end;   procedure DealWithKeyDowns (theEvent : EventRecord);     var      CharCode : integer;      ch : Char;      MenuChoice : longint;     begin    with TheEvent do      begin        charCode := BitAnd(Message, CharCodeMask);        ch := chr(CharCode);            if BitAnd(theEvent.modifiers, CmdKey) <> 0 then          begin            if what <> AutoKey then              begin                menuChoice := MenuKey(ch);                DoMenuChoice(MenuChoice);              end;          end        else{Dotyping}      end;  end;   {************MyTasks Procedures***************}   procedure MyTasks;     var      SearchWindow : WindowPeek;      ThisWindow : WindowPtr;      DataHandle : Handle;      TheData : WDHandle;      ADC : integer;      TempPort : WindowPtr;      TheEvent : EventType;      Error : boolean;     begin    Error := False;    case CollectingMode of      0:StackReadEvent(TheEvent, Error);      1:TapeReadEvent(TheEvent, Error);      2:TDCReadEvent(TheEvent, Error);      3:ADCReadEvent(TheEvent, Error);    end;    if error then      begin        Collecting := False;        OKDialog('Error reading event, collecting stopped');      end;    ThisWindow := FrontWindow;    SearchWindow := WindowPeek(ThisWindow);    while SearchWindow <> nil do      begin        if SearchWindow^.WindowKind = UserKind then          begin            ThisWindow := WindowPtr(SearchWindow);                  dataHandle := Handle(GetWRefCon(ThisWindow));            Hlock(dataHandle);            TheData := WDHandle(DataHandle);                  if TheData^^.WindowdataInfo.collecting then              begin                TheData^^.Changed := true;                if TheData^^.WindowDataInfo.TypeOfData[10]=collectingMode then                  if not error then                    case collectingMode of                      0:StackAddToWindow(TheData^^, TheEvent,ThisWindow);                      1:TapeAddToWindow(TheData^^, TheEvent,ThisWindow);                      2:TDCAddToWindow(TheData^^, TheEvent,ThisWindow);                      3:ADCAddToWindow(TheData^^, TheEvent,ThisWindow);                    end;                if ((Tickcount - TheData^^.LastReDraw)                     >= TheData^^.WindowdataInfo.RedrawDelay)                         and SearchWindow^.Visible and (TheData^^.WindowdataInfo.RedrawDelay <> 0) then                  begin                    GetPort(TempPort);                    setPort(ThisWindow);                    DrawWindowPic( ThisWindow); {Time to Update whole window}                    InvalRect(ThisWindow^.PortRect);                    SetPort(TempPort);                  end;              end;            Hunlock(dataHandle);          end;        SearchWindow := SearchWindow^.nextwindow;      end;  end;   procedure EventLoop;     var      Event : EventRecord;      ProcessIt : boolean;      TempPort : WindowPtr;     begin    GetPort(TempPort); {save Port For background printing}    SystemTask;    if collecting then      MyTasks;    ProcessIt := GetNextEvent(everyEvent, Event); { get the next event in queue}    if ProcessIt then      begin        case Event.what of          mouseDown :             if not Quitting then              DealWithMouseDowns(Event);          AutoKey :             if not Quitting then              DealWithKeyDowns(Event);          KeyDown :             if not Quitting then              DealWithKeyDowns(Event);          ActivateEvt :             DealWithActivates(Event);          UpdateEvt :             DealWithUpdates(Event);        end;      end    else      begin        if Quitting and (Event.What = NullEvent) then          begin            if FrontWindow <> nil then              DoClose            else              Finished := true;          end;      end;    SetPort(TempPort); {get back Port For background printing}  end; {*************InitThings Procedures**************}  procedure SetUpCursors;     var      WatchHandle : CursHandle;     begin    WatchHandle := GetCursor(WatchCursor);    Hlock(handle(WatchHandle));    Watch := WatchHandle^^;    Hunlock(handle(WatchHandle));  end;   procedure SetupMemory;     var        i:integer;          begin    for i:=1 to 20 do        MoreMasters;    MaxApplZone;  end;   procedure SetUpMenus;		{ get the menus & display them}     var      index : Integer;     begin    for index := AppleMenuID to TypeMenuID do      begin        myMenus[index] := GetMenu(index);        InsertMenu(myMenus[index], 0);      end;    AddResMenu(myMenus[AppleMenuID], 'DRVR');    MenuHilight;  end;   procedure SetupLimits;		{ set up the dragging and growing rects}     var      Screen : Rect;     begin    Screen := ScreenBits.bounds;    with Screen do      begin        ScreenHeight := bottom - top;        ScreenWidth := Right - Left;        SetRect(DragArea, left + 4, top + 24, right - 4, bottom - 4);        SetRect(GrowArea, left, top + 24, right, bottom);        GrowArea.left := 150;        GrowArea.top := 100;        DoubleArea := 4;      end;  end;   procedure DoStartup;     var      Message : integer;      Count : integer;      Reply : SFReply;      AFile : AppFile;      i : integer;      error:Boolean;        begin    CountAppFiles(Message, Count);    if (Message = AppOpen) and (Count > 0) then      for i := 1 to count do        begin          GetAppFiles(i, AFile);          Reply.vRefNum := AFile.vRefNum;          Reply.fType := AFile.Ftype;          Reply.version := AFile.VersNum;          Reply.FName := AFile.Fname;          NewWindow;          ShowWindow(TheWindow);          ReadText(Reply,error);          clrappfiles(i);        end    else if (Message = AppPrint) and (Count > 0) then      begin        NewWindow;        DoPageSetUp;        for i := 1 to count do          begin            GetAppFiles(i, AFile);            Reply.vRefNum := AFile.vRefNum;            Reply.fType := AFile.Ftype;            Reply.version := AFile.VersNum;            Reply.FName := AFile.Fname;            ReadText(Reply,error);            DoPrint;            clrappfiles(i);            DoPrintSetup := False;          end;        Quitting := True;        DoClose;      end    else if count=0 then        DoNew;  end;   procedure SetupPrinter;     var      TheHandle : Handle;     begin    PrRecHdl := THPrint(NewHandle(SizeOf(TPrint))); {make handle}    prOpen;    PrintDefault(PrRecHdl); 	{initialize the fields}    PrClose;    DoPrintSetup := True;  {Do Print setup when printing}    {mystrec}  end;   procedure InitThings;   begin    SetUpMemory;    FlushEvents(everyEvent, 0);      InitGraf(@thePort);    InitFonts;    InitWindows;    InitMenus;    TEInit;    InitDialogs(nil);    InitCursor;    InitAllPacks;      TheWindow := nil;     {None of my windows up yet}    Finished := False;    Quitting := False;    Collecting := false;    Printing := False;    Drawing:=true;    WindowCount := 0;     {None of my windows up yet}    CollectingMode:=2;    LastClick := TickCount;    SetPt(LastMouse, 0, 0);      SetUpLimits;    SetUpMenus;    SetUpcursors;    TDCInit;    {collecting mode 2}    SetUpPrinter;    DoStartUp;  end;   procedure CloseThings;   begin    {Collector doesn't open anything}  end; begin  initThings;  repeat    EventLoop;  until Finished and not Printing;  CloseThings;end.