unit RecordReal(-373);interface {$U-} {Use My own include Librarys} {$R DialogRsrc} {Load my reasources (dialog boxes etc..)} {$U Jim Surine:Programming:Units:My Units:Dialogs} {$I-} {$O Jim Surine:Programming:Units:My Units:RecordReal} uses Memtypes,            {Basic types stanadard} QuickDraw,           {Quickdraw standard} OSIntf,              {Operating system standard} ToolIntf,            {Tools standard} PackIntf,            {Package stuff (List Manager, Decimal to string convert)} sane,                {For Real number conversions}  PasInOut,  Dialogs; const  RecordRealDisplayID = 26819 ;{RecordReal Display parameters editing dialog}  RecordRealDataID = 23041 ; {RecordReal Data parameters editing dialog}  RecordRealInfoID = 4871;    CurrNumberRecordedLimitRecordReal = 5000;  NumberPerRecordLimitRecordReal = 10;type    RecordRealDataType=        packed array[1..NumberPerRecordLimitRecordReal] of Real;    RecordRealDataSegmentHandle=        ^RecordRealDataSegmentPointer;    RecordRealDataSegmentPointer=        ^RecordRealDataSegmentType;    RecordRealDataSegmentType =  Packed record        RecordRealDataSegment:            packed array[1..CurrNumberRecordedLimitRecordReal] of Real;        NextRecordRealDataSegmentHandle:            RecordRealDataSegmentHandle;    end;      RecordRealInfoType =     record      NumberPerRecord : integer;      NumberToRecord:LongInt;      Title : Str255;      DrawOption : integer;    end;    RecordRealHandle=    ^RecordRealPointer;  RecordRealPointer=    ^RecordRealType;  RecordRealType =    record      RecordRealInfo : RecordRealInfoType;      NumberRecorded : LongInt;      Max,Min,Sum,SumSquared:Array[1..NumberPerRecordLimitRecordReal] of real;      DataSegmentHandle : RecordRealDataSegmentHandle;      CurrNumberRecorded:longInt;      CurrDataSegmentHandle : RecordRealDataSegmentHandle;    end;  RecordRealAnalType = array [1..NumberPerRecordLimitRecordReal] of    record      Number : LongInt;      Mean : real;      StandardDev : real;      Maximum : real;      Minimum : real;    end; procedure InitRecordReal (var RecordReal : RecordRealType;         ThePort:WindowPtr); procedure CloseRecordReal (var RecordReal : RecordRealType); procedure AddToRecordReal (var RecordReal : RecordRealType;         Numbers : RecordRealDataType;         ThePort:WindowPtr;         var Error:Boolean);  procedure SetGetAddRecordReal (var TheRecordReal : RecordRealType;         var Numbers : RecordRealDataType;         Loc:LongInt;         SetGetAdd:Integer;         ThePort:WindowPtr);     procedure DrawRecordReal (var TheRecordReal : RecordRealType;            ThePort:WindowPtr);  Procedure SaveRecordRealAsText (var TheRecordReal : RecordRealType;          Reply:SFReply;          var OutPut:Text); Procedure LoadRecordRealAsText (var TheRecordReal : RecordRealType;          Reply:SFReply;          var Input:Text);  procedure RecordRealDisplayDialog (var RecordReal : RecordRealType;                    ThePOrt:WindowPtr);  procedure RecordRealDataDialog (var RecordReal : RecordRealType;                    ThePOrt:WindowPtr); procedure RecordRealAnal(var RecordRealAnal:RecordRealAnalType;            var RecordReal : RecordRealType); procedure RecordRealInfoDialog (var RecordReal : RecordRealType);implementationprocedure CheckRecordReal( var RecordReal : RecordRealType); begin    if RecordReal.RecordRealinfo.NumberPerRecord>NumberPerRecordLimitRecordReal then        begin            RecordReal.RecordRealinfo.NumberPerRecord:=NumberPerRecordLimitRecordReal;            OKDialog('Number Per record Greater Than Limit');        end; end; procedure InitRecordReal {(var RecordReal : RecordRealType;         ThePort:WindowPtr)};     begin    CheckRecordReal( RecordReal);    RecordReal.CurrDataSegmentHandle:=RecordRealDataSegmentHandle(NewHandle(SizeOf(RecordRealDataSegmentType)));    Hlock(Handle(RecordReal.CurrDataSegmentHandle));    RecordReal.CurrDataSegmentHandle^^.NextRecordRealDataSegmentHandle:=nil;    Hunlock(Handle(RecordReal.CurrDataSegmentHandle));    RecordReal.CurrNumberRecorded := 0;    RecordReal.DataSegmentHandle:=RecordReal.CurrDataSegmentHandle;    RecordReal.NumberRecorded := 0; end; procedure CloseRecordReal {(var RecordReal : RecordRealType)};      var    TheDataSegmentHandle:RecordRealDataSegmentHandle;     begin    While RecordReal.DataSegmentHandle<>nil do        begin            TheDataSegmentHandle:=RecordReal.DataSegmentHandle;            HLock(Handle(TheDataSegmentHandle));            RecordReal.DataSegmentHandle:=TheDataSegmentHandle^^.NextRecordRealDataSegmentHandle;            HUnlock(Handle(TheDataSegmentHandle));            DisposHandle(Handle(TheDataSegmentHandle));        end; end; procedure AddToRecordReal {(var RecordReal : RecordRealType;         Numbers : RecordRealDataType;         ThePort:WindowPtr;         var error:Boolean)};  var   i:integer;   TheDataSegmentHandle:RecordRealDataSegmentHandle;   OldPort:WindowPtr;    begin    GetPort(OldPort);    SetPort(ThePort);    Error:=False;    with RecordReal do        begin            if (RecordRealInfo.NumberToRecord > 0) then                begin                    HLock(Handle(CurrDataSegmentHandle));                    if (CurrNumberRecorded>=CurrNumberRecordedLimitRecordReal-RecordRealInfo.NumberPerRecord) then                        begin                             ResrvMem( SizeOf(RecordRealDataSegmentType));                            if memError = noerr then                                begin                                    TheDataSegmentHandle:=CurrDataSegmentHandle;                                    CurrDataSegmentHandle^^.NextRecordRealDataSegmentHandle :=                                         RecordRealDataSegmentHandle(NewHandle(SizeOf(RecordRealDataSegmentType)));                                    CurrDataSegmentHandle:=CurrDataSegmentHandle^^.NextRecordRealDataSegmentHandle;                                    HLock(Handle(CurrDataSegmentHandle));                                    HUnlock(Handle(TheDataSegmentHandle));                                    CurrDataSegmentHandle^^.NextRecordRealDataSegmentHandle:=nil;                                    CurrNumberRecorded:=0;                                end                            else                                begin                                    RecordRealInfo.NumberToRecord:=0;                                    OKDialog('Memory Full in add to Record integer');                                end;                        end;                                        if RecordRealInfo.NumberToRecord > 0 then                        begin                            for i := 1 to RecordRealInfo.NumberPerRecord do                                begin                                    CurrNumberRecorded:=CurrNumberRecorded+1;                                    CurrDataSegmentHandle^^.RecordRealDataSegment[CurrNumberRecorded]:=Numbers[i];                                end;                            RecordRealInfo.NumberToRecord:=RecordRealInfo.NumberToRecord-1;                            NumberRecorded:=NumberRecorded+1;                        end;                                            HUnlock(Handle(CurrDataSegmentHandle));                end            else              Error:=True;        end;    SetPort(OldPort); end; procedure SetGetAddRecordReal {(var TheRecordReal : RecordRealType;         var Numbers : RecordRealDataType;         Loc:LongInt;         SetGetAdd:Integer;         ThePort:WindowPtr)};  var    i:integer;    CurrCount:Integer;    NumberPerSegment,Segments:integer;    NextDataSegmentHandle,TheDataSegment:RecordRealDataSegmentHandle;    OldPort:WIndowPtr;     begin  GetPort(OldPort);  SetPort(ThePort);     if TheRecordReal.NumberRecorded <> 0 then         begin         If Loc>(TheRecordReal.NumberRecorded) then            Loc:=TheRecordReal.NumberRecorded;         If Loc<0 then            Loc:=0;                   NumberPerSegment:=TheRecordReal.RecordRealinfo.NumberPerRecord             *(CurrNumberRecordedLimitRecordReal div TheRecordReal.RecordRealinfo.NumberPerRecord);                  CurrCount:=(Loc*TheRecordReal.RecordRealinfo.NumberPerRecord) mod NumberPerSegment;                  Segments:=(Loc*TheRecordReal.RecordRealinfo.NumberPerRecord) div NumberPerSegment;                  NextDataSegmentHandle:=TheRecordReal.DataSegmentHandle;         for i:= 1 to Segments do            begin                HLock(Handle(NextDataSegmentHandle));                TheDataSegment:=NextDataSegmentHandle;                NextDataSegmentHandle:=TheDataSegment^^.NextRecordRealDataSegmentHandle;                HUnlock(Handle(TheDataSegment));            end;                     TheDataSegment:=NextDataSegmentHandle;         HLock(Handle(TheDataSegment));         for i:= 1 to TheRecordReal.RecordRealInfo.NumberPerRecord do            begin                CurrCount:=CurrCount+1;                case SetGetAdd of                    0:TheDataSegment^^.RecordRealDataSegment[CurrCount]:=Numbers[i];                    1:Numbers[i]:=TheDataSegment^^.RecordRealDataSegment[CurrCount];                    2:begin                        TheDataSegment^^.RecordRealDataSegment[CurrCount]:=Numbers[i]                            +TheDataSegment^^.RecordRealDataSegment[CurrCount];                        Numbers[i]:=TheDataSegment^^.RecordRealDataSegment[CurrCount];                      end;                end;            end;                  HUnlock(Handle(TheDataSegment));     end;     SetPort(OldPort); end;Procedure SaveRecordRealAsText {(var TheRecordReal : RecordRealType;          Reply:SFReply;          var OutPut:Text)};  var     i,j:integer;    CurrCount:Integer;    NextDataSegmentHandle,TheDataSegment:RecordRealDataSegmentHandle;    		begin			with TheRecordReal do				begin					writeln(Output,RecordRealInfo.NumberToRecord);     writeln(Output,RecordRealInfo.NumberPerRecord);     writeln(Output,RecordRealInfo.Title);         writeln(Output,RecordRealInfo.DrawOption);     writeln(Output,NumberRecorded);     NextDataSegmentHandle:=TheRecordReal.DataSegmentHandle;          i:=0;    While i<NumberRecorded do        begin            HLock(Handle(NextDataSegmentHandle));            TheDataSegment:=NextDataSegmentHandle;                        CurrCount:=0;            While (CurrCount< CurrNumberRecordedLimitRecordReal-                RecordRealinfo.NumberPerRecord) and (i<TheRecordReal.NumberRecorded) do                begin                   i:=i+1;                   for j:= 1 to TheRecordReal.RecordRealInfo.NumberPerRecord do                        begin                            CurrCount:=CurrCount+1;                            write(OutPut,TheDataSegment^^.RecordRealDataSegment[CurrCount]:9:9,chr(9));                        end;                    writeln(Output);                end;            NextDataSegmentHandle:=TheDataSegment^^.NextRecordRealDataSegmentHandle;            HUnlock(Handle(TheDataSegment));        end;				end;		end;Procedure LoadRecordRealAsText {(var TheRecordReal : RecordRealType;          Reply:SFReply;          var InPut:Text)};  var     i,j:integer;    TheDataSegmentHandle,TheDataSegment:RecordRealDataSegmentHandle;    		begin   CloseRecordReal(TheRecordReal);			with TheRecordReal do				begin					Readln(Input,RecordRealInfo.NumberToRecord);     Readln(Input,RecordRealInfo.NumberPerRecord);     Readln(Input,RecordRealInfo.Title);         Readln(Input,RecordRealInfo.DrawOption);     Readln(Input,NumberRecorded);          DataSegmentHandle:=RecordRealDataSegmentHandle(NewHandle(SizeOf(RecordRealDataSegmentType)));     CurrDataSegmentHandle:=DataSegmentHandle;     HLock(Handle(CurrDataSegmentHandle));     CurrDataSegmentHandle^^.NextRecordRealDataSegmentHandle:=nil;      HunLock(Handle(CurrDataSegmentHandle));           i:=0;     HLock(Handle(CurrDataSegmentHandle));     CurrNumberRecorded:=0;     While i<TheRecordReal.NumberRecorded do         begin            i:=i+1;                        if (CurrNumberRecorded>=CurrNumberRecordedLimitRecordReal-RecordRealInfo.NumberPerRecord) then               begin                    ResrvMem( SizeOf(RecordRealDataSegmentType));                   if memError = noerr then                       begin                           TheDataSegmentHandle:=CurrDataSegmentHandle;                           CurrDataSegmentHandle^^.NextRecordRealDataSegmentHandle :=                                RecordRealDataSegmentHandle(NewHandle(SizeOf(RecordRealDataSegmentType)));                           CurrDataSegmentHandle:=CurrDataSegmentHandle^^.NextRecordRealDataSegmentHandle;                           HLock(Handle(CurrDataSegmentHandle));                           HUnlock(Handle(TheDataSegmentHandle));                           CurrDataSegmentHandle^^.NextRecordRealDataSegmentHandle:=nil;                           CurrNumberRecorded:=0;                       end                   else                       begin                           RecordRealInfo.NumberToRecord:=0;                           OKDialog('Memory Full in add to Record integer');                       end;               end;            for j:= 1 to TheRecordReal.RecordRealInfo.NumberPerRecord do                 begin                     CurrNumberRecorded:=CurrNumberRecorded+1;                     Read(Input,CurrDataSegmentHandle^^.RecordRealDataSegment[CurrNumberRecorded]);                 end;             Readln(Input);         end;       HUnlock(Handle(CurrDataSegmentHandle));     end;		end; procedure DrawRecordReal {(var TheRecordReal : RecordRealType;                  ThePort:WindowPtr)};  var   Box : rect;   Title:str255;   seconds:longint;   TheString:Str255;   OldPort:WindowPtr;     begin   GetPort(OldPort);   SetPort(ThePort);   Box:=ThePort^.portRect;   Box.Bottom:=Box.Bottom-15;   Box.Top:=Box.Bottom-30;   box.right:=Box.Right-15;   Title:=TheRecordReal.RecordRealInfo.title;   GetDateTime(Seconds);   IUDateString(Seconds,shortdate,TheString);   Title:=Title+' Last recorded '+TheString;   IUTimeString(Seconds,false,TheString);   Title:=Title+' '+TheString;      NumToString(TheRecordReal.NumberRecorded,TheSTring);   Title:=Title+' Number recorded '+TheString;      TextBox(POINTER(ORD(@Title) + 1), Length(Title), Box, TEJustCenter);   SetCursor(Arrow);   SetPort(OldPort);  end;  procedure SetGetRecordRealDisplayDialog (var RecordReal : RecordRealType;         var DialogPointer : DialogPtr;         SetGet : boolean); begin  with RecordReal.RecordRealinfo do   begin    setGetDlgLongInt(3, NumberToRecord, DialogPointer, SetGet);    SetgetDlgStr255(4, Title, DialogPointer, SetGet);    SelectText(DialogPointer,3);   end; end; procedure RecordRealDisplayDialog {(var RecordReal : RecordRealType;                    ThePOrt:WindowPtr)};  var   DialogPointer : DialogPtr;    OldPort:WindowPtr;     begin  GetPort(OldPort);  DialogPointer := GetNewDialog(RecordRealDisplayID, nil, pointer(-1));  SetGetRecordRealDisplayDialog(RecordReal, dialogPointer, true);  ShowHide(DialogPointer, true);  Modal( OKCancelType, DialogPointer);  if not cancelButton then   SetGetRecordRealDisplayDialog(RecordReal, DialogPointer, false);  DisposDialog(DialogPointer);  CheckRecordReal( RecordReal);  SetPort(OldPort); end; procedure SetGetRecordRealDataDialog (var RecordReal : RecordRealType;         var DialogPointer : DialogPtr;         SetGet : boolean); begin  with RecordReal.RecordRealinfo do   begin    setGetDlgLongInt(3, NumberToRecord, DialogPointer, SetGet);    setGetDlginteger(4, NumberPerRecord, DialogPointer, SetGet);    SelectText(DialogPointer,3);   end; end; procedure RecordRealDataDialog {(var RecordReal : RecordRealType)};  var   DialogPointer : DialogPtr;   OldPort:WindowPtr;   begin  GetPort(OldPort);  DialogPointer := GetNewDialog(RecordRealDataID, nil, pointer(-1));  SetGetRecordRealDataDialog(RecordReal, dialogPointer, true);  ShowHide(DialogPointer, true);  Modal( OKCancelType, DialogPointer);  if not CancelButton then    begin      OKCancelDialog('Changing a RecordReals data ranges erases the RecordReal');      if not CancelButton then        begin          SetGetRecordRealDataDialog(RecordReal, DialogPointer, false);          CloseRecordReal(recordReal);          InitRecordReal(RecordReal,ThePort);        end;    end;  DisposDialog(DialogPointer);  CheckRecordReal( RecordReal);  SetPort(OldPort); end;  procedure RecordRealAnal{(var RecordRealAnal:RecordRealAnalType;            var RecordReal : RecordRealType)};   var    i,j,CurrCount:integer;    TheValue:real;    NextDataSegmentHandle,TheDataSegment:RecordRealDataSegmentHandle;      begin    for i:=1 to RecordReal.RecordRealInfo.NumberPerRecord do      begin        RecordRealAnal[i].Mean:=0;        RecordRealAnal[i].Maximum:=-inf;        RecordRealAnal[i].Minimum:=inf;        RecordRealAnal[i].StandardDev:=0;        RecordRealAnal[i].Number:=RecordReal.NumberRecorded      end;           NextDataSegmentHandle:=RecordReal.DataSegmentHandle;     i:=0;    While i<RecordReal.NumberRecorded do        begin            HLock(Handle(NextDataSegmentHandle));            TheDataSegment:=NextDataSegmentHandle;                        CurrCount:=0;            While (CurrCount< CurrNumberRecordedLimitRecordReal-                RecordReal.RecordRealinfo.NumberPerRecord) and (i<RecordReal.NumberRecorded) do                begin                   i:=i+1;                   for j:= 1 to RecordReal.RecordRealInfo.NumberPerRecord do                        begin                            CurrCount:=CurrCount+1;                                                        TheValue:=TheDataSegment^^.RecordRealDataSegment[CurrCount];                                                        if TheValue>RecordRealAnal[j].Maximum then                              RecordRealAnal[j].Maximum:=TheValue;                            if TheValue<RecordRealAnal[j].Minimum then                              RecordRealAnal[j].Minimum:=TheValue;                                                        RecordRealAnal[j].Mean:=RecordRealAnal[j].Mean+TheValue;                            RecordRealAnal[j].StandardDev:=RecordRealAnal[j].StandardDev+TheValue*TheValue;                        end;                end;            NextDataSegmentHandle:=TheDataSegment^^.NextRecordRealDataSegmentHandle;            HUnlock(Handle(TheDataSegment));        end;                   for i:=1 to RecordReal.RecordRealInfo.NumberPerRecord do      RecordRealAnal[i].Mean:=RecordRealAnal[i].Mean/RecordReal.NumberRecorded;        for i:=1 to RecordReal.RecordRealInfo.NumberPerRecord do      RecordRealAnal[i].StandardDev:=        Sqrt((RecordRealAnal[i].StandardDev/RecordReal.NumberRecorded)-(RecordRealAnal[i].Mean*RecordRealAnal[i].Mean));   end;    procedure SetGetRecordRealInfoDialog (var TheRecordRealAnal : RecordRealAnalType;         var DialogPointer : DialogPtr;         SetGet : boolean;         WhichOne:integer);     begin            setGetDlgReal(2, TheRecordRealAnal[WhichOne].Mean, DialogPointer, SetGet);    setGetDlgReal(3, TheRecordRealAnal[WhichOne].standardDev, DialogPointer, SetGet);    setGetDlgReal(4, TheRecordRealAnal[WhichOne].Maximum, DialogPointer, SetGet);    setGetDlgReal(5, TheRecordRealAnal[WhichOne].minimum, DialogPointer, SetGet);    setGetDlgLongInt(6, TheRecordRealAnal[WhichOne].number, DialogPointer, SetGet);  end; procedure RecordRealInfoDialog { (var RecordReal : RecordRealType)};  var    DialogPointer : DialogPtr;    i:integer;    TheRecordRealAnal:RecordRealAnalType;    OldPort:WindowPtr;     begin  GetPort(OldPort);  RecordRealAnal(TheRecordRealAnal,RecordReal);  for i:= 1 to RecordReal.RecordRealInfo.NumberPerRecord do    begin      DialogPointer := GetNewDialog(RecordRealinfoID, nil, pointer(-1));      SetGetRecordRealinfoDialog(TheRecordRealAnal, dialogPointer, true,i);      ShowHide(DialogPointer, true);      Modal( OKType, DialogPointer);      DisposDialog(DialogPointer);    end;  SetPort(OldPort); end; begin end.