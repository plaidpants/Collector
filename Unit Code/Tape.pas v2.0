unit Tape(-31747);interface {$U-} {Use My own include Librarys}  {$U Jim Surine:Programming:Units:My Units:Dialogs} {$U Jim Surine:Programming:Units:My Units:Patterns} {$U Jim Surine:Programming:Units:My Units:Axis2} {$U Jim Surine:Programming:Units:Mews Units:Serial} {$U Jim Surine:Programming:Units:My Units:Histogram} {$U Jim Surine:Programming:Units:My Units:GrayScale} {$U Jim Surine:Programming:Units:My Units:RecordInteger} {$U Jim Surine:Programming:Units:My Units:RecordReal} {$U Jim Surine:Programming:Units:My Units:RecordLongInt} {$U Jim Surine:Programming:Units:My Units:Plot} {$U Jim Surine:Programming:Units:My Units:AutoRecord} {$U Jim Surine:Programming:Units:My Units:CollectorGlobals} {$U Jim Surine:Programming:Units:My Units:Stack} {$I-} {$O Jim Surine:Programming:Units:My Units:Tape} uses Memtypes,            {Basic types stanadard} QuickDraw,           {Quickdraw standard} OSIntf,              {Operating system standard} ToolIntf,            {Tools standard}  PackIntf,            {Package stuff (List Manager, Decimal to string convert)} sane,                {For Real number conversions}   PasInOut,  Dialogs, Serial, Patterns, Axis2, Histogram, GrayScale, RecordInteger, RecordReal, RecordLongInt, PLot, AutoRecord,  CollectorGlobals,  Stack;   Var  LastFrame:LastFrameType;  {Used with read event}  Procedure TapeAddToWindow(var TheWindowData:WindowDataType;                    TheEvent:EventType;                    ThePort:WindowPtr);procedure TapeinitHistograminfo(var TheWindowData:WindowDataType;                    ThePort:WindowPtr);procedure TapeInitGrayScaleinfo(var TheWindowData:WindowDataType;                    ThePort:WindowPtr);procedure TapeInitRecordIntegerinfo(var TheWindowData:WindowDataType;                    ThePort:WindowPtr);procedure TapeInitRecordRealinfo(var TheWindowData:WindowDataType;                    ThePort:WindowPtr);procedure TapeWindowTypeDialog (var TheWindowDataInfo : WindowDataInfoType);procedure TapeInit;procedure TapeClose; procedure TapeReadEvent(var TheEvent:EventType;     var Error:Boolean);implementation{*************************Procedures for add to window*************}  Procedure TapeAddToWindow{(var TheWindowData:WindowDataType;                    TheEvent:EventType;                    ThePort:WindowPtr)};      begin      StackAddToWindow(TheWindowData,TheEvent,ThePort);    end;  {*************init windowDataWindowData procedures **************} procedure TapeinitHistograminfo{(var TheWindowData:WindowDataType;                    ThePort:WindowPtr)};  begin    StackinitHistograminfo(TheWindowData,ThePort); end;  procedure TapeinitGrayScaleinfo{(var TheWindowData:WindowDataType;                    ThePort:WindowPtr)};  begin    StackinitGrayScaleinfo(TheWindowData,ThePort); end;procedure TapeInitRecordIntegerinfo{(var TheWindowData:WindowDataType;                    ThePort:WindowPtr)}; begin    StackinitRecordIntegerinfo(TheWindowData,ThePort); end;procedure TapeInitRecordRealinfo{(var TheWindowData:WindowDataType;                    ThePort:WindowPtr)}; begin    StackinitRecordRealinfo(TheWindowData,ThePort); end;procedure TapeWindowTypeDialog {(var TheWindowDataInfo : WindowDataInfoType)}; begin    StackWindowTypeDialog (TheWindowDataInfo); end;var   BufferCount:integer; procedure TapeInit;    var        i:integer;         begin  if InitSPort(SPortA, baud9600, stop10, noParity, data8, 5000, none, none) <> noerr then    sysbeep(10);  for i := 1 to 10 do    DefaultWindowDatainfo.TypeOfData[i]:=0;  DefaultWindowDatainfo.TypeOfData[5]:=1;  DefaultWindowDatainfo.TypeOfData[10]:=1;  BufferCount:=0; end;procedure TapeClose;    begin        CloseSPort(SportA);    end;    const  BufferSize=4096;     function TapereadNibble(Var error:Boolean):Byte;  var    ch:char;    GotChar:Boolean;    count:integer;    Dummy:Byte;      begin     GotChar:=False;    Count:=0;    BufferCount:=BufferCount+1;        if BufferCount=BufferSize then      begin        BufferCount:=0;        Dummy:=TapeReadNibble(Error);        if Error then          DebugDialog(SerResult,'error in reading CheckSum',0);        BufferCount:=0;      end;          repeat      if InReady(SPortA) then        begin          GetChar(SPortA,ch);          if SerResult<>noErr then  {error on get char}            begin              error:=true;              DebugDialog(SerResult,'error in get char',0);            end          else            GotChar:=True;        end      else        begin          if SerResult<>noErr then  {error on inready}            begin              Error:=true;              debugDialog(SerResult,'Error in inready',0);            end;          SendChar(SportA,Chr(16));          SendChar(SportA,'4');          if SerResult<>noErr then  {error on send cntrl-P 4}            begin              Error:=true;              debugDialog(SerResult,'Error in send cntrl-P 4',0);            end;        end;    until GotChar or (count=1000) or error;    if Count = 1000 then      begin        error:=true;        DebugDialog(0,'Read byte 1000 error',0);      end;    TapeReadNibble := Ord(ch);  end;Function TapeReadByte(var Error:Boolean):Byte;var  N1,N2:byte;begin  N1:=TapeReadNibble(Error);  N2:=TapeReadNibble(Error);  if N1 < N2 then    TapeReadByte:= (N1-Ord('A'))*16+(N2-Ord('a'))  else    begin      N1:=TapeReadNibble(Error);      error:=true;      DebugDialog(0,'sync error',0);    end;end; procedure TapeReadFrame(var Frame:FrameType;                  var IDNumber : byte;                  var eventNumber:integer;                  Var Error:Boolean);   var    Found:Boolean;    WordCount:byte;    Count:integer;    i:integer;      begin    found:=False;    Count:=0;    repeat      begin        count:=Count+1;        if TapereadByte(Error) = 255 then          if TapereadByte(Error) = 255 then            begin              count:=0;              IDNumber:=TapereadByte(Error);              WordCount:=TapereadByte(Error);              EventNumber:=Tapereadbyte(Error)*256+Tapereadbyte(Error);              for i:= 1 to (WordCount-1)*2 do                Frame.FrameBuffer[i+(i mod 2)-((i+1) mod 2)]:=TapereadByte(Error);              Found:=False;              case IDNumber of                1:                  ;                2:                  ;                3:                  if Frame.EEFrame.EEID1=Frame.EEFrame.EEID2 then                     Found:=true;              end;            end;      end;    until found or (Count=100) or error;    if Count = 100 then      begin        error:=true;        DebugDialog(0,'Read Frame 100 error',0);      end;  end;    procedure TapeReadEvent{(var TheEvent:EventType;        Var Error:boolean)};     var      Frame:FrameType;      IdNumber:byte;      EventNumber:integer;      Count:Integer;      i:integer;          begin      TheEvent.TapeEvent.EventNumber:=0;      for i:=0 to 2 do        begin          TheEvent.TapeEvent.MWPCFrameFound[i]:=false;        end;      TheEvent.TapeEvent.EEFramefound:=false;            for i:=0 to 17 do        TheEvent.TapeEvent.EEDecode.EEValuesDecoded[i]:=false;              Count:=0;            repeat        begin          count:=Count+1;          if LastFrame.Found then            begin              Frame:=LastFrame.Frame;              EventNumber:=LastFrame.eventnumber;              IdNumber:=LastFrame.IdNumber;              TheEvent.TapeEvent.EventNumber:=EventNumber;              LastFrame.Found:=False;            end          else            TapeReadFrame(Frame,IdNumber,EventNumber,error);          if EventNumber=TheEvent.TapeEvent.EventNumber then            begin              case IdNumber of                0..2:                  begin                    TheEvent.TapeEvent.MWPCFrame[IdNumber]:=Frame.MWPC;                    TheEvent.TapeEvent.MWPCFrameFound[IdNumber]:=true;                  end;                3:                  begin                    TheEvent.TapeEvent.EEFrame:=Frame.EEFrame;                    TheEvent.TapeEvent.EEFramefound:=true;                  end;              end;            end          else            begin              LastFrame.Found:=True;              LastFrame.Frame:=Frame;              LastFrame.IdNumber:=IdNumber;              LastFrame.EventNumber:=EventNumber;            end;        end;     until LastFrame.found or (Count=10) or error;     if count=10 then      begin        Error:=True;        DebugDialog(0,'Read event 10 error',0);      end;   end;   beginend.