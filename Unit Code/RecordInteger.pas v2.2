unit RecordInteger(-22776);interface {$U-} {Use My own include Librarys} {$R DialogRsrc} {Load my reasources (dialog boxes etc..)} {$U Jim Surine:Programming:Units:My Units:Dialogs} {$I-} {$O Jim Surine:Programming:Units:My Units:RecordInteger} uses Memtypes,            {Basic types stanadard} QuickDraw,           {Quickdraw standard} OSIntf,              {Operating system standard} ToolIntf,            {Tools standard} PackIntf,            {Package stuff (List Manager, Decimal to string convert)} sane,                {For Real number conversions}  PasInOut,  Dialogs; const  RecordIntegerDisplayID = 26819 ;{RecordInteger Display parameters editing dialog}  RecordIntegerDataID = 23041 ; {RecordInteger Data parameters editing dialog}  RecordIntegerInfoID = 4871;    CurrNumberRecordedLimitRecordInteger = 5000;  NumberPerRecordLimitRecordInteger = 10;type    RecordIntegerDataType=        packed array[1..NumberPerRecordLimitRecordInteger] of Integer;    RecordIntegerDataSegmentHandle=        ^RecordIntegerDataSegmentPointer;    RecordIntegerDataSegmentPointer=        ^RecordIntegerDataSegmentType;    RecordIntegerDataSegmentType =  Packed record        RecordIntegerDataSegment:            packed array[1..CurrNumberRecordedLimitRecordInteger] of Integer;        NextRecordIntegerDataSegmentHandle:            RecordIntegerDataSegmentHandle;    end;      RecordIntegerInfoType =     record      NumberPerRecord : integer;      NumberToRecord:LongInt;      TypeOfData:Integer;      Title : array[0..NumberPerRecordLimitRecordInteger] of Str255;      Note : array[0..NumberPerRecordLimitRecordInteger] of Str255;      DrawOption : integer;    end;    RecordIntegerHandle=    ^RecordIntegerPointer;  RecordIntegerPointer=    ^RecordIntegerType;  RecordIntegerType =    record      RecordIntegerInfo : RecordIntegerInfoType;      NumberRecorded : LongInt;      Max,Min:Integer;      Mean,Standard:Real;      DataSegmentHandle : RecordIntegerDataSegmentHandle;      CurrNumberRecorded:longInt;      CurrDataSegmentHandle : RecordIntegerDataSegmentHandle;    end;  RecordIntegerAnalType = array [1..NumberPerRecordLimitRecordInteger] of    record      Number : LongInt;      Mean : real;      StandardDev : real;      Maximum : real;      Minimum : real;    end; procedure InitRecordInteger (var RecordInteger : RecordIntegerType;         ThePort:WindowPtr); procedure CloseRecordInteger (var RecordInteger : RecordIntegerType); procedure AddToRecordInteger (var RecordInteger : RecordIntegerType;         Numbers : RecordIntegerDataType;         ThePort:WindowPtr;         var error:Boolean);  procedure SetGetAddRecordInteger (var TheRecordInteger : RecordIntegerType;         var Numbers : RecordIntegerDataType;         Loc:LongInt;         SetGetAdd:Integer;         ThePort:WindowPtr);     procedure DrawRecordInteger (var TheRecordInteger : RecordIntegerType;            ThePort:WindowPtr);  Procedure SaveRecordIntegerAsText (var TheRecordInteger : RecordIntegerType;          Reply:SFReply;          var OutPut:Text); Procedure LoadRecordIntegerAsText (var TheRecordInteger : RecordIntegerType;          Reply:SFReply;          var Input:Text);  procedure RecordIntegerDisplayDialog (var TheRecordInteger : RecordIntegerType;            ThePort:WindowPtr);  procedure RecordIntegerDataDialog (var TheRecordInteger : RecordIntegerType;                                    ThePort:WIndowPtr); procedure RecordIntegerAnal(var RecordIntegerAnal:RecordIntegerAnalType;            var RecordInteger : RecordIntegerType); procedure RecordIntegerInfoDialog (var RecordInteger : RecordIntegerType);implementationprocedure CheckRecordInteger( var TheRecordInteger : RecordIntegerType); begin    if TheRecordInteger.RecordIntegerinfo.NumberPerRecord>NumberPerRecordLimitRecordInteger then        begin            TheRecordInteger.RecordIntegerinfo.NumberPerRecord:=NumberPerRecordLimitRecordInteger;            OKDialog('Number Per record Greater Than Limit');        end; end; procedure InitRecordInteger {(var RecordInteger : RecordIntegerType;         ThePort:WindowPtr)};     begin    CheckRecordInteger( RecordInteger);    RecordInteger.CurrDataSegmentHandle:=RecordIntegerDataSegmentHandle(NewHandle(SizeOf(RecordIntegerDataSegmentType)));    Hlock(Handle(RecordInteger.CurrDataSegmentHandle));    RecordInteger.CurrDataSegmentHandle^^.NextRecordIntegerDataSegmentHandle:=nil;    Hunlock(Handle(RecordInteger.CurrDataSegmentHandle));    RecordInteger.CurrNumberRecorded := 0;    RecordInteger.DataSegmentHandle:=RecordInteger.CurrDataSegmentHandle;    RecordInteger.NumberRecorded := 0; end; procedure CloseRecordInteger {(var RecordInteger : RecordIntegerType)};      var    TheDataSegmentHandle:RecordIntegerDataSegmentHandle;     begin    While RecordInteger.DataSegmentHandle<>nil do        begin            TheDataSegmentHandle:=RecordInteger.DataSegmentHandle;            HLock(Handle(TheDataSegmentHandle));            RecordInteger.DataSegmentHandle:=TheDataSegmentHandle^^.NextRecordIntegerDataSegmentHandle;            HUnlock(Handle(TheDataSegmentHandle));            DisposHandle(Handle(TheDataSegmentHandle));        end; end; procedure AddToRecordInteger {(var RecordInteger : RecordIntegerType;         Numbers : RecordIntegerDataType;         ThePort:WindowPtr;         var error:Boolean)};  var   i:integer;   TheDataSegmentHandle:RecordIntegerDataSegmentHandle;   OldPort:WindowPtr;    begin    GetPort(OldPort);    SetPort(ThePort);    error:=False;    with RecordInteger do        begin            if (RecordIntegerInfo.NumberToRecord > 0) then                begin                    HLock(Handle(CurrDataSegmentHandle));                    if (CurrNumberRecorded>=CurrNumberRecordedLimitRecordInteger-RecordIntegerInfo.NumberPerRecord) then                        begin                             ResrvMem( SizeOf(RecordIntegerDataSegmentType));                            if memError = noerr then                                begin                                    TheDataSegmentHandle:=CurrDataSegmentHandle;                                    CurrDataSegmentHandle^^.NextRecordIntegerDataSegmentHandle :=                                         RecordIntegerDataSegmentHandle(NewHandle(SizeOf(RecordIntegerDataSegmentType)));                                    CurrDataSegmentHandle:=CurrDataSegmentHandle^^.NextRecordIntegerDataSegmentHandle;                                    HLock(Handle(CurrDataSegmentHandle));                                    HUnlock(Handle(TheDataSegmentHandle));                                    CurrDataSegmentHandle^^.NextRecordIntegerDataSegmentHandle:=nil;                                    CurrNumberRecorded:=0;                                end                            else                                begin                                    RecordIntegerInfo.NumberToRecord:=0;                                    OKDialog('Memory Full in add to Record integer');                                end;                        end;                                        if RecordIntegerInfo.NumberToRecord > 0 then                        begin                            for i := 1 to RecordIntegerInfo.NumberPerRecord do                                begin                                    CurrNumberRecorded:=CurrNumberRecorded+1;                                    CurrDataSegmentHandle^^.RecordIntegerDataSegment[CurrNumberRecorded]:=Numbers[i];                                end;                            RecordIntegerInfo.NumberToRecord:=RecordIntegerInfo.NumberToRecord-1;                            NumberRecorded:=NumberRecorded+1;                        end;                                            HUnlock(Handle(CurrDataSegmentHandle));                end            else                Error:=True;        end;    SetPort(OldPort); end; procedure SetGetAddRecordInteger {(var TheRecordInteger : RecordIntegerType;         var Numbers : RecordIntegerDataType;         Loc:LongInt;         SetGetAdd:Integer;         ThePort:WIndowPtr)};  var    i:integer;    CurrCount:Integer;    NumberPerSegment,Segments:integer;    NextDataSegmentHandle,TheDataSegment:RecordIntegerDataSegmentHandle;    OldPort:WindowPtr;     begin      GetPort(OldPort);      SetPort(ThePort);     if TheRecordInteger.NumberRecorded <> 0 then         begin         If Loc>(TheRecordInteger.NumberRecorded) then            Loc:=TheRecordInteger.NumberRecorded;         If Loc<0 then            Loc:=0;                   NumberPerSegment:=TheRecordInteger.RecordIntegerinfo.NumberPerRecord             *(CurrNumberRecordedLimitRecordInteger div TheRecordInteger.RecordIntegerinfo.NumberPerRecord);                  CurrCount:=(Loc*TheRecordInteger.RecordIntegerinfo.NumberPerRecord) mod NumberPerSegment;                  Segments:=(Loc*TheRecordInteger.RecordIntegerinfo.NumberPerRecord) div NumberPerSegment;                  NextDataSegmentHandle:=TheRecordInteger.DataSegmentHandle;         for i:= 1 to Segments do            begin                HLock(Handle(NextDataSegmentHandle));                TheDataSegment:=NextDataSegmentHandle;                NextDataSegmentHandle:=TheDataSegment^^.NextRecordIntegerDataSegmentHandle;                HUnlock(Handle(TheDataSegment));            end;                     TheDataSegment:=NextDataSegmentHandle;         HLock(Handle(TheDataSegment));         for i:= 1 to TheRecordInteger.RecordIntegerInfo.NumberPerRecord do            begin                CurrCount:=CurrCount+1;                case SetGetAdd of                    0:TheDataSegment^^.RecordIntegerDataSegment[CurrCount]:=Numbers[i];                    1:Numbers[i]:=TheDataSegment^^.RecordIntegerDataSegment[CurrCount];                    2:begin                        TheDataSegment^^.RecordIntegerDataSegment[CurrCount]:=Numbers[i]                            +TheDataSegment^^.RecordIntegerDataSegment[CurrCount];                        Numbers[i]:=TheDataSegment^^.RecordIntegerDataSegment[CurrCount];                      end;                end;            end;                  HUnlock(Handle(TheDataSegment));     end;     SetPort(OldPort); end;Procedure SaveRecordIntegerAsText {(var TheRecordInteger : RecordIntegerType;          Reply:SFReply;          var OutPut:Text)};  var     i,j:integer;    CurrCount:Integer;    NextDataSegmentHandle,TheDataSegment:RecordIntegerDataSegmentHandle;    		begin			with TheRecordInteger do				begin					writeln(Output,RecordIntegerInfo.NumberToRecord);     writeln(Output,RecordIntegerInfo.NumberPerRecord);     writeln(Output,RecordIntegerInfo.Title);         writeln(Output,RecordIntegerInfo.DrawOption);     writeln(Output,NumberRecorded);     NextDataSegmentHandle:=TheRecordInteger.DataSegmentHandle;          i:=0;    While i<NumberRecorded do        begin            HLock(Handle(NextDataSegmentHandle));            TheDataSegment:=NextDataSegmentHandle;                        CurrCount:=0;            While (CurrCount< CurrNumberRecordedLimitRecordInteger-                RecordIntegerinfo.NumberPerRecord) and (i<TheRecordInteger.NumberRecorded) do                begin                   i:=i+1;                   for j:= 1 to TheRecordInteger.RecordIntegerInfo.NumberPerRecord do                        begin                            CurrCount:=CurrCount+1;                            write(OutPut,TheDataSegment^^.RecordIntegerDataSegment[CurrCount],chr(9));                        end;                    writeln(Output);                end;            NextDataSegmentHandle:=TheDataSegment^^.NextRecordIntegerDataSegmentHandle;            HUnlock(Handle(TheDataSegment));        end;				end;		end;Procedure LoadRecordIntegerAsText {(var TheRecordInteger : RecordIntegerType;          Reply:SFReply;          var InPut:Text)};  var     i,j:integer;    TheDataSegmentHandle,TheDataSegment:RecordIntegerDataSegmentHandle;    		begin   CloseRecordInteger(TheRecordInteger);			with TheRecordInteger do				begin					Readln(Input,RecordIntegerInfo.NumberToRecord);     Readln(Input,RecordIntegerInfo.NumberPerRecord);     Readln(Input,RecordIntegerInfo.Title);         Readln(Input,RecordIntegerInfo.DrawOption);     Readln(Input,NumberRecorded);          DataSegmentHandle:=RecordIntegerDataSegmentHandle(NewHandle(SizeOf(RecordIntegerDataSegmentType)));     CurrDataSegmentHandle:=DataSegmentHandle;     HLock(Handle(CurrDataSegmentHandle));     CurrDataSegmentHandle^^.NextRecordIntegerDataSegmentHandle:=nil;      HunLock(Handle(CurrDataSegmentHandle));           i:=0;     HLock(Handle(CurrDataSegmentHandle));     CurrNumberRecorded:=0;     While i<TheRecordInteger.NumberRecorded do         begin            i:=i+1;                        if (CurrNumberRecorded>=CurrNumberRecordedLimitRecordInteger-RecordIntegerInfo.NumberPerRecord) then               begin                    ResrvMem( SizeOf(RecordIntegerDataSegmentType));                   if memError = noerr then                       begin                           TheDataSegmentHandle:=CurrDataSegmentHandle;                           CurrDataSegmentHandle^^.NextRecordIntegerDataSegmentHandle :=                                RecordIntegerDataSegmentHandle(NewHandle(SizeOf(RecordIntegerDataSegmentType)));                           CurrDataSegmentHandle:=CurrDataSegmentHandle^^.NextRecordIntegerDataSegmentHandle;                           HLock(Handle(CurrDataSegmentHandle));                           HUnlock(Handle(TheDataSegmentHandle));                           CurrDataSegmentHandle^^.NextRecordIntegerDataSegmentHandle:=nil;                           CurrNumberRecorded:=0;                       end                   else                       begin                           RecordIntegerInfo.NumberToRecord:=0;                           OKDialog('Memory Full in add to Record integer');                       end;               end;            for j:= 1 to TheRecordInteger.RecordIntegerInfo.NumberPerRecord do                 begin                     CurrNumberRecorded:=CurrNumberRecorded+1;                     Read(Input,CurrDataSegmentHandle^^.RecordIntegerDataSegment[CurrNumberRecorded]);                 end;             Readln(Input);         end;       HUnlock(Handle(CurrDataSegmentHandle));     end;		end; procedure DrawRecordInteger {(var TheRecordInteger : RecordIntegerType;  ThePort:WIndowPtr)};  var   Box : rect;   Title:str255;   seconds:longint;   TheString:Str255;   OldPort:WindowPtr;     begin   GetPort(OldPort);   SetPort(ThePort);   Box:=ThePort^.portRect;   Box.Bottom:=Box.Bottom-15;   Box.Top:=Box.Bottom-30;   box.right:=Box.Right-15;   Title:=TheRecordInteger.RecordIntegerInfo.title;   GetDateTime(Seconds);   IUDateString(Seconds,shortdate,TheString);   Title:=Title+' Last recorded '+TheString;   IUTimeString(Seconds,false,TheString);   Title:=Title+' '+TheString;      NumToString(TheRecordInteger.NumberRecorded,TheSTring);   Title:=Title+' Number recorded '+TheString;      TextBox(POINTER(ORD(@Title) + 1), Length(Title), Box, TEJustCenter);   SetCursor(Arrow);   SetPort(OldPort);  end;  procedure SetGetRecordIntegerDisplayDialog (var TheRecordInteger : RecordIntegerType;         var DialogPointer : DialogPtr;         SetGet : boolean); begin  with TheRecordInteger.RecordIntegerinfo do   begin    setGetDlgLongInt(3, NumberToRecord, DialogPointer, SetGet);    SetgetDlgStr255(4, Title, DialogPointer, SetGet);    SelectText(DialogPointer,3);   end; end; procedure RecordIntegerDisplayDialog {(var TheRecordInteger : RecordIntegerType;            ThePort:WindowPtr)};  var   DialogPointer : DialogPtr;  OldPort:WindowPtr;   begin  GetPort(oldPort);  DialogPointer := GetNewDialog(RecordIntegerDisplayID, nil, pointer(-1));  SetGetRecordIntegerDisplayDialog(TheRecordInteger, dialogPointer, true);  ShowHide(DialogPointer, true);  Modal( OKCancelType, DialogPointer);  if not cancelButton then   SetGetRecordIntegerDisplayDialog(TheRecordInteger, DialogPointer, false);  DisposDialog(DialogPointer);  CheckRecordInteger( TheRecordInteger);  SetPort(OldPort); end; procedure SetGetRecordIntegerDataDialog (var TheRecordInteger : RecordIntegerType;         var DialogPointer : DialogPtr;         SetGet : boolean); begin  with TheRecordInteger.RecordIntegerinfo do   begin    setGetDlgLongInt(3, NumberToRecord, DialogPointer, SetGet);    setGetDlginteger(4, NumberPerRecord, DialogPointer, SetGet);    SelectText(DialogPointer,3);   end; end; procedure RecordIntegerDataDialog { (var TheRecordInteger: RecordIntegerType;                    ThePort:WindowPtr)};  var   DialogPointer : DialogPtr;   OldPort:WindowPtr;   begin  GetPort(OldPort);  DialogPointer := GetNewDialog(RecordIntegerDataID, nil, pointer(-1));  SetGetRecordIntegerDataDialog(TheRecordInteger, dialogPointer, true);  ShowHide(DialogPointer, true);  Modal( OKCancelType, DialogPointer);  if not CancelButton then    begin      OKCancelDialog('Changing a RecordIntegers data ranges erases the RecordInteger');      if not CancelButton then          begin            SetGetRecordIntegerDataDialog(TheRecordInteger, DialogPointer, false);            CloseRecordInteger(TheRecordInteger);            InitRecordInteger(TheRecordInteger,ThePOrt);          end;    end;  DisposDialog(DialogPointer);  CheckRecordInteger(TheRecordInteger);  SetPort(oldPort); end;  procedure RecordIntegerAnal{(var RecordIntegerAnal:RecordIntegerAnalType;            var RecordInteger : RecordIntegerType)};   var    i,j,CurrCount:integer;    TheValue:real;    NextDataSegmentHandle,TheDataSegment:RecordIntegerDataSegmentHandle;      begin    for i:=1 to RecordInteger.RecordIntegerInfo.NumberPerRecord do      begin        RecordIntegerAnal[i].Mean:=0;        RecordIntegerAnal[i].Maximum:=-inf;        RecordIntegerAnal[i].Minimum:=inf;        RecordIntegerAnal[i].StandardDev:=0;        RecordIntegerAnal[i].Number:=RecordInteger.NumberRecorded      end;           NextDataSegmentHandle:=RecordInteger.DataSegmentHandle;     i:=0;    While i<RecordInteger.NumberRecorded do        begin            HLock(Handle(NextDataSegmentHandle));            TheDataSegment:=NextDataSegmentHandle;                        CurrCount:=0;            While (CurrCount< CurrNumberRecordedLimitRecordInteger-                RecordInteger.RecordIntegerinfo.NumberPerRecord) and (i<RecordInteger.NumberRecorded) do                begin                   i:=i+1;                   for j:= 1 to RecordInteger.RecordIntegerInfo.NumberPerRecord do                        begin                            CurrCount:=CurrCount+1;                                                        TheValue:=TheDataSegment^^.RecordIntegerDataSegment[CurrCount];                                                        if TheValue>RecordIntegerAnal[j].Maximum then                              RecordIntegerAnal[j].Maximum:=TheValue;                            if TheValue<RecordIntegerAnal[j].Minimum then                              RecordIntegerAnal[j].Minimum:=TheValue;                                                        RecordIntegerAnal[j].Mean:=RecordIntegerAnal[j].Mean+TheValue;                            RecordIntegerAnal[j].StandardDev:=RecordIntegerAnal[j].StandardDev+TheValue*TheValue;                        end;                end;            NextDataSegmentHandle:=TheDataSegment^^.NextRecordIntegerDataSegmentHandle;            HUnlock(Handle(TheDataSegment));        end;                   for i:=1 to RecordInteger.RecordIntegerInfo.NumberPerRecord do      RecordIntegerAnal[i].Mean:=RecordIntegerAnal[i].Mean/RecordInteger.NumberRecorded;        for i:=1 to RecordInteger.RecordIntegerInfo.NumberPerRecord do      RecordIntegerAnal[i].StandardDev:=        Sqrt((RecordIntegerAnal[i].StandardDev/RecordInteger.NumberRecorded)            -(RecordIntegerAnal[i].Mean*RecordIntegerAnal[i].Mean));   end;    procedure SetGetRecordIntegerInfoDialog (var TheRecordIntegerAnal : RecordIntegerAnalType;         var DialogPointer : DialogPtr;         SetGet : boolean;         WhichOne:integer);     begin            setGetDlgReal(2, TheRecordIntegerAnal[WhichOne].Mean, DialogPointer, SetGet);    setGetDlgReal(3, TheRecordIntegerAnal[WhichOne].standardDev, DialogPointer, SetGet);    setGetDlgReal(4, TheRecordIntegerAnal[WhichOne].Maximum, DialogPointer, SetGet);    setGetDlgReal(5, TheRecordIntegerAnal[WhichOne].minimum, DialogPointer, SetGet);    setGetDlgLongInt(6, TheRecordIntegerAnal[WhichOne].number, DialogPointer, SetGet);  end; procedure RecordIntegerInfoDialog { (var RecordInteger : RecordIntegerType)};  var    DialogPointer : DialogPtr;    i:integer;    TheRecordIntegerAnal:RecordIntegerAnalType;    OldPort:WindowPtr;     begin  GetPort(OldPort);  RecordIntegerAnal(TheRecordIntegerAnal,RecordInteger);  for i:= 1 to RecordInteger.RecordIntegerInfo.NumberPerRecord do    begin      DialogPointer := GetNewDialog(RecordIntegerinfoID, nil, pointer(-1));      SetGetRecordIntegerinfoDialog(TheRecordIntegerAnal, dialogPointer, true,i);      ShowHide(DialogPointer, true);      Modal( OKType, DialogPointer);      DisposDialog(DialogPointer);    end;   SetPort(OldPort); end; begin end.