unit Dialogs(-67);{Some Helpful routines for accessing dialog boxes}interface {$U-} {Use My own include Librarys} {$R-} {use my own Resources} {$R DialogRsrc} {Load my reasources (dialog boxes etc..)} {$O Jim Surine:Programming:Units:My Units:Dialogs}uses Memtypes,            {Basic types stanadard} QuickDraw,           {Quickdraw standard} OSIntf,              {Operating system standard} ToolIntf,            {Tools standard} PackIntf,            {Package stuff (List Manager, Decimal to string convert)} sane;                {For Real number conversions}const OKType = 1000; OKCancelType = 1001; YesNoCancelType = 1002; ManyButtonType = 1003; ManyItemType = 1004;  SetDialog=True; GetDialog=False;  {Dialog Reasouce Numbers}  DebugDialogID = 6002; YesNoCancelID = 25991; OKCancelID = 9325; OKID = 24819; EditMenuID = 302;	 	{ the Edit menu standard constants} UndoItemID = 1; CutItemID = 3; CopyItemID = 4; PasteItemID = 5; ClearItemID = 6;type  MoveType=record             Move:real;             PercentAbsolute:Boolean;           end;           var OKButton : Boolean;                {True if an OK Button Was Pushed} CancelButton : Boolean;            {True if an Cancel Button Was Pushed} YesButton : Boolean;               {True if an Yes Button Was Pushed} NoButton : Boolean;                {True if an No Button Was Pushed} ButtonHit :integer;                {Number of Button Hit for many Button}  CheckBoxSingle:Boolean; RadioSingle:Boolean;  CommandKeyLetter:Boolean;  UseMenus:boolean; UseKeys:boolean;  NumberOfDialogItems:integer;       {Number of Items to scan}  Dialogformat : DecForm;            {Real Number Output Format}  PageUpDown:MoveType; ArrowUpDown:MoveType;  TraceDialogPointer:DialogPtr; TempDialogPointer : DialogPtr;PROCEDURE DrawOKDefault(theDialog: DialogPtr; theItem: INTEGER);procedure SetGetDlgBoolean (Item : integer;        var TheBoolean : Boolean;        DialogPointer : DialogPtr;        SetGet : Boolean);procedure SetGetDlgRadioCheckRange (var TheRadio : integer;        DialogPointer : DialogPtr;        SetGet : boolean;        StartItem,EndItem:Integer);procedure SetGetDlgRadioCheckBits (var TheCheck : integer;        DialogPointer : DialogPtr;        SetGet : boolean;        StartItem,EndItem:Integer);procedure SetGetDlgCtrlValue (Item : integer;        var TheValue : integer;        DialogPointer : DialogPtr;        SetGet : boolean);procedure SetGetDlgCtrlMaxMin (Item : integer;        var TheMin ,TheMax : Integer;        DialogPointer : DialogPtr;        setget:Boolean);procedure SetGetDlgCtrlTitle (Item : integer;        var TheTitle : str255;        DialogPointer : DialogPtr;        setget:Boolean);procedure SetGetDlgStr255 (Item : integer;        var TheString : str255;        DialogPointer : DialogPtr;        SetGet : Boolean);procedure SetGetDlgInteger (Item : integer;        var theInteger : integer;        DialogPointer : DialogPtr;        SetGet : Boolean);procedure SetGetDlgLongInt (Item : integer;        var theLongInt : LongInt;        DialogPointer : DialogPtr;        SetGet : Boolean);procedure SetGetDlgReal (Item : integer;        var theReal : Real;        DialogPointer : DialogPtr;        SetGet : Boolean);Procedure MyDialogFilterTasks;procedure Modal ( button : Integer;        DialogPointer : DialogPtr);procedure SelectText (DialogPointer : DialogPtr;        Item : Integer);procedure YesNoCancelDialog (TheString : Str255);procedure OKCancelDialog (TheString : Str255);procedure OKDialog (TheString : Str255);procedure DebugDialog (TheInteger1 : integer;        TheString1 : str255;        TheInteger2 : integer);procedure TraceDialog (TheInteger1 : integer;        TheString1 : str255;        TheInteger2 : integer);implementationPROCEDURE DrawOKDefault{(theDialog: DialogPtr; theItem: INTEGER)};VAR savePen: PenState;theType:integer;theHdl:Handle;theBox:Rect;BEGIN	GetPenState(savePen); {save the old pen state}		GetDItem(theDialog, theItem, theType, theHdl, theBox); {get the item’s rect}	PenSize(3,3); {make the pen fatter}	FrameRoundRect(theBox,16,16); {draw the ring}	SetPenState(savePen); {restore the pen state}END; {DrawOKDefault}{These are the set get routines used to set and get data from dialog boxes}{Given then item number and the dialog pointer Set true Get False}procedure SetGetDlgBoolean {(Item : integer;        var TheBoolean : Boolean;        DialogPointer : DialogPtr;        SetGet : Boolean)};{Checks or unchecks checkboxes, dots or undots radio buttons, True or false} var  ItemType : integer;  TheHandle : Handle;  Box : rect;  TheControl : ControlHandle;begin GetDItem(DialogPointer, Item, ItemType, TheHandle, Box); if (ItemType = CtrlItem+RadCtrl) or (ItemType = CtrlItem+ChkCtrl) then  begin   TheControl := controlhandle(TheHandle);   if SetGet then    begin     if TheBoolean then      SetCtlValue(TheControl, 1)     else      SetCtlValue(TheControl, 0)    end   else    begin     if GetCtlValue(TheControl) = 1 then      TheBoolean := True     else      TheBoolean := False;    end;  end else  sysbeep(10);end;procedure SetGetDlgRadioCheckRange {(var TheRadio : integer;        DialogPointer : DialogPtr;        SetGet : boolean;        StartItem,EndItem:integer)};{Sets the TheRadio number radio button in a dialog box and unsets all others}{or gets the number of the first set radio button in a dialogbox}{not posistion dependant} var  ItemType : integer;  TheHandle : Handle;  Box : rect;  TheControl : ControlHandle;  LoopCount : integer;  Count : Integer;begin count := 0; for LoopCount := StartItem to EndItem do  begin   GetDItem(DialogPointer, LoopCount, ItemType, TheHandle, Box);   TheControl := ControlHandle(TheHandle);   if (ItemType = CtrlItem+RadCtrl) or (ItemType = CtrlItem+ChkCtrl) then    begin     if Setget then           if Count <> TheRadio then       SetCtlValue(TheControl, 0)      else       SetCtlValue(TheControl, 1)            else       if GetCtlValue(TheControl) = 1 then        TheRadio := Count;           Count:=Count+1;    end;  end;end;procedure SetGetDlgRadioCheckBits {(var TheCheck : integer;        DialogPointer : DialogPtr;        SetGet : boolean;        startItem,EndItem:integer)};{Sets the TheCheck number Check Box in a dialog box and unsets all others}{or gets the number of the first set Check Box in a dialogbox}{not posistion dependant} var  ItemType : integer;  TheHandle : Handle;  Box : rect;  TheControl : ControlHandle;  LoopCount : integer;  Count : Integer;begin count := 0; for LoopCount := startItem to EndItem do  begin   GetDItem(DialogPointer, LoopCount, ItemType, TheHandle, Box);   TheControl := ControlHandle(TheHandle);   if ItemType = CtrlItem+ChkCtrl then    begin     if Setget then           if Count <> TheCheck then       SetCtlValue(TheControl, 0)      else       SetCtlValue(TheControl, 1)            else       if GetCtlValue(TheControl) = 1 then        TheCheck := Count;           Count:=Count+1;    end;  end;end;procedure SetGetDlgCtrlValue {(Item : integer;        var TheValue : integer;        DialogPointer : DialogPtr;        SetGet : boolean)};{Sets The controls value like a scroll bar} var  ItemType : integer;  TheHandle : Handle;  Box : rect;  TheControl : ControlHandle;begin GetDItem(DialogPointer, Item, ItemType, TheHandle, Box); TheControl := ControlHandle(TheHandle); if ItemType = CtrlItem+ResCtrl then   if Setget then    SetCtlValue(TheControl, TheValue)   else     TheValue:= GetCtlValue(TheControl)  else  sysbeep(10);end;procedure SetGetDlgCtrlMaxMin {(Item : integer;        var TheMin, TheMax : Integer;        DialogPointer : DialogPtr;        SetGet : boolean)};{Sets The controls Max and Min Values like a scroll bar} var  ItemType : integer;  TheHandle : Handle;  Box : rect;  TheControl : ControlHandle;begin GetDItem(DialogPointer, Item, ItemType, TheHandle, Box); TheControl := ControlHandle(TheHandle); if ItemType = CtrlItem+ResCtrl then     if Setget then        begin            SetCtlMin(TheControl, TheMin);            SetCtlMax(TheControl, TheMax);        end   else     begin        TheMin:= getCtlMin(TheControl) ;        TheMax:= getCtlMax(TheControl)     end else  sysbeep(10);end;procedure SetGetDlgCtrlTitle {(Item : integer;        var TheTitle : str255;        DialogPointer : DialogPtr;        SetGet:Boolean)};{Sets The controls Max and Min Values like a scroll bar} var  ItemType : integer;  TheHandle : Handle;  Box : rect;  TheControl : ControlHandle;begin GetDItem(DialogPointer, Item, ItemType, TheHandle, Box); TheControl := ControlHandle(TheHandle); if (ItemType = CtrlItem+ChkCtrl) or (ItemType = CtrlItem+RadCtrl)    or (ItemType = CtrlItem+BtnCtrl) or (ItemType = CtrlItem+ResCtrl)then    if Setget then        SetCTitle(TheControl, TheTitle)   else         GetCTitle(TheControl,TheTitle );end;procedure SetGetDlgInteger {(Item : integer;        var theInteger : integer;        DialogPointer : DialogPtr;        SetGet : Boolean)};{works with integers} var  ItemType : integer;  TextHandle : Handle;  Box : rect;  TheString : str255;  TheLongInt : LongInt;begin GetDItem(DialogPointer, item, ItemType, TextHandle, Box); if (ItemType = StatText) or (ItemType=EditText) then  if SetGet then   begin    TheLongInt := TheInteger;    NumToString(TheLongInt, TheString);    SetItext(TextHandle, TheString);   end  else   begin    GetItext(TextHandle, TheString);    StringtoNum(TheString, TheLongInt);    TheInteger := TheLongInt;   end else  sysbeep(10);end;procedure SetGetDlgLongInt {(Item : integer;        var theLongInt : LongInt;        DialogPointer : DialogPtr;        SetGet : Boolean)};{Works with long integers} var  ItemType : integer;  TextHandle : Handle;  Box : rect;  TheString : str255;begin GetDItem(DialogPointer, item, ItemType, TextHandle, Box); if (ItemType = StatText) or (ItemType=EditText) then  if SetGet then   begin    NumToString(TheLongInt, TheString);    SetItext(TextHandle, TheString);   end  else   begin    GetItext(TextHandle, TheString);    StringtoNum(TheString, TheLongInt);   end else  sysbeep(10);end;procedure SetGetDlgStr255 {(Item : integer;        var TheString : str255;        DialogPointer : DialogPtr;        SetGet : Boolean)};{Works with strings} var  ItemType : integer;  TextHandle : Handle;  Box : rect;begin GetDItem(DialogPointer, Item, ItemType, TextHandle, Box); if (ItemType = StatText) or (ItemType=EditText) then  if SetGet then   SetItext(TextHandle, TheString)  else   GetItext(TextHandle, TheString) else  sysbeep(10);end;procedure SetGetDlgReal {(Item : integer;        var theReal : Real;        DialogPointer : DialogPtr;        SetGet : Boolean)};{Works with Reals} var  ItemType : integer;  TextHandle : Handle;  Box : rect;  TheString : str255;begin GetDItem(DialogPointer, item, ItemType, TextHandle, Box); if (ItemType = StatText) or (ItemType=EditText) then  if SetGet then   begin    Num2Str(Dialogformat, TheReal, TheString);    SetItext(TextHandle, TheString);   end  else   begin    GetItext(TextHandle, TheString);    TheReal := Str2Num(TheString);   end else  sysbeep(10);end;procedure SelectText {(DialogPointer : DialogPtr;        Item : Integer)};{Selects the desired text box, like the first one before giving it to the user} var  ItemType : integer;  TextHandle : Handle;  Box : rect;  TheString : str255;begin GetDItem(DialogPointer, item, ItemType, TextHandle, Box); GetItext(TextHandle, TheString); SelIText(DialogPointer, item, 0, MaxInt);end;{Procedures for Filter, They must be global for Filter to access them}procedure DoDialogMenuChoice (MenuChoice : LongInt); var  TheMenu : integer;  TheItem : integer;  TheDialog : DialogPtr;begin TheDialog := DialogPtr(FrontWindow); if menuChoice <> 0 then  begin   theMenu := HiWord(MenuChoice);   TheItem := LoWord(MenuChoice);   case TheMenu of    EditMenuID :      case TheItem of      CutItemID :        DlgCut(TheDialog);      CopyItemID :        DlgCopy(TheDialog);      PasteItemID :        DlgPaste(TheDialog);      ClearItemID :        DlgDelete(TheDialog);     end;   end;   HiliteMenu(0);  end;end;procedure DealWithDialogMouseDowns (var theEvent : EventRecord); var  WindowPointedTo : WindowPtr;  windowLoc : integer;  MenuChoice : LongInt;begin windowLoc := FindWindow(theEvent.where, windowPointedTo); case windowLoc of  inMenuBar :    if UseMenus then    begin    MenuChoice := MenuSelect(TheEvent.where);    DoDialogMenuChoice(MenuChoice);   end;  inContent:    begin          end; end;end;Procedure DealWithDialogItemSelect(var TheDialog:DialogPtr;                             var TheEvent:EventRecord;                             var itemNumber:Integer;                             ThePart:integer);  var      ItemType : integer;      TheHandle : Handle;      Box : rect;      LoopCount : integer;      pageMove:integer;      ArrowMove:integer;      Range:integer;      inRange:Boolean;      TheValue:integer;      TheControl:ControlHandle;        begin    GetDItem(TheDialog, ItemNumber, ItemType, TheHandle, Box);    TheControl := ControlHandle(TheHandle);    if thePart in [inUpButton,inDownButton,inPageUp,inPageDown,inthumb] then      begin        Range:=GetCtlMax(TheControl)-GetCtlMin(TheControl);        if PageUpDown.PercentAbsolute then          PageMove:=trunc(Range*PageUpDown.Move)        else          PageMove:=trunc(PageUpDown.Move);        if ArrowUpDown.PercentAbsolute then          ArrowMove:=Trunc(Range*ArrowUpDown.Move)        else          ArrowMove:=trunc(ArrowUpDown.Move);        case thepart of         inUpButton:                    if  LongInt(GetCtlValue(TheControl))-arrowMove >= GetCtlMin(TheControl) then                        SetCtlValue(TheControl, GetCtlValue(TheControl)-arrowMove)                    else                         SetCtlValue(TheControl, GetCtlMin(TheControl));         inDownButton:                    if LongInt(GetCtlValue(TheControl))+arrowMove <= GetCtlMax(TheControl) then                        SetCtlValue(TheControl, GetCtlValue(TheControl)+arrowMove)                    else                         SetCtlValue(TheControl, GetCtlMax(TheControl));         inPageUp:                    if LongInt(GetCtlValue(TheControl))-pageMove >= GetCtlMin(TheControl) then                        SetCtlValue(TheControl, GetCtlValue(TheControl)-pageMove)                    else                         SetCtlValue(TheControl, GetCtlMin(TheControl));         inPageDown:                    if  longInt(GetCtlValue(TheControl))+pageMove  <= GetCtlMax(TheControl) then                        SetCtlValue(TheControl, GetCtlValue(TheControl)+pageMove)                    else                         SetCtlValue(TheControl, GetCtlMax(TheControl));        end;        TheValue:=GetCtlValue(TheControl);        GetDItem(TheDialog, ItemNumber+1, ItemType, TheHandle, Box);        If (ItemType = StatText) or (ItemType = EditText) then            SetGetDlginteger(ItemNumber+1,TheValue , TheDialog,True);      end;         GetDItem(TheDialog, ItemNumber, ItemType, TheHandle, Box);    TheControl := ControlHandle(TheHandle);    if (CheckBoxSingle and (ItemType=CtrlItem+ChkCtrl)) or (RadioSingle and (ItemType=CtrlItem+RadCtrl)) then      SetCtlValue(TheControl, 1 - GetCtlValue(TheControl))    else     if (not CheckBoxSingle and (ItemType=CtrlItem+ChkCtrl)) or (not RadioSingle and (ItemType=CtrlItem+RadCtrl)) then      begin       inRange:=True;       for LoopCount := ItemNumber to NumberOfDialogItems do        begin         GetDItem(TheDialog, LoopCount, ItemType, TheHandle, Box);         TheControl := ControlHandle(TheHandle);         if ((ItemType = CtrlItem+RadCtrl) or (ItemType = CtrlItem+ChkCtrl)) and inRange then           if LoopCount <> ItemNumber then             SetCtlValue(TheControl, 0)           else             SetCtlValue(TheControl, 1)         else           inRange:=False;        end;                inRange:=True;       for LoopCount := ItemNumber downto 0 do        begin         GetDItem(TheDialog, LoopCount, ItemType, TheHandle, Box);         TheControl := ControlHandle(TheHandle);         if ((ItemType = CtrlItem+RadCtrl) or (ItemType = CtrlItem+ChkCtrl)) and inRange then           if LoopCount <> ItemNumber then             SetCtlValue(TheControl, 0)           else             SetCtlValue(TheControl, 1)         else           inRange:=False;        end;      end;    end;   procedure DealWithDialogKeyDowns (var theEvent : EventRecord;        var TheFilter : Boolean;        var ItemNumber : integer;        var TheDialog:DialogPtr); const  returnCode = 13;  {Return}  enterCode = 3;    {Enter}  CancelCode = 27;  {BackSpace} var  CharCode : integer;  ch : Char;  MenuChoice : longint;    i:integer;    TheTitle:str255;    ITEMFound:Boolean;    begin with TheEvent do  begin   charCode := BitAnd(Message, CharCodeMask);   ch := chr(CharCode);   if BitAnd(theEvent.modifiers, CmdKey) <> 0 then    begin            {Do this manually because some programs don't have menus}               if (ch in ['C','X','V','B','c','x','v','b']) and UseKeys then         begin         case ch of          'X','x' :            DlgCut(TheDialog);          'C','c' :            DlgCopy(TheDialog);          'V','v' :            DlgPaste(TheDialog);          'B','b' :            DlgDelete(TheDialog);         end;         TheFilter:=True;         end       else        if CommandKeyLetter then         begin          ITEMfound:=false;          i:=0;         While (i<= NumberOfDialogItems) and (Not Itemfound) do             begin                 i:=i+1;                 SetGetDlgCtrlTitle (i,TheTitle,TheDialog,GetDialog);                 if IUEqualString(TheTitle[1],ch)= 0 then                    begin                     ItemNumber:=i;                     ITEMfound:=true;                     TheFilter := true;                    end;             end;            if ITEMFound then                DealWithDialogItemSelect(TheDialog,TheEvent,ItemNumber,0);           end;    end   else    begin     if ch = chr(returnCode) then      begin       itemNumber := 1;       TheFilter := true;      end;     if ch = chr(CancelCode) then      begin       itemNumber := 2;       TheFilter := true;      end;     if ch = chr(enterCode) then      begin       message := message + 6;       TheFilter := false;      end;    end;  end;end;Procedure MyDialogFilterTasks;begin;end;function Filter (TheDialog : DialogPtr;        var theEvent : EventRecord;        var itemNumber : Integer) : Boolean; var  TheFilter : Boolean;  TheControl:ControlHandle;  thePart:integer;  begin TheFilter := false; case theEvent.what of  mouseDown:    begin    DealWithDialogMouseDowns(theEvent);     if IsDialogEvent(TheEvent) then      begin        SetPort(WindowPtr(TheDialog));        GlobalToLocal(TheEvent.Where);        thePart:=FindControl(TheEvent.Where,WindowPtr(TheDialog),TheControl);        LocalToGlobal(TheEvent.Where);       if DialogSelect(TheEvent, TheDialog, itemNumber) then          DealWithDialogItemSelect(TheDialog,TheEvent,ItemNumber,ThePart);       TheFilter := True;      end;   end;  KeyDown, autoKey :    DealWithDialogKeyDowns(theEvent, TheFilter, ItemNumber,TheDialog); end;  MyDialogFilterTasks; filter := TheFilter;end;{Button Procedures for Modal}procedure OKOnlyButton (ItemHit : integer;        var Done : Boolean;        DialogPointer : DialogPtr);begin if itemHit =1 then   begin    OKButton := True;    Done := true;   end;end;procedure OKCancelButton (ItemHit : integer;        var Done : Boolean;        DialogPointer : DialogPtr);begin case itemHit of  1 :    begin    OKButton := True;    Done := true;   end;  2 :    begin    done := true;    CancelButton := true;   end; end;end;procedure YesNoCancelButton (ItemHit : integer;        var Done : Boolean;        DialogPointer : DialogPtr);begin case itemHit of  1 :    begin    YesButton := True;    Done := true;   end;  2 :    begin    done := true;    NoButton := true;   end;  3 :    begin    done := true;    CancelButton := true;   end; end;end;procedure ManyButton (ItemHit : integer;        var Done : Boolean;        DialogPointer : DialogPtr);  var  ItemType : integer;  TheHandle : Handle;  Box : rect;  TheControl : ControlHandle;  LoopCount : integer;  Count : Integer;begin count := 0; for LoopCount := 0 to NumberOfDialogItems do  begin   GetDItem(DialogPointer, LoopCount, ItemType, TheHandle, Box);   if ItemType = ctrlItem+BtnCtrl then    begin     if LoopCount = itemHit then       begin         ButtonHit := Count;         Done:=True;       end;     count := Count + 1;    end;  end;end;procedure Modal {(button : Integer;        DialogPointer : DialogPtr)};{Call this procedure to handle dialogs, Give it the right button code and{The Variables OKButton,CancleButton,YesButton,NoButton will be set}{Enter key is the tab key}{Cut copy Paste Clear are keyboard and mouse active} var  itemHit : integer;  Done : boolean;  ItemType : integer;  TheHandle : Handle;  Box : rect;  TempPort:WindowPtr;  begin HiliteMenu(0); {Get Rid of Any Menu Hiliting}  cancelButton := false; {No Buttons Pushed Yet} YesButton := False; NoButton := False; OkButton :=False; ButtonHit := 0;  done := false; {Not Done Yet just started}  repeat  begin {repeat}   ModalDialog(@Filter, itemHit);   case Button of    OKType :      OKOnlyButton(ItemHit, Done, DialogPointer);    OKCancelType :      OKCancelButton(ItemHit, Done, DialogPointer);    YesNoCancelType :      YesNoCancelButton(ItemHit, Done, DialogPointer);    ManyButtonType:     ManyButton(ItemHit,Done,DialogPointer);    ManyItemType:      begin        ButtonHit:=ItemHit;        Done:=True;      end;   end;  end;{repeat} until done;end;{dialog}procedure YesNoCancelDialog;{(TheString:Str255)}{Standard ask user yes no question}begin TempDialogPointer:= GetNewDialog(YesNoCancelID, nil, pointer(-1)); SetGetDlgStr255(4, TheString, TempDialogPointer, SetDialog); ShowHide(TempDialogPointer, true); DrawOKDefault(TempDialogPointer,1); Modal(YesNoCancelType, TempDialogPointer); DisposDialog(TempDialogPointer);end;procedure OKCancelDialog;{(TheString:Str255)}{Stadard ask user something}begin TempDialogPointer := GetNewDialog(OKCancelID, nil, pointer(-1)); SetGetDlgStr255(3, TheString, TempDialogPointer, SetDialog); ShowHide(TempDialogPointer, true); DrawOKDefault(TempDialogPointer,1); Modal(OKCancelType, TempDialogPointer); DisposDialog(TempDialogPointer);end;procedure OKDialog;{(TheString:Str255)}{Standard tell user something}begin TempDialogPointer := GetNewDialog(OKID, nil, pointer(-1)); SetGetDlgStr255(2, TheString, TempDialogPointer, SetDialog); ShowHide(TempDialogPointer, true); DrawOKDefault(TempDialogPointer,1); Modal(OKType, TempDialogPointer); DisposDialog(TempDialogPointer);end;procedure DebugDialog {(TheInteger1 : integer;        TheString1 : str255;        TheInteger2 : integer)};{Use it for debugging}begin TempDialogPointer := GetNewDialog(DebugDialogID, nil, pointer(-1)); SetGetDlgInteger(3, TheInteger1, TempDialogPointer, SetDialog); SetGetDlgstr255(4, TheString1, TempDialogPointer, SetDialog); SetGetDlgInteger(5, TheInteger2, TempDialogPointer, SetDialog); Modal(OKType, TempDialogPointer); DisposDialog(TempDialogPointer);end;procedure TraceDialog {(TheInteger1 : integer;        TheString1 : str255;        TheInteger2 : integer)};{Use it for debugging}begin if TraceDialogPointer = nil then    TraceDialogPointer := GetNewDialog(DebugDialogID, nil, pointer(-1)); SetGetDlgInteger(3, TheInteger1, TraceDialogPointer, SetDialog); SetGetDlgstr255(4, TheString1, TraceDialogPointer, SetDialog); SetGetDlgInteger(5, TheInteger2, TraceDialogPointer, SetDialog);end;begin  OKButton :=False;  CancelButton := False;  YesButton :=False;  NoButton :=False;  ButtonHit :=0;    CheckBoxSingle:=True;  RadioSingle:=False;    CommandKeyLetter:=True;    UseKeys:=true;  UseMenus:=False;    NumberOfDialogItems:=100;  Dialogformat.Style := Fixeddecimal; {Fixeddecimal or FloatDecimal}  DialogFormat.digits := 5;    PageUpDown.Move:=0.3;  PageUpDown.PercentAbsolute:=True;    ArrowUpDown.Move:=0.1;  ArrowUpDown.PercentAbsolute:=true;    TraceDialogPointer:=Nil;end.