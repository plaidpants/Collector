unit SerialPort(-67);interface {$U-} {Use My own include Librarys} {$R-} {use my own Resources} {$R AccessRsrc} {Load my reasources (dialog boxes etc..)} {$O Jim Surine:Programming:Units:My Units:Access}uses Memtypes,            {Basic types stanadard} QuickDraw,           {Quickdraw standard} OSIntf,              {Operating system standard} ToolIntf,            {Tools standard} PackIntf,            {Package stuff (List Manager, Decimal to string convert)} sane,                {For Real number conversions} Dialogs;                  const    SetUpPortID=5818;    FileID=29254;    BufferID= 13885;    BufferDefault=100;  {Serial ports Default Buffer Size}      type    SerialPortType=        Packed record            Port:integer;            BaudRate:integer;            StopBits:integer;            Parity:integer;            DataBits:integer;            BufferSize:integer;            InHandShake:integer;            OutHandShake:integer;        end;  var    {My Globals}    DisplayMode:integer;    DataMode:integer;    i:integer;    ch:Char;    Number:integer;    TheString:str255;    TheNumber:LongInt;    TheSerialPort:SerialPortType; procedure InitSerialPort(var TheSerialPort:SerialPortType);    var        error:integer;        ThePort:SPortSel;        TheBaudRate:integer;        TheStopBits:Integer;        TheParity:integer;        TheDataBits:integer;        TheInHandShake:HandShakeKinds;        TheOutHandShake:HandShakeKinds;            begin      with TheSerialPort do        begin            case Port of                0:ThePort:=SPortA;                1:ThePort:=SPortB;            end;            case BaudRate of                0:TheBaudRate:=Baud300;                1:TheBaudRate:=Baud600;                2:TheBaudRate:=Baud1200;                3:TheBaudRate:=Baud1800;                4:TheBaudRate:=Baud2400;                5:TheBaudRate:=Baud3600;                6:TheBaudRate:=Baud4800;                7:TheBaudRate:=Baud7200;                8:TheBaudRate:=Baud9600;                9:TheBaudRate:=Baud19200;                10:TheBaudRate:=Baud57600;            end;            case StopBits of                0:TheStopBits:=Stop10;                1:TheStopBits:=Stop15;                2:TheStopBits:=Stop20;            end;            case Parity of                0:TheParity:=noParity;                1:TheParity:=OddParity;                2:TheParity:=EvenParity;            end;            case DataBits of                0:TheDataBits:=Data5;                1:TheDataBits:=Data6;                2:TheDataBits:=Data7;                3:TheDataBits:=Data8;            end;            case InHandShake of                0:TheInHandShake:=XOnXOff;                1:TheInHandShake:=CTS;                2:TheInHandShake:=none;            end;            case OutHandShake of                0:TheOutHandShake:=XOnXOff;                1:TheOutHandShake:=CTS;                2:TheOutHandShake:=none;            end;            Error:= InitSPort(ThePort,TheBaudRate,TheStopBits,TheParity,TheDataBits,                BufferSize,TheInHandShake,TheOutHandShake);            if Error<>0 then                DebugDialog(Error,'Init Port Error',0);        end;    end;     procedure CloseSerialPort(var TheSerialPort:SerialPortType);            begin        case TheSerialPort.Port of            0:CloseSPort(SPortA);            1:CloseSPort(SPortB);        end;        CloseSPort(SPortA);    end; procedure SetGetSetUpPortDialog (var TheSerialPort : SerialPortType;                  var DialogPointer : DialogPtr;                  SetGet : boolean);           begin    with TheSerialPort do      begin        SetGetDlgInteger(39, BufferSize, DialogPointer, SetGet);        SetGetDlgCtrlValue(38,BufferSize, DialogPointer, True);        SetGetDlgRadioCheckRange(Port, DialogPointer, SetGet,36,37);        SetGetDlgRadioCheckRange(BaudRate, DialogPointer, SetGet,3,13);        SetGetDlgRadioCheckRange(StopBits, DialogPointer, SetGet,15,17);        SetGetDlgRadioCheckRange(Parity, DialogPointer, SetGet,19,21);        SetGetDlgRadioCheckRange(DataBits, DialogPointer, SetGet,23,26);        SetGetDlgRadioCheckRange(InHandShake, DialogPointer, SetGet,28,30);        SetGetDlgRadioCheckRange(OutHandShake, DialogPointer, SetGet,32,34);                SelectText(DialogPointer, 39);      end;  end;     Procedure SetUpPortDialog(var TheSerialPort : SerialPortType);      var        DialogPointer:DialogPtr;             Begin        DialogPointer := GetNewDialog(SetUpPortID, nil, pointer(-1));        SetGetSetUpPortDialog(TheSerialPort, DialogPointer, true);        ShowHide(DialogPointer, true);        Modal( OKCancelType, DialogPointer);        if not CancelButton then            SetGetSetUpPortDialog(TheSerialPort, DialogPointer, false);        DisposDialog(DialogPointer);        CloseSerialPort(TheSerialPort);        InitSerialPort(TheSerialPort);    end;Procedure ClearBuffer(var Error:Boolean);  var    ch:char;    Count:integer;      begin    Error:=False;    count:=0;    while InReady(SPortA) and not error and (Count<110) do      begin        GetChar(SPortA,ch);        if SerResult<>noErr then  {error on get char}          begin            debugdialog(SerResult,'GetChar error in clear buffer count',0);            Error:=true;          end;        count:=Count+1;      end  end;Procedure Send8Bit(TheByte:Byte;                var Error:Boolean);    var      TheString:Str255;            begin      if OutReady(SportA) then        SendChar(SPortA,chr(TheByte))      else        begin          TheString:='Serial port not ready to send.';          sysbeep(1);          SetGetDlgStr255(28,TheString, AccessDialogPointer, true);          Error:=True;        end;    end;    Function Receive8Bit(Var Error:Boolean):Byte;    var      TheChar:Char;            begin      Receive8bit:=0;      if InReady(SportA) then        begin            GetChar(SPortA,TheChar);            Receive8bit:=Ord(TheChar);        end      else        begin          TheString:='Serial port not ready to receive.';          sysbeep(1);          SetGetDlgStr255(28,TheString, AccessDialogPointer, true);          Error:=True;        end;    end;      Procedure Send24Bit(TheNumber:LongInt;            var error:boolean);            begin      Send8Bit(BitShift(bitAnd(TheNumber,$00FC0000),-18)+$C0,error);      if Not error then        begin            Send8Bit(BitShift(bitAnd(TheNumber,$0003F000),-12)+$80,error);            if Not error then                begin                    Send8Bit(BitShift(bitAnd(TheNumber,$00000FC0),-06)+$40,error);                    if Not error then                        Send8Bit(BitShift(bitAnd(TheNumber,$0000003F),-00)+$00,error);                end;        end;    end;   function Receive24Bit(var error:boolean):LongInt;   var    Found:Boolean;    Count:integer;    Byte1,Byte2,Byte3,Byte4:Byte;      begin    Found:=False;    Error:=False;    Count:=0;    repeat      begin        count:=Count+1;        Byte1:= Receive8Bit(Error);        if BitAnd(Byte1,$C0) = $00 then          begin            Byte2:=Receive8Bit(Error);            if BitAnd(Byte2,$C0) = $40 then              begin                Byte3:=Receive8Bit(Error);                if BitAnd(Byte3,$C0) = $80 then                  begin                    Byte4:=Receive8Bit(Error);                    if BitAnd(Byte4,$C0) = $C0 then                      begin                        Found:=True;                        Receive24Bit:=BitAnd(Byte1,$3F)+BitAnd(Byte2,$3F)*64+                            BitAnd(Byte3,$3F)*64*64+BitAnd(Byte4,$3F)*64*64*64;                      end;                  end;              end;          end;      end;    until found or (Count=10) or error;    if Count = 10 then      begin        TheString:='Serial port not ready to receive.';        sysbeep(1);        SetGetDlgStr255(28,TheString, AccessDialogPointer, true);        error:=true;      end;  end;Function ConvertBase(TheString:str255;                    FromBase,ToBase:integer):str255;    var        i,X,L:LongInt;        A:Real;        TempString:Str255;        ch:char;            begin        A:=0;                for i:= 1 to Length(TheString) do            begin                TempString:=Copy(TheString,i,1);                ch:=tempstring[1];                X:=Ord(ch)-Ord('0');                if X>9 then                    X:=X-7;                A:=A*FromBase+X;            end;                  TempString:='';         A:=A+0.499999999999;         L:=trunc(log(A)/Log(ToBase));                  if L<0 then            L:=0;                     for i:= L downto 0 do            begin                X:=trunc(A/Power(ToBase,i));                A:=A-X*Power(ToBase,i);                if X>9 then                    TempString:=TempString+chr(Ord('0')+X+7)                else                    TempString:=TempString+chr(Ord('0')+X);            end;                   ConvertBase:=TempString;    end;    Function StringToNumber(TheDisplayMode:integer;                            TheString:Str255):LongInt;  var     TheLongInt:LongInt;       begin  StringToNumber:=9999;    case TheDisplayMode of      0:        begin            StringToNum(ConvertBase(TheString,2,10),TheLongInt);            StringToNumber:=TheLongInt;        end;      1:        begin            StringToNum(ConvertBase(TheString,8,10),TheLongInt);            StringToNumber:=TheLongInt;        end;      2:        begin            StringToNum(TheString,TheLongInt);            StringToNumber:=TheLongInt;        end;      3:        begin            StringToNum(ConvertBase(TheString,16,10),TheLongInt);            StringToNumber:=TheLongInt;        end;      4:        begin          if Length(TheString) = 1 then              StringToNumber:=Ord(TheString[1]);          if Length(TheString)=2 then              StringToNumber:=Ord(TheString[1])+Ord(TheString[2])*256;          if Length(TheString)>=3 then              StringToNumber:=Ord(TheString[1])+Ord(TheString[2])*256+Ord(TheString[3])*65536;        end;    end;  end;Function NumberToString(TheDisplayMode:integer;                            TheNumber:LongInt):Str255;  var     TheString:Str255;      begin    NumberToString:='error';    case TheDisplayMode of      0:        begin            NumToString(TheNumber, TheString);            NumberToString:=ConvertBase(TheString,10,2);        end;      1:        begin            NumToString(TheNumber, TheString);            NumberToString:=ConvertBase(TheString,10,8);        end;      2:        begin            NumToString(TheNumber, TheString);            NumberToString:=TheString;        end;      3:        begin            NumToString(TheNumber, TheString);            NumberToString:=ConvertBase(TheString,10,16);        end;      4:        NumberToString:=chr(trunc(TheNumber))+chr(trunc(TheNumber/256))+chr(trunc(TheNumber/65536));    end;  end;  procedure SendMode(TheDisplayMode,TheDataMode:Integer);    var        TheString:Str255;        AccessDialogPeek:DialogPeek;        TextItemNumber:integer;        error:boolean;          begin    error:=false;    AccessDialogPeek:=DialogPeek(AccessDialogPointer);    TextItemNumber:=AccessDialogPeek^.editField+1;    case TheDataMode Of        0:;        1:;        2:           begin            SetGetDlgStr255(TextItemNumber,TheString, AccessDialogPointer, False);            Send8Bit(StringToNumber(TheDisplayMode,TheString),error);          end;        3:                    begin            SetGetDlgStr255(TextItemNumber,TheString, AccessDialogPointer, False);            Send24Bit(StringToNumber(TheDisplayMode,TheString),error);          end;      end;  end;  procedure ReceiveMode(TheDisplayMode,TheDataMode:Integer);    var        TheString:Str255;        TheByte:Byte;        TheNumber:LongInt;        AccessDialogPeek:DialogPeek;        TextItemNumber:integer;        Error:boolean;          begin    error:=False;    AccessDialogPeek:=DialogPeek(AccessDialogPointer);    TextItemNumber:=AccessDialogPeek^.editField+1;    case TheDataMode Of        0:;        1:;        2:           begin            TheNumber:=Receive8Bit(error);            TheString:=NumberToString(TheDisplayMode,TheNumber);            SetGetDlgStr255(TextItemNumber,TheString, AccessDialogPointer, True);          end;        3:          begin            TheNumber:=Receive24Bit(error);            TheString:=NumberToString(TheDisplayMode,TheNumber);            SetGetDlgStr255(TextItemNumber,TheString, AccessDialogPointer, True);          end;      end;  end;procedure SendFile(TheDisplayMode,TheDataMode:Integer);    var        TheString:Str255;        AccessDialogPeek:DialogPeek;        TextItemNumber:integer;        TheFile:SFReply;        Input:Text;        NumberOfLines:LongInt;        i,ResultError:integer;        DummyString:StringPtr;        OldVol:integer;        OldDataMode:integer;        OldDisplayMode:integer;        error:boolean;          begin    OldDisplayMode:=TheDisplayMode;    OldDataMode:=theDataMode;        GetTextReadFile(TheFile);    if not cancelButton then        begin            error:=False;            DummyString:=Nil;            ResultError:=GetVol(DummyString,OldVol);            DummyString:=Nil;            ResultError:=SetVol(DummyString,TheFile.vRefNum);            Reset(Input,TheFile.fName);            Readln(input,NumberOfLines);            i:=0;            While (i< NumberOfLines) and Not error do                begin                    i:=i+1;                    readln(input,TheString);                    if IUEqualString(theString , 'Binary')=0 then                        TheDisplayMode:=0                    else if IUEqualString(theString ,'Octal')=0 then                        TheDisplayMode:=1                    else if IUEqualString(theString ,'Decimal')=0then                        TheDisplayMode:=2                    else if IUEqualString(theString ,'Hexidecimal')=0 then                        TheDisplayMode:=3                    else if IUEqualString(theString, 'ASCII')=0 then                        TheDisplayMode:=4                    else if IUEqualString(theString,'ADC')=0 then                        TheDataMode:=0                    else if IUEqualString(theString,'TDC')=0 then                        TheDataMode:=1                    else if IUEqualString(theString,'8 Bit')=0 then                        TheDataMode:=2                    else if IUEqualString(theString,'24 Bit')=0 then                        TheDataMode:=3                    else                     begin                        case TheDataMode Of                            0:;                            1:;                            2:Send8Bit(StringToNumber(TheDisplayMode,TheString),error);                            3:Send24Bit(StringToNumber(TheDisplayMode,TheString),error);                          end;                    end;               end;            Close(Input);            DummyString:=Nil;            ResultError:=SetVol(DummyString,OldVol);                        TheDisplayMode:=OldDisplayMode;            TheDataMode:=OldDataMode;         end;  end;   procedure SetGetFileDialog (var Size : LongInt;                  var DialogPointer : DialogPtr;                  SetGet : boolean);           begin    SetGetDlgLongInt(3, Size, DialogPointer, SetGet);    SelectText(DialogPointer, 3);  end;     Procedure FileDialog(var Size : LongInt);      var        DialogPointer:DialogPtr;             Begin        DialogPointer := GetNewDialog(FileID, nil, pointer(-1));        SetGetFileDialog(Size, DialogPointer, true);        ShowHide(DialogPointer, true);        Modal( OKCancelType, DialogPointer);        if not CancelButton then            SetGetFileDialog(Size, DialogPointer, false);        DisposDialog(DialogPointer);    end;procedure ReceiveFile(TheDisplayMode,TheDataMode:Integer);    var        TheString:Str255;        AccessDialogPeek:DialogPeek;        TextItemNumber:integer;        TheFile:SFReply;        OutPut:Text;        NumberOfLines:LongInt;        i,ResultError:integer;        DummyString:StringPtr;        OldVol:integer;        error:boolean;          begin     TheFile.fName:='';    GetWriteFile(TheFile);    if not cancelButton then        begin            NumberOfLines:=1000;            FileDialog(NumberOfLines);            if not cancelButton Then                begin                    error:=False;                    DummyString:=Nil;                    ResultError:=GetVol(DummyString,OldVol);                    DummyString:=Nil;                    ResultError:=SetVol(DummyString,TheFile.vRefNum);                    ReWrite(OutPut,TheFile.fName);                    Writeln(OutPut,NumberOfLines+2,' number of lines');                    case TheDataMode Of                        0:Writeln(OutPut,'ADC');                        1:Writeln(OutPut,'TDC');                        2:Writeln(OutPut,'8 Bit');                        3:Writeln(OutPut,'24 Bit');                      end;                    case TheDisplayMode Of                        0:Writeln(OutPut,'Binary');                        1:Writeln(OutPut,'Octal');                        2:Writeln(OutPut,'Decimal');                        3:Writeln(OutPut,'Hexidecimal');                        4:Writeln(OutPut,'ASCII');                      end;                    i:=0;                    While (i< NumberOfLines) and not error do                        begin                           i:=i+1;                           case TheDataMode Of                             0:;                             1:;                             2:                                begin                                 TheNumber:=Receive8Bit(error);                                 TheString:=NumberToString(TheDisplayMode,TheNumber);                               end;                             3:                               begin                                 TheNumber:=Receive24Bit(error);                                 TheString:=NumberToString(TheDisplayMode,TheNumber);                               end;                           end;                           if not error then                             Writeln(OutPut,TheString);                        end;                    if Error then                        Writeln(OutPut,'Error occured during Recieve, actual number of lines is ',i+1,'.');                    Close(OutPut);                    DummyString:=Nil;                    ResultError:=SetVol(DummyString,OldVol);                end;        end;  end;begin  with TheSerialPort do    begin        Port:=0;        BaudRate:=8;        StopBits:=2;        Parity:=0;        DataBits:=3;        BufferSize:=1000;        inHandShake:=0;        OutHandShake:=2;    end;    InitSerialPort(TheSerialPort);    DisplayMode:=2;    DataMode:=2;end.