unit MultiFileSelect(-44);  interface  {$U-}  {Use My own include Librarys}  {$R MultiFileSelectRsrc}  {Load my reasources (dialog boxes etc..)}  {$O Jim Surine:Programming:Units:My Units:MultiFileSelect}    uses    Memtypes,            {Basic types stanadard}    QuickDraw,           {Quickdraw standard}    OSIntf,              {Operating system standard}    ToolIntf,            {Tools standard}    PackIntf;            {Package stuff (List Manager, Decimal to string convert)}  type    FileListType = array[1..200] of SFReply;    FileListptr = ^FileListType;    FileListHdl = ^FileListptr;  const    MultiFileSelectID=18104;      var    phonycancel:boolean;    globalvol:longint;          procedure GetFolder (var DirectoryID : longint;                  var cancelcommand : boolean;                  NumberOfTypes:integer;                  FileTypes:SFTypeList);                    procedure GetAllinFolder (DirectoryID : longint;                  theFiles : FileListHdl;                  var numfound : integer);  implementation    function MyFileFilter (paramBlock : ParmBlkPtr) : boolean;    begin      myfilefilter := false;      globalvol := paramBlock^.iovrefnum;    end;  function myfolderdlg (whichitem : integer;                  folderdialog : dialogptr) : integer;    begin      if whichitem = 11 then        begin          myfolderdlg := getcancel;          phonycancel := true;        end      else        begin          myfolderdlg := whichitem;          phonycancel := false;        end;    end;    procedure GetFolder {(var DirectoryID : longint;                  var cancelcommand : boolean)};                      var      ThePoint : point;      FileType : SFTypeList;      reply : sfReply;       begin      ThePoint.h := 40;      ThePoint.v := 50;      SFPGetFile(ThePoint,'Select Folder', @myFileFilter,-1, FileType, @myfolderdlg, reply, MultiFileSelectID, nil);      DirectoryID := longint(reply.ftype);      cancelcommand := not phonycancel;    end;   procedure GetAllinFolder {(DirectoryID : longint;                  theFiles : FileListHdl;                  var numfound : integer)};                      var      theptr : ptr;      GAFparm : CInfoPBPtr;      wdparm : wdPBPtr;      errcode, wderr : oserr;      gfilename, wdfilename : str255;      directories, nextdir : array[1..50] of longint;      founddir, numcycles : integer;      cycle : integer;      mysignedbyte : signedbyte;      filetype : ostype;     begin    theptr := newptr(sizeof(wdPBRec));    wdparm := wdPBPtr(theptr);    wdparm^.iocompletion := nil;    wdfilename := '';    wdparm^.ionameptr := nil;    wdparm^.ioWDIndex := 0;    filetype := 'CMPS';    wdparm^.iowdprocid := longint(filetype);      theptr := newptr(sizeof(cinfopbrec));    gafparm := cinfopbptr(theptr);    gafparm^.iocompletion := nil;    gafparm^.ionameptr := @gfilename;    numfound := 0;    founddir := 1;    directories[1] := directoryID;    gafparm^.iovrefnum := globalvol;    repeat      begin        numcycles := founddir;        founddir := 0;        for cycle := 1 to numcycles do          begin            gafparm^.iofdirindex := 0;            repeat              begin                gafparm^.iofdirindex := gafparm^.iofdirindex + 1;                gafparm^.iodirid := directories[cycle];                errcode := PBGetCatInfo(gafparm, false);                if errcode = noerr then                  begin                    mysignedbyte := gafparm^.ioflattrib;                    if bittst(@mysignedbyte, 3) then {true if folder}                      begin                        founddir := founddir + 1;                        nextdir[founddir] := gafparm^.iodrdirid;                      end                    else {it's a file}                      begin                        numfound := numfound + 1;                        hlock(handle(thefiles));                        with theFiles^^[numfound] do                          begin                            fname := gafparm^.ionameptr^;                            ftype := gafparm^.ioflFndrInfo.fdtype;                            wdparm^.iovrefnum := gafparm^.iovrefnum;                            wdparm^.iowddirid := directories[cycle];                            wderr := PBOpenWD(wdparm, false);                            vrefnum := wdparm^.iovrefnum;                          end;                        hunlock(handle(thefiles));                      end;                  end;              end;            until errcode = fnferr;            directories := nextdir;          end;      end;    until founddir = 0;    disposptr(ptr(gafparm));    disposptr(ptr(wdparm));  end;  beginend.