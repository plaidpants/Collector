unit ADC(90);interface {$U-} {Use My own include Librarys} {$U Jim Surine:Programming:Units:My Units:Dialogs} {$U Jim Surine:Programming:Units:My Units:Patterns} {$U Jim Surine:Programming:Units:My Units:Axis2} {$U Jim Surine:Programming:Units:Mews Units:Serial} {$U Jim Surine:Programming:Units:My Units:Histogram} {$U Jim Surine:Programming:Units:My Units:GrayScale} {$U Jim Surine:Programming:Units:My Units:RecordInteger} {$U Jim Surine:Programming:Units:My Units:RecordReal} {$U Jim Surine:Programming:Units:My Units:RecordLongInt} {$U Jim Surine:Programming:Units:My Units:Plot} {$U Jim Surine:Programming:Units:My Units:AutoRecord} {$U Jim Surine:Programming:Units:My Units:CollectorGlobals} {$I-}  {$O Jim Surine:Programming:Units:My Units:ADC} uses Memtypes,            {Basic types stanadard} QuickDraw,           {Quickdraw standard} OSIntf,              {Operating system standard} ToolIntf,            {Tools standard}  PackIntf,          {Package stuff (List Manager, Decimal to string convert)} sane,              {For Real number conversions}   PasInOut, Dialogs, Serial, Patterns, Axis2, Histogram, GrayScale, RecordInteger, RecordReal, RecordLongInt, Plot, AutoRecord, CollectorGlobals;  const  WIndowTypeID = 17679;     {Standard data window}  PortBufferID = 13885;    BufferDefault = 100; Procedure ADCAddToWindow(var TheWindowData:WindowDataType;                    TheEvent:EventType;                    ThePort:WIndowPtr);procedure ADCWindowTypeDialog (var TheWindowDatainfo : WindowDatainfoType);procedure ADCinitHistograminfo(var TheWindowData:WindowDataType;                          ThePort:WindowPtr);procedure ADCInit;procedure ADCClose; procedure ADCReadEvent(var TheEvent:EventType;     var Error:Boolean);implementation  Procedure ADCAddToWindow{(var TheWindowData:WindowDataType;                    TheEvent:EventType;                    ThePort:WindowPtr)};    begin    AddToHistogram(TheWindowData.WindowData.Histogram,TheEvent.ADCEvent,1,ThePort);  end;   procedure ADCinitHistograminfo{(var TheWindowData:WindowDataType;                            ThePort:WindowPtr)};  var   TheString:str255;   seconds:longInt;    begin  with TheWindowData.WindowData.Histogram.Histograminfo do    begin      LowerDataBound := 0;      UpperDataBound := 4095;      NumberOfDataBins := 4095;            UpperdataInclude := true;      LowerdataInclude := true;            Title:='ADC device histogram plot';            GetDateTime(Seconds);      IUDateString(Seconds,shortDate,TheString);      Title:=Title+' created '+TheString;      IUTimeString(Seconds,false,TheString);      Title:=Title+' '+TheString;            LowerDisplayBound := 0;      UpperDisplayBound := 500;      NumberOfDisplayBins := 5;            UpperDisplayInclude := true;      LowerDisplayInclude := true;            LowerVerticleBound:=0;  {Default scaling}      UpperVerticleBound:=0;    end; end;         procedure ADCWindowTypeDialog {(var TheWindowData : WindowDataType)}; begin  {only one type and one data of that type so no types to select} end;procedure ADCClose;begin    CloseSPort(SPortA);end; procedure ADCInit;  var   DialogPointer : DialogPtr;   BufferSize : LongInt;   i:integer;    begin  BufferSize:=BufferDefault;    DialogPointer := GetNewDialog(PortBufferID, nil, pointer(-1));  SetGetDlgLongInt(2,BufferSize, dialogPointer, true);  SelectText(DialogPointer,2);  ShowHide(DialogPointer, true);  Modal( OKType, DialogPointer);  SetGetDlgLongInt(2,BufferSize, dialogPointer, False);  DisposDialog(DialogPointer);    if InitSPort(SPortA, baud9600, stop20, noParity, data8, BufferSize, XonXoff, none) <> noerr then    sysbeep(10);      for i := 1 to 10 do    DefaultWindowDatainfo.TypeOfData[i]:=0;    DefaultWindowDatainfo.TypeOfData[10]:=3; end; function ADCreadByte(var Error:Boolean):Byte;  var    ch:char;    GotChar:Boolean;    Count:integer;      begin     GotChar:=False;    Error:=False;    Count:=0;    repeat      Count:=Count+1;      if InReady(SPortA) then        begin          GetChar(SPortA,ch);          if SerResult<>noErr then  {error on get char}            begin              debugdialog(SerResult,'GetChar error',0);              Error:=true;            end          else            GotChar:=True;        end      else        begin          if SerResult<>noErr then  {error on inready}            begin              debugdialog(SerResult,'inready error',0);              Error:=true;            end;          SendChar(SportA,Chr(17));          if SerResult<>noErr then  {error on inready}            begin              debugdialog(SerResult,'Send Char error',0);              Error:=true;            end;        end;    until GotChar or (Count>1000) or error;    if Count>1000 then      begin        debugdialog(0,'readbyte 1000 error',0);        Error:=true;      end;    ADCReadByte := Ord(ch);  end;   procedure ADCReadEvent{(var TheEvent:EventType;     var Error:Boolean)};   var    Found:Boolean;    Count:integer;    Byte1,Byte2,Byte3,Byte4:Byte;      begin    Found:=False;    Error:=False;    Count:=0;    repeat      begin        count:=Count+1;        Byte1:= ADCreadByte(Error);        if BitAnd(Byte1,$C0) = $00 then          begin            Byte2:=ADCreadByte(Error);            if BitAnd(Byte2,$C0) = $40 then              begin                Byte3:=ADCreadByte(Error);                if BitAnd(Byte3,$C0) = $80 then                  begin                    Byte4:=ADCreadByte(Error);                    if BitAnd(Byte4,$C0) = $C0 then                      begin                        Found:=True;                        TheEvent.ADCEvent:=BitAnd(Byte1,$3F)+BitAnd(Byte2,$3F)*64;                      end;                  end;              end;          end;      end;    until found or (Count=10) or error;    if Count = 10 then      begin        debugdialog(0,'readEvent 10 error',0);        Error:=true;      end;  end;var   i:integer;  begin  for i := 1 to 5 do    DefaultWindowDatainfo.TypeOfData[i]:=0;  IgnoreErrorCheck:=False;end.