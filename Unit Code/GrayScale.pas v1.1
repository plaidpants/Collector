unit GrayScale(-45);{Some Helpful routines for accessing dialog boxes}interface {$U-} {Use My own include Librarys} {$R DialogRsrc} {Load my reasources (dialog boxes etc..)} {$U Jim Surine:Programming:Units:My Units:Patterns} {$U Jim Surine:Programming:Units:My Units:Axis2} {$U Jim Surine:Programming:Units:My Units:Dialogs} {$I-} {$O Jim Surine:Programming:Units:My Units:GrayScale}uses Memtypes,            {Basic types stanadard} QuickDraw,           {Quickdraw standard} OSIntf,              {Operating system standard} ToolIntf,            {Tools standard} PackIntf,            {Package stuff (List Manager, Decimal to string convert)} sane,                {For Real number conversions} PasInOut,  Dialogs, Patterns, Axis2;  const  GrayScaleInfoID = 9083; {GrayScale info parameters editing dialog}  GrayScaleDataID = 5583; {GrayScale Data parameters editing dialog}  GrayScaleXLimit = 75;  GrayScaleYLimit = 75;  type  GrayScaleInfoType = record    DataRangeDomain : RealRect;        TopDataInclude:Boolean;    BottomDataInclude:Boolean;    LeftDataInclude:Boolean;    RightDataInclude:Boolean;        HorzDataBins:integer;    VertDataBins:integer;        Title:str255;        DisplayRangeDomain : Realrect;        TopDisplayInclude:Boolean;    BottomDisplayInclude:Boolean;    LeftDisplayInclude:Boolean;    RightDisplayInclude:Boolean;    HorzDisplayBins:integer;    VertDisplayBins:integer;        LowerVerticleBound:integer; {zero both for auto scaling}    UpperVerticleBound:integer;         DrawOption:integer;   end;  GrayScaleType = record    GrayScaleData : packed array[1..GrayScaleXLimit, 1..GrayScaleYLimit] of Integer;    MaxNumberInBin  :integer;    NumberOutsideGrayScale:integer;    NumberInGrayScale : integer;    GrayScaleInfo : GrayScaleInfoType;   end; procedure InitGrayScale (var GrayScale : GrayScaleType;         ThePort:WindowPtr); procedure CloseGrayScale (var GrayScale : GrayScaleType);          procedure AddToGrayScale (var GrayScale : GrayScaleType;         X : real;         Y : real;         Add : integer;         ThePort:WindowPtr);          procedure DrawGrayScale (var TheGrayScale : GrayScaleType;    ThePort:windowPtr);  procedure GrayScaleDisplayDialog (var GrayScale: GrayScaleType;          ThePort:WindowPtr);  procedure GrayScaleDataDialog (var GrayScale : GrayScaleType;                                ThePort:WindowPtr); procedure GrayScaleInfoDialog (var GrayScale : GrayScaleType); Procedure SaveGrayScaleAsText (var TheGrayScale : GrayScaleType;          Reply:SFReply;          var Output:text); Procedure LoadGrayScaleAsText (var TheGrayScale : GrayScaleType;          Reply:SFReply;          var Input:Text);implementation{*******************GrayScale Procedures*****************}procedure CheckGrayScale( var GrayScale: GrayScaleType);begin  with GrayScale DO    begin  if GrayScaleinfo.HorzDataBins>GrayScaleXLimit then    begin        OKDialog('Problem with data bins in gray scale.');        GrayScaleinfo.HorzDataBins:=GrayScaleXLimit;    end;  if GrayScaleinfo.VertDataBins>GrayScaleYLimit then    begin        OKDialog('Problem with data bins in gray scale.');        GrayScaleinfo.VertDataBins:=GrayScaleYLimit;    end;          if GrayScaleinfo.DataRangeDomain.Left>GrayScaleinfo.DataRangeDomain.Right then    begin        OKDialog('Problem with data bounds in gray scale.');        GrayScaleinfo.DataRangeDomain.Left:=GrayScaleinfo.DataRangeDomain.Right-10;    end;  if GrayScaleinfo.DataRangeDomain.Top<GrayScaleinfo.DataRangeDomain.Bottom then    begin        OKDialog('Problem with data bounds in gray scale.');        GrayScaleinfo.DataRangeDomain.Top:=GrayScaleinfo.DataRangeDomain.Bottom+10;    end;      if GrayScaleinfo.DisplayRangeDomain.Left>GrayScaleinfo.DisplayRangeDomain.Right then    begin        OKDialog('Problem with Display bounds in gray scale.');        GrayScaleinfo.DisplayRangeDomain.Left:=GrayScaleinfo.DisplayRangeDomain.Right-10;    end;  if GrayScaleinfo.DisplayRangeDomain.Top<GrayScaleinfo.DisplayRangeDomain.Bottom then    begin        OKDialog('Problem with Display bounds in gray scale.');        GrayScaleinfo.DisplayRangeDomain.Top:=GrayScaleinfo.DisplayRangeDomain.Bottom+10;    end;      if GrayScaleinfo.LowerVerticleBound>GrayScaleinfo.UpperVerticleBound then    begin        OKDialog('Problem with verticle bounds in gray scale.');        GrayScaleinfo.LowerVerticleBound:=0; {auto scale}        GrayScaleinfo.UpperVerticleBound:=0;    end;    end; end; procedure InitGrayScale {(var GrayScale : GrayScaleType;         ThePort:windowPtr)};  var    i,j:integer;     begin  CheckGrayScale( GrayScale );  for i := 1 to GrayScaleXLimit do    for j := 1 to GrayScaleYLimit do      GrayScale.GrayScaleData[i,j] := 0;  GrayScale.NumberInGrayScale := 0;  GrayScale.NumberOutsideGrayScale := 0;  GrayScale.MaxNumberInBin := 0; end;  procedure CloseGrayScale {(var GrayScale : GrayScaleType)};     begin end; procedure AddToGrayScale {(var GrayScale : GrayScaleType;         X : real;         Y : real;         Add : integer;         ThePort:WindowPtr)};  var   LocX,LocY : integer;   test1,test2,test3,test4,test5,test6:boolean;   OldPort:WindowPtr;    begin  GetPort(OldPort);  SetPort(ThePort);  with GrayScale.GrayScaleinfo do    begin      Test1:=(X<DataRangeDomain.right) and (X>DataRangeDomain.left);      Test2:= (X=DataRangeDomain.right) and rightdataInclude;      Test3:= (X=DataRangeDomain.left) and leftdataInclude;            Test4:=(Y<DataRangeDomain.top) and (Y>DataRangeDomain.bottom);      Test5:=(Y=DataRangeDomain.Bottom) and BottomdataInclude;      Test6:=(Y=DataRangeDomain.top) and TopdataInclude;    end;    if (Test1 or Test2 or Test3) and (Test4 or Test5 or test6) then    begin      with GrayScale.GrayScaleInfo do        begin          LocX := Trunc((X - DataRangeDomain.left) / ((DataRangeDomain.right - DataRangeDomain.left) / HorzDataBins)) + 1;           LocY := Trunc((Y - DataRangeDomain.Bottom) / ((DataRangeDomain.top - DataRangeDomain.bottom) / VertDataBins)) + 1;         end;     {Plus One because array starts at one}      GrayScale.GrayScaleData[LocX,LocY] := GrayScale.GrayScaleData[LocX,LocY] + Add;      GrayScale.NumberInGrayScale := GrayScale.NumberInGrayScale + Add;      if GrayScale.GrayScaleData[locX,LocY] > GrayScale.MaxNumberInBin then        GrayScale.MaxNumberInBin := GrayScale.GrayScaleData[locX,LocY];    end  else    GrayScale.NumberInGrayScale := GrayScale.NumberInGrayScale+Add;   SetPort(OldPort); end; procedure DrawGrayScale {(var TheGrayScale : GrayScaleType;        ThePort:WindowPtr)};  var   AxisInfo:AxisInfoType;      XDisplayDataRange:Real;   XDataRange:Real;   XBinSpace:Real;      XStartBin:Real;   XBinStep:Real;   TheXBin:integer;   YDisplayDataRange:Real;   YDataRange:Real;   YBinSpace:Real;      YStartBin:Real;   YBinStep:Real;   TheYBin:integer;      TheRealPoint:RealPoint;   ThePoint:Point;   TheRect:Rect;   InView:boolean;      TheValue:Real;   GrayLevel:Integer;   TitleLoc:integer;   i,j:Integer;      TheEvent:EventRecord;   OldPort:WindowPtr;    begin    getPort(OldPort);    SetPort(ThePort);    DefaultAxis(AxisInfo,ThePort);        with AxisInfo do        begin            XGridMinor:=0;            YGridMinor:=0;            XGridMajor:=0;            YGridMajor:=0;            DataRect:=TheGrayScale.GrayScaleInfo.DisplayRangeDomain;                        Title:='test title';            Note:='Test Note';                        TitleLoc:=pos('*',TheGrayScale.GrayScaleInfo.Title);            Title:=copy(TheGrayScale.GrayScaleInfo.Title,1,TitleLoc-1);            Note:=copy(TheGrayScale.GrayScaleInfo.Title,TitleLoc+1,Length(TheGrayScale.GrayScaleInfo.Title)-TitleLoc);                end;     AdjustAxis(AxisInfo,ThePort);          DrawAxis(AxisInfo,ThePort);          XDisplayDataRange:=AxisInfo.DataRect.Right-AxisInfo.DataRect.Left;     XDataRange:=TheGrayScale.GrayScaleInfo.DataRangeDomain.Right-TheGrayScale.GrayScaleInfo.DataRangeDomain.Left;        XBinStep:=(TheGrayScale.GrayScaleInfo.HorzDataBins/XDataRange)        *(XDisplayDataRange/TheGrayScale.GrayScaleInfo.HorzDisplayBins);          XBinSpace:=(XDisplayDataRange/TheGrayScale.GrayScaleInfo.HorzDisplayBins);      XStartBin:=Xbinstep*(Axisinfo.DataRect.left-TheGrayScale.GrayScaleInfo.DataRangeDomain.Left)/XBinSpace;     YDisplayDataRange:=AxisInfo.DataRect.Top-AxisInfo.DataRect.Bottom;     YDataRange:=TheGrayScale.GrayScaleInfo.DataRangeDomain.Top-TheGrayScale.GrayScaleInfo.DataRangeDomain.Bottom;        YBinStep:=(TheGrayScale.GrayScaleInfo.VertDataBins/YDataRange)        *(YDisplayDataRange/TheGrayScale.GrayScaleInfo.VertDisplayBins);          YBinSpace:=(YDisplayDataRange/TheGrayScale.GrayScaleInfo.VertDisplayBins);      YStartBin:=Ybinstep*(Axisinfo.DataRect.Bottom-TheGrayScale.GrayScaleInfo.DataRangeDomain.Bottom)/YBinSpace;          PenMode(PatOr);          for i:= 0 to trunc(TheGrayScale.GrayScaleInfo.HorzDisplayBins)-1 do       for j:= 0 to trunc(TheGrayScale.GrayScaleInfo.VertDisplayBins)-1 do        begin            TheXBin:=trunc(XStartBin+i*XBinStep);            TheYBin:=trunc(YStartBin+j*YBinStep);                        if (TheXBin>=0) and (TheXBin<TheGrayScale.GrayScaleInfo.HorzDataBins)                and (TheYBin>=0) and (TheXBin<TheGrayScale.GrayScaleInfo.VertDataBins) then                TheValue:=TheGrayScale.GrayScaleData[TheXBin+1,TheYBin+1]            else                TheValue:=0;                        If eventAvail(keydownmask,theEvent) then                Exit;                            with TheGrayScale.GrayScaleInfo do                if TheGrayScale.MaxNumberInBin <> 0 then                    if (LowerVerticleBound =0) and (UpperVerticleBound=0 )then                      GrayLevel:=trunc(TheValue/(TheGrayScale.MaxNumberInBin/16))                    else                      GrayLevel:=trunc((TheValue-LowerVerticleBound)                        /((UpperVerticleBound-LowerVerticleBound)/16))                else                    GrayLevel:=0;                                                  if GrayLevel > 16 then                GrayLevel:=17;              if GrayLevel < 0 then                grayLevel:=18;                        TheRealPoint.X:=AxisInfo.DataRect.Left+XBinSpace*i;            TheRealPoint.Y:=AxisInfo.DataRect.bottom+YBinSpace*j;            WhereAxis(AxisInfo,TheRealPoint,ThePoint,InView);            TheRect.Left:=ThePoint.h;            TheRect.Bottom:=ThePoint.V;                        TheRealPoint.X:=AxisInfo.DataRect.Left+XBinSpace*(i+1);            TheRealPoint.Y:=AxisInfo.DataRect.Bottom+YBinSpace*(j+1);            WhereAxis(AxisInfo,TheRealPoint,ThePoint,InView);            TheRect.Right:=ThePoint.h;            TheRect.Top:=ThePoint.V;                        insetRect(TheRect,1,1);            PenPat( Mypatterns[GrayLevel]);            PaintRect(TheRect);        end;     SetPort(ThePort); end; procedure SetGetGrayScaleDisplayDialog (var GrayScale: GrayScaleType;         var DialogPointer : DialogPtr;         SetGet : boolean); begin  with GrayScale.GrayScaleinfo do   begin    setGetDlgReal(3, DisplayRangeDomain.left, DialogPointer, SetGet);    setGetDlgReal(4, DisplayRangeDomain.right, DialogPointer, SetGet);    setGetDlginteger(5, HorzDisplayBins, DialogPointer, SetGet);    SetGetDlgBoolean(6,LeftDisplayInclude, DialogPointer, SetGet);    SetGetDlgBoolean(7,RightDisplayInclude, DialogPointer, SetGet);    setGetDlgReal(8, DisplayRangeDomain.bottom, DialogPointer, SetGet);    setGetDlgReal(9, DisplayRangeDomain.top, DialogPointer, SetGet);    setGetDlginteger(10, VertDisplayBins, DialogPointer, SetGet);    SetGetDlgBoolean(11,LeftDisplayInclude, DialogPointer, SetGet);    SetGetDlgBoolean(12,RightDisplayInclude, DialogPointer, SetGet);    setGetDlginteger(13, LowerVerticleBound, DialogPointer, SetGet);    setGetDlginteger(14, UpperVerticleBound, DialogPointer, SetGet);    SetgetDlgStr255(15, Title, DialogPointer, SetGet);    SelectText(DialogPointer,3);   end; end; procedure GrayScaleDisplayDialog {(var GrayScale : GrayScaleType;          ThePort:WindowPtr)};  var   DialogPointer : DialogPtr;   OldPort:WindowPtr;    begin  GetPort(OldPort);  DialogPointer := GetNewDialog(GrayScaleInfoID, nil, pointer(-1));  SetGetGrayScaleDisplayDialog(GrayScale, dialogPointer, true);  ShowHide(DialogPointer, true);  Modal( OKCancelType, DialogPointer);  if not cancelButton then   SetGetGrayScaleDisplayDialog(GrayScale, DialogPointer, false);  DisposDialog(DialogPointer);  CheckGrayScale( GrayScale );  SetPort(OldPort); end; procedure SetGetGrayScaleDataDialog (var GrayScale : GrayScaleType;         var DialogPointer : DialogPtr;         SetGet : boolean); begin  with GrayScale.GrayScaleinfo do   begin    setGetDlgReal(3, DataRangeDomain.left, DialogPointer, SetGet);    setGetDlgReal(4, DataRangeDomain.right, DialogPointer, SetGet);    setGetDlginteger(5, HorzDataBins, DialogPointer, SetGet);    SetGetDlgBoolean(6,LeftDataInclude, DialogPointer, SetGet);    SetGetDlgBoolean(7,RightDataInclude, DialogPointer, SetGet);    setGetDlgReal(8, DataRangeDomain.bottom, DialogPointer, SetGet);    setGetDlgReal(9, DataRangeDomain.top, DialogPointer, SetGet);    setGetDlginteger(10, VertDataBins, DialogPointer, SetGet);    SetGetDlgBoolean(11,LeftDataInclude, DialogPointer, SetGet);    SetGetDlgBoolean(12,RightDataInclude, DialogPointer, SetGet);    SelectText(DialogPointer,3);   end; end; procedure GrayScaleDataDialog {(var GrayScale : GrayScaleType;                                ThePort:WindowPtr)};  var   DialogPointer : DialogPtr;  OldPort:WindowPtr;   begin  GetPort(OldPort);  DialogPointer := GetNewDialog(GrayScaleDataID, nil, pointer(-1));  SetGetGrayScaleDataDialog(GrayScale, dialogPointer, true);  ShowHide(DialogPointer, true);  Modal( OKCancelType, DialogPointer);  if not CancelButton then    begin      OKCancelDialog('Changing a Gray Scale data ranges erases the GrayScale');      if not CancelButton then       begin        SetGetGrayScaleDataDialog(GrayScale, DialogPointer, false);        InitGrayScale(GrayScale,ThePort);       end;    end;  DisposDialog(DialogPointer);  CheckGrayScale( GrayScale );  SetPort(OldPort); end; procedure SetGetGrayScaleInfoDialog (var GrayScale : GrayScaleType;         var DialogPointer : DialogPtr;         SetGet : boolean);   begin end; procedure GrayScaleInfoDialog {(var GrayScale : GrayScaleType)};  var   DialogPointer : DialogPtr;  OldPort:WindowPtr;   begin  GetPort(OldPort);  DialogPointer := GetNewDialog(GrayScaleinfoID, nil, pointer(-1));  SetGetGrayScaleinfoDialog(GrayScale, dialogPointer, true);  ShowHide(DialogPointer, true);  Modal( OKType, DialogPointer);  DisposDialog(DialogPointer);  SetPort(OldPort); end; Procedure SaveGrayScaleAsText {(var TheGrayScale : GrayScaleType;          Reply:SFReply;          var OutPut:Text)};  var     i,j:integer;    		begin			with TheGrayScale do				begin					writeln(Output,GrayScaleInfo.DataRangeDomain.Top);     writeln(Output,GrayScaleInfo.DataRangeDomain.Bottom);     writeln(Output,GrayScaleInfo.DataRangeDomain.Left);     writeln(Output,GrayScaleInfo.DataRangeDomain.Right);     {writeln(Output,GrayScaleInfo.TopDataInclude);     writeln(Output,GrayScaleInfo.BottomDataInclude);     writeln(Output,GrayScaleInfo.LeftDataInclude);     writeln(Output,GrayScaleInfo.RightDataInclude);}     writeln(Output,GrayScaleInfo.HorzDataBins);     writeln(Output,GrayScaleInfo.VertDataBins);     writeln(Output,GrayScaleInfo.Title);        	writeln(Output,GrayScaleInfo.DisplayRangeDomain.Top);     writeln(Output,GrayScaleInfo.DisplayRangeDomain.Bottom);     writeln(Output,GrayScaleInfo.DisplayRangeDomain.Left);     writeln(Output,GrayScaleInfo.DisplayRangeDomain.Right);          {writeln(Output,GrayScaleInfo.TopDisplayInclude);     writeln(Output,GrayScaleInfo.BottomDisplayInclude);     writeln(Output,GrayScaleInfo.LeftDisplayInclude);     writeln(Output,GrayScaleInfo.RightDisplayInclude);}     writeln(Output,GrayScaleInfo.HorzDisplayBins);     writeln(Output,GrayScaleInfo.VertDisplayBins);     writeln(Output,GrayScaleInfo.LowerVerticleBound);     writeln(Output,GrayScaleInfo.UpperVerticleBound);          writeln(Output,GrayScaleInfo.DrawOption);          writeln(Output,NumberinGrayScale);     writeln(Output,NumberOutsideGrayScale);     writeln(Output,MaxNumberInBin);          for i:= 1 to GrayScaleInfo.HorzDataBins do       for j:= 1 to GrayScaleInfo.VertDataBins do          writeln(OutPut,GrayScaleData[i,j]);				end;		end; Procedure LoadGrayScaleAsText {(var TheGrayScale : GrayScaleType;          Reply:SFReply;          var Input:Text)};  var     i,j:integer;    TheReal:Real;    		begin			with TheGrayScale do				begin					Readln(Input,GrayScaleInfo.DataRangeDomain.Top);     Readln(Input,GrayScaleInfo.DataRangeDomain.Bottom);     Readln(Input,GrayScaleInfo.DataRangeDomain.Left);     Readln(Input,GrayScaleInfo.DataRangeDomain.Right);     {Readln(Input,GrayScaleInfo.TopDataInclude);     Readln(Input,GrayScaleInfo.BottomDataInclude);     Readln(Input,GrayScaleInfo.LeftDataInclude);     Readln(Input,GrayScaleInfo.RightDataInclude);}     Readln(Input,GrayScaleInfo.HorzDataBins);     Readln(Input,GrayScaleInfo.VertDataBins);     Readln(Input,GrayScaleInfo.Title);        	Readln(Input,GrayScaleInfo.DisplayRangeDomain.Top);     Readln(Input,GrayScaleInfo.DisplayRangeDomain.Bottom);     Readln(Input,GrayScaleInfo.DisplayRangeDomain.Left);     Readln(Input,GrayScaleInfo.DisplayRangeDomain.Right);          {Readln(Input,GrayScaleInfo.TopDisplayInclude);     Readln(Input,GrayScaleInfo.BottomDisplayInclude);     Readln(Input,GrayScaleInfo.LeftDisplayInclude);     Readln(Input,GrayScaleInfo.RightDisplayInclude);}     Readln(Input,GrayScaleInfo.HorzDisplayBins);     Readln(Input,GrayScaleInfo.VertDisplayBins);     Readln(Input,GrayScaleInfo.LowerVerticleBound);     Readln(Input,GrayScaleInfo.UpperVerticleBound);          Readln(Input,GrayScaleInfo.DrawOption);          Readln(Input,NumberinGrayScale);     Readln(Input,NumberOutsideGrayScale);     Readln(Input,MaxNumberInBin);          for i:= 1 to GrayScaleInfo.HorzDataBins do       for j:= 1 to GrayScaleInfo.VertDataBins do        begin          Readln(Input,TheReal);          GrayScaleData[i,j]:=Trunc(TheReal);        end;    end;		end;  begin  end.