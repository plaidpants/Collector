unit RecordLongInt(-22311);interface {$U-} {Use My own include Librarys} {$R DialogRsrc} {Load my reasources (dialog boxes etc..)} {$U Jim Surine:Programming:Units:My Units:Dialogs} {$I-} {$O Jim Surine:Programming:Units:My Units:RecordLongInt} uses Memtypes,            {Basic types stanadard} QuickDraw,           {Quickdraw standard} OSIntf,              {Operating system standard} ToolIntf,            {Tools standard} PackIntf,            {Package stuff (List Manager, Decimal to string convert)} sane,                {For Real number conversions}  PasInOut,  Dialogs; const  RecordLongIntDisplayID = 26819 ;{RecordLongInt Display parameters editing dialog}  RecordLongIntDataID = 23041 ; {RecordLongInt Data parameters editing dialog}  RecordLongIntInfoID = 4871;    CurrNumberRecordedLimitRecordLongInt = 5000;  NumberPerRecordLimitRecordLongInt = 200;type    RecordLongIntDataType=        packed array[1..NumberPerRecordLimitRecordLongInt] of LongInt;    RecordLongIntDataSegmentHandle=        ^RecordLongIntDataSegmentPointer;    RecordLongIntDataSegmentPointer=        ^RecordLongIntDataSegmentType;    RecordLongIntDataSegmentType =  Packed record        RecordLongIntDataSegment:            packed array[1..CurrNumberRecordedLimitRecordLongInt] of LongInt;        NextRecordLongIntDataSegmentHandle:            RecordLongIntDataSegmentHandle;    end;      RecordLongIntInfoType =     record      NumberPerRecord : integer;      NumberToRecord:LongInt;      Title : Str255;      DrawOption : integer;    end;    RecordLongIntHandle=    ^RecordLongIntPointer;  RecordLongIntPointer=    ^RecordLongIntType;  RecordLongIntType =    record      RecordLongIntInfo : RecordLongIntInfoType;      NumberRecorded : LongInt;      DataSegmentHandle : RecordLongIntDataSegmentHandle;      CurrNumberRecorded:longInt;      CurrDataSegmentHandle : RecordLongIntDataSegmentHandle;    end;  RecordLongIntAnalType = array [1..NumberPerRecordLimitRecordLongInt] of    record      Number : LongInt;      Mean : real;      StandardDev : real;      Maximum : real;      Minimum : real;    end; procedure InitRecordLongInt (var RecordLongInt : RecordLongIntType;                          ThePort:WindowPtr); procedure CloseRecordLongInt (var RecordLongInt : RecordLongIntType); procedure AddToRecordLongInt (var RecordLongInt : RecordLongIntType;         Numbers : RecordLongIntDataType;         ThePort:WindowPtr;         var error:Boolean);  procedure SetGetAddRecordLongInt (var TheRecordLongInt : RecordLongIntType;         var Numbers : RecordLongIntDataType;         Loc:LongInt;         SetGetAdd:Integer;         ThePort:WindowPtr);     procedure DrawRecordLongInt (var TheRecordLongInt : RecordLongIntType;              ThePort:WindowPtr);  Procedure SaveRecordLongIntAsText (var TheRecordLongInt : RecordLongIntType;          Reply:SFReply;          var OutPut:Text); Procedure LoadRecordLongIntAsText (var TheRecordLongInt : RecordLongIntType;          Reply:SFReply;          var Input:Text);  procedure RecordLongIntDisplayDialog (var RecordLongInt : RecordLongIntType;                      ThePort:WindowPtr);  procedure RecordLongIntDataDialog (var RecordLongInt : RecordLongIntType;                      ThePort:WindowPtr); procedure RecordLongIntAnal(var RecordLongIntAnal:RecordLongIntAnalType;            var RecordLongInt : RecordLongIntType); procedure RecordLongIntInfoDialog (var RecordLongInt : RecordLongIntType);implementationprocedure CheckRecordLongInt( var RecordLongInt : RecordLongIntType); begin    if RecordLongInt.RecordLongIntinfo.NumberPerRecord>NumberPerRecordLimitRecordLongInt then        begin            RecordLongInt.RecordLongIntinfo.NumberPerRecord:=NumberPerRecordLimitRecordLongInt;            OKDialog('Number Per record Greater Than Limit');        end; end; procedure InitRecordLongInt {(var RecordLongInt : RecordLongIntType;                      ThePort:WindowPtr)};     begin    CheckRecordLongInt( RecordLongInt);    RecordLongInt.CurrDataSegmentHandle:=RecordLongIntDataSegmentHandle(NewHandle(SizeOf(RecordLongIntDataSegmentType)));    Hlock(Handle(RecordLongInt.CurrDataSegmentHandle));    RecordLongInt.CurrDataSegmentHandle^^.NextRecordLongIntDataSegmentHandle:=nil;    Hunlock(Handle(RecordLongInt.CurrDataSegmentHandle));    RecordLongInt.CurrNumberRecorded := 0;    RecordLongInt.DataSegmentHandle:=RecordLongInt.CurrDataSegmentHandle;    RecordLongInt.NumberRecorded := 0; end; procedure CloseRecordLongInt {(var RecordLongInt : RecordLongIntType)};      var    TheDataSegmentHandle:RecordLongIntDataSegmentHandle;     begin    While RecordLongInt.DataSegmentHandle<>nil do        begin            TheDataSegmentHandle:=RecordLongInt.DataSegmentHandle;            HLock(Handle(TheDataSegmentHandle));            RecordLongInt.DataSegmentHandle:=TheDataSegmentHandle^^.NextRecordLongIntDataSegmentHandle;            HUnlock(Handle(TheDataSegmentHandle));            DisposHandle(Handle(TheDataSegmentHandle));        end; end; procedure AddToRecordLongInt {(var RecordLongInt : RecordLongIntType;         Numbers : RecordLongIntDataType;         ThePort:WindowPtr;         var error:Boolean)};  var   i:integer;   TheDataSegmentHandle:RecordLongIntDataSegmentHandle;   OldPort:WindowPtr;    begin    GetPort(OldPort);    SetPort(ThePOrt);    Error:=False;    with RecordLongInt do        begin            if (RecordLongIntInfo.NumberToRecord > 0) then                begin                    HLock(Handle(CurrDataSegmentHandle));                    if (CurrNumberRecorded>=CurrNumberRecordedLimitRecordLongInt-RecordLongIntInfo.NumberPerRecord) then                        begin                             ResrvMem( SizeOf(RecordLongIntDataSegmentType));                            if memError = noerr then                                begin                                    TheDataSegmentHandle:=CurrDataSegmentHandle;                                    CurrDataSegmentHandle^^.NextRecordLongIntDataSegmentHandle :=                                         RecordLongIntDataSegmentHandle(NewHandle(SizeOf(RecordLongIntDataSegmentType)));                                    CurrDataSegmentHandle:=CurrDataSegmentHandle^^.NextRecordLongIntDataSegmentHandle;                                    HLock(Handle(CurrDataSegmentHandle));                                    HUnlock(Handle(TheDataSegmentHandle));                                    CurrDataSegmentHandle^^.NextRecordLongIntDataSegmentHandle:=nil;                                    CurrNumberRecorded:=0;                                end                            else                                begin                                    RecordLongIntInfo.NumberToRecord:=0;                                    OKDialog('Memory Full in add to Record integer');                                end;                        end;                                        if RecordLongIntInfo.NumberToRecord > 0 then                        begin                            for i := 1 to RecordLongIntInfo.NumberPerRecord do                                begin                                    CurrNumberRecorded:=CurrNumberRecorded+1;                                    CurrDataSegmentHandle^^.RecordLongIntDataSegment[CurrNumberRecorded]:=Numbers[i];                                end;                            RecordLongIntInfo.NumberToRecord:=RecordLongIntInfo.NumberToRecord-1;                            NumberRecorded:=NumberRecorded+1;                        end;                                            HUnlock(Handle(CurrDataSegmentHandle));                end            else                Error:=True;        end; end; procedure SetGetAddRecordLongInt {(var TheRecordLongInt : RecordLongIntType;         var Numbers : RecordLongIntDataType;         Loc:LongInt;         SetGetAdd:Integer;         ThePort:WindowPtr)};  var    i:integer;    CurrCount:Integer;    NumberPerSegment,Segments:integer;    NextDataSegmentHandle,TheDataSegment:RecordLongIntDataSegmentHandle;    begin     if TheRecordLongInt.NumberRecorded <> 0 then         begin         If Loc>(TheRecordLongInt.NumberRecorded) then            Loc:=TheRecordLongInt.NumberRecorded;         If Loc<0 then            Loc:=0;                   NumberPerSegment:=TheRecordLongInt.RecordLongIntinfo.NumberPerRecord             *(CurrNumberRecordedLimitRecordLongInt div TheRecordLongInt.RecordLongIntinfo.NumberPerRecord);                  CurrCount:=(Loc*TheRecordLongInt.RecordLongIntinfo.NumberPerRecord) mod NumberPerSegment;                  Segments:=(Loc*TheRecordLongInt.RecordLongIntinfo.NumberPerRecord) div NumberPerSegment;                  NextDataSegmentHandle:=TheRecordLongInt.DataSegmentHandle;         for i:= 1 to Segments do            begin                HLock(Handle(NextDataSegmentHandle));                TheDataSegment:=NextDataSegmentHandle;                NextDataSegmentHandle:=TheDataSegment^^.NextRecordLongIntDataSegmentHandle;                HUnlock(Handle(TheDataSegment));            end;                     TheDataSegment:=NextDataSegmentHandle;         HLock(Handle(TheDataSegment));         for i:= 1 to TheRecordLongInt.RecordLongIntInfo.NumberPerRecord do            begin                CurrCount:=CurrCount+1;                case SetGetAdd of                    0:TheDataSegment^^.RecordLongIntDataSegment[CurrCount]:=Numbers[i];                    1:Numbers[i]:=TheDataSegment^^.RecordLongIntDataSegment[CurrCount];                    2:begin                        TheDataSegment^^.RecordLongIntDataSegment[CurrCount]:=Numbers[i]                            +TheDataSegment^^.RecordLongIntDataSegment[CurrCount];                        Numbers[i]:=TheDataSegment^^.RecordLongIntDataSegment[CurrCount];                      end;                end;            end;                  HUnlock(Handle(TheDataSegment));     end; end;Procedure SaveRecordLongIntAsText {(var TheRecordLongInt : RecordLongIntType;          Reply:SFReply;          var OutPut:Text)};  var     i,j:integer;    CurrCount:Integer;    NextDataSegmentHandle,TheDataSegment:RecordLongIntDataSegmentHandle;    		begin			with TheRecordLongInt do				begin					writeln(Output,RecordLongIntInfo.NumberToRecord);     writeln(Output,RecordLongIntInfo.NumberPerRecord);     writeln(Output,RecordLongIntInfo.Title);         writeln(Output,RecordLongIntInfo.DrawOption);     writeln(Output,NumberRecorded);     NextDataSegmentHandle:=TheRecordLongInt.DataSegmentHandle;          i:=0;    While i<NumberRecorded do        begin            HLock(Handle(NextDataSegmentHandle));            TheDataSegment:=NextDataSegmentHandle;                        CurrCount:=0;            While (CurrCount< CurrNumberRecordedLimitRecordLongInt-                RecordLongIntinfo.NumberPerRecord) and (i<TheRecordLongInt.NumberRecorded) do                begin                   i:=i+1;                   for j:= 1 to TheRecordLongInt.RecordLongIntInfo.NumberPerRecord do                        begin                            CurrCount:=CurrCount+1;                            write(OutPut,TheDataSegment^^.RecordLongIntDataSegment[CurrCount],chr(9));                        end;                    writeln(Output);                end;            NextDataSegmentHandle:=TheDataSegment^^.NextRecordLongIntDataSegmentHandle;            HUnlock(Handle(TheDataSegment));        end;				end;		end;Procedure LoadRecordLongIntAsText {(var TheRecordLongInt : RecordLongIntType;          Reply:SFReply;          var InPut:Text)};  var     i,j:integer;    TheDataSegmentHandle,TheDataSegment:RecordLongIntDataSegmentHandle;    		begin   CloseRecordLongInt(TheRecordLongInt);			with TheRecordLongInt do				begin					Readln(Input,RecordLongIntInfo.NumberToRecord);     Readln(Input,RecordLongIntInfo.NumberPerRecord);     Readln(Input,RecordLongIntInfo.Title);         Readln(Input,RecordLongIntInfo.DrawOption);     Readln(Input,NumberRecorded);          DataSegmentHandle:=RecordLongIntDataSegmentHandle(NewHandle(SizeOf(RecordLongIntDataSegmentType)));     CurrDataSegmentHandle:=DataSegmentHandle;     HLock(Handle(CurrDataSegmentHandle));     CurrDataSegmentHandle^^.NextRecordLongIntDataSegmentHandle:=nil;      HunLock(Handle(CurrDataSegmentHandle));           i:=0;     HLock(Handle(CurrDataSegmentHandle));     CurrNumberRecorded:=0;     While i<TheRecordLongInt.NumberRecorded do         begin            i:=i+1;                        if (CurrNumberRecorded>=CurrNumberRecordedLimitRecordLongInt-RecordLongIntInfo.NumberPerRecord) then               begin                    ResrvMem( SizeOf(RecordLongIntDataSegmentType));                   if memError = noerr then                       begin                           TheDataSegmentHandle:=CurrDataSegmentHandle;                           CurrDataSegmentHandle^^.NextRecordLongIntDataSegmentHandle :=                                RecordLongIntDataSegmentHandle(NewHandle(SizeOf(RecordLongIntDataSegmentType)));                           CurrDataSegmentHandle:=CurrDataSegmentHandle^^.NextRecordLongIntDataSegmentHandle;                           HLock(Handle(CurrDataSegmentHandle));                           HUnlock(Handle(TheDataSegmentHandle));                           CurrDataSegmentHandle^^.NextRecordLongIntDataSegmentHandle:=nil;                           CurrNumberRecorded:=0;                       end                   else                       begin                           RecordLongIntInfo.NumberToRecord:=0;                           OKDialog('Memory Full in add to Record integer');                       end;               end;            for j:= 1 to TheRecordLongInt.RecordLongIntInfo.NumberPerRecord do                 begin                     CurrNumberRecorded:=CurrNumberRecorded+1;                     Read(Input,CurrDataSegmentHandle^^.RecordLongIntDataSegment[CurrNumberRecorded]);                 end;             Readln(Input);         end;       HUnlock(Handle(CurrDataSegmentHandle));     end;		end; procedure DrawRecordLongInt {(var TheRecordLongInt : RecordLongIntType;                      ThePort:WindowPtr)};  var   Box : rect;   Title:str255;   seconds:longint;   TheString:Str255;   OldPort:WindowPtr;     begin   GetPort(OldPort);   SetPort(ThePort);   Box:=ThePort^.portRect;   Box.Bottom:=Box.Bottom-15;   Box.Top:=Box.Bottom-30;   box.right:=Box.Right-15;   Title:=TheRecordLongInt.RecordLongIntInfo.title;   GetDateTime(Seconds);   IUDateString(Seconds,shortdate,TheString);   Title:=Title+' Last recorded '+TheString;   IUTimeString(Seconds,false,TheString);   Title:=Title+' '+TheString;      NumToString(TheRecordLongInt.NumberRecorded,TheSTring);   Title:=Title+' Number recorded '+TheString;      TextBox(POINTER(ORD(@Title) + 1), Length(Title), Box, TEJustCenter);   SetCursor(Arrow);   SetPort(OldPort);  end;  procedure SetGetRecordLongIntDisplayDialog (var RecordLongInt: RecordLongIntType;         var DialogPointer : DialogPtr;         SetGet : boolean); begin  with RecordLongInt.RecordLongIntinfo do   begin    setGetDlgLongInt(3, NumberToRecord, DialogPointer, SetGet);    SetgetDlgStr255(4, Title, DialogPointer, SetGet);    SelectText(DialogPointer,3);   end; end; procedure RecordLongIntDisplayDialog {(var RecordLongInt : RecordLongIntType;                      ThePort:WindowPtr)};  var   DialogPointer : DialogPtr;  OldPOrt:WindowPtr;   begin  GetPort(OldPort);  DialogPointer := GetNewDialog(RecordLongIntDisplayID, nil, pointer(-1));  SetGetRecordLongIntDisplayDialog(RecordLongInt, dialogPointer, true);  ShowHide(DialogPointer, true);  Modal( OKCancelType, DialogPointer);  if not cancelButton then   SetGetRecordLongIntDisplayDialog(RecordLongInt, DialogPointer, false);  DisposDialog(DialogPointer);  CheckRecordLongInt( RecordLongInt);  SetPort(OldPOrt); end; procedure SetGetRecordLongIntDataDialog (var RecordLongInt : RecordLongIntType;         var DialogPointer : DialogPtr;         SetGet : boolean); begin  with RecordLongInt.RecordLongIntinfo do   begin    setGetDlgLongInt(3, NumberToRecord, DialogPointer, SetGet);    setGetDlginteger(4, NumberPerRecord, DialogPointer, SetGet);    SelectText(DialogPointer,3);   end; end; procedure RecordLongIntDataDialog { (var RecordLongInt: RecordLongIntType;                      ThePort:WindowPtr)};  var   DialogPointer : DialogPtr;  OldPOrt:WIndowPtr;   begin  GetPort(OldPort);  DialogPointer := GetNewDialog(RecordLongIntDataID, nil, pointer(-1));  SetGetRecordLongIntDataDialog(RecordLongInt, dialogPointer, true);  ShowHide(DialogPointer, true);  Modal( OKCancelType, DialogPointer);  if not CancelButton then    begin      OKCancelDialog('Changing a RecordLongInts data ranges erases the RecordLongInt');      if not CancelButton then        begin          SetGetRecordLongIntDataDialog(RecordLongInt, DialogPointer, false);          CloseRecordLongInt(RecordLongInt);          InitRecordLongInt(RecordLongInt,ThePort);        end;    end;  DisposDialog(DialogPointer);  CheckRecordLongInt( RecordLongInt);  SetPOrt(OldPOrt) end;  procedure RecordLongIntAnal{(var RecordLongIntAnal:RecordLongIntAnalType;            var RecordLongInt : RecordLongIntType)};   var    i,j,CurrCount:integer;    TheValue:real;    NextDataSegmentHandle,TheDataSegment:RecordLongIntDataSegmentHandle;      begin    for i:=1 to RecordLongInt.RecordLongIntInfo.NumberPerRecord do      begin        RecordLongIntAnal[i].Mean:=0;        RecordLongIntAnal[i].Maximum:=-inf;        RecordLongIntAnal[i].Minimum:=inf;        RecordLongIntAnal[i].StandardDev:=0;        RecordLongIntAnal[i].Number:=RecordLongInt.NumberRecorded      end;           NextDataSegmentHandle:=RecordLongInt.DataSegmentHandle;     i:=0;    While i<RecordLongInt.NumberRecorded do        begin            HLock(Handle(NextDataSegmentHandle));            TheDataSegment:=NextDataSegmentHandle;                        CurrCount:=0;            While (CurrCount< CurrNumberRecordedLimitRecordLongInt-                RecordLongInt.RecordLongIntinfo.NumberPerRecord) and (i<RecordLongInt.NumberRecorded) do                begin                   i:=i+1;                   for j:= 1 to RecordLongInt.RecordLongIntInfo.NumberPerRecord do                        begin                            CurrCount:=CurrCount+1;                                                        TheValue:=TheDataSegment^^.RecordLongIntDataSegment[CurrCount];                                                        if TheValue>RecordLongIntAnal[j].Maximum then                              RecordLongIntAnal[j].Maximum:=TheValue;                            if TheValue<RecordLongIntAnal[j].Minimum then                              RecordLongIntAnal[j].Minimum:=TheValue;                                                        RecordLongIntAnal[j].Mean:=RecordLongIntAnal[j].Mean+TheValue;                            RecordLongIntAnal[j].StandardDev:=RecordLongIntAnal[j].StandardDev+TheValue*TheValue;                        end;                end;            NextDataSegmentHandle:=TheDataSegment^^.NextRecordLongIntDataSegmentHandle;            HUnlock(Handle(TheDataSegment));        end;                   for i:=1 to RecordLongInt.RecordLongIntInfo.NumberPerRecord do      RecordLongIntAnal[i].Mean:=RecordLongIntAnal[i].Mean/RecordLongInt.NumberRecorded;        for i:=1 to RecordLongInt.RecordLongIntInfo.NumberPerRecord do      RecordLongIntAnal[i].StandardDev:=        Sqrt((RecordLongIntAnal[i].StandardDev/RecordLongInt.NumberRecorded)            -(RecordLongIntAnal[i].Mean*RecordLongIntAnal[i].Mean));   end;    procedure SetGetRecordLongIntInfoDialog (var TheRecordLongIntAnal : RecordLongIntAnalType;         var DialogPointer : DialogPtr;         SetGet : boolean;         WhichOne:integer);     begin            setGetDlgReal(2, TheRecordLongIntAnal[WhichOne].Mean, DialogPointer, SetGet);    setGetDlgReal(3, TheRecordLongIntAnal[WhichOne].standardDev, DialogPointer, SetGet);    setGetDlgReal(4, TheRecordLongIntAnal[WhichOne].Maximum, DialogPointer, SetGet);    setGetDlgReal(5, TheRecordLongIntAnal[WhichOne].minimum, DialogPointer, SetGet);    setGetDlgLongInt(6, TheRecordLongIntAnal[WhichOne].number, DialogPointer, SetGet);  end; procedure RecordLongIntInfoDialog { (var RecordLongInt : RecordLongIntType)};  var    DialogPointer : DialogPtr;    i:integer;    TheRecordLongIntAnal:RecordLongIntAnalType;    OldPort:WindowPtr;     begin  GetPort(OldPort);  RecordLongIntAnal(TheRecordLongIntAnal,RecordLongInt);  for i:= 1 to RecordLongInt.RecordLongIntInfo.NumberPerRecord do    begin      DialogPointer := GetNewDialog(RecordLongIntinfoID, nil, pointer(-1));      SetGetRecordLongIntinfoDialog(TheRecordLongIntAnal, dialogPointer, true,i);      ShowHide(DialogPointer, true);      Modal( OKType, DialogPointer);      DisposDialog(DialogPointer);    end;  SetPort(OldPOrt); end; begin end.